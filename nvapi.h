 /***************************************************************************\
|*                                                                           *|
|*      Copyright 2005-2009 NVIDIA Corporation.  All rights reserved.        *|
|*                                                                           *|
|*   THE SOFTWARE AND INFORMATION CONTAINED HEREIN IS PROPRIETARY AND        *|
|*   CONFIDENTIAL TO NVIDIA CORPORATION. THIS SOFTWARE IS FOR INTERNAL USE   *|
|*   ONLY AND ANY REPRODUCTION OR DISCLOSURE TO ANY PARTY OUTSIDE OF NVIDIA  *|
|*   IS STRICTLY PROHIBITED.                                                 *|
|*                                                                           *|
 \***************************************************************************/
///////////////////////////////////////////////////////////////////////////////
//
// Date: Aug 31, 2009
// File: nvapi.h
//
// NvAPI provides an interface to NVIDIA devices. This file contains the
// interface constants, structure definitions and function prototypes.
//
// Target Profile: all
// Target OS-Arch: windows
//
///////////////////////////////////////////////////////////////////////////////
#ifndef _NVAPI_H
#define _NVAPI_H

#pragma pack(push,8) // Make sure we have consistent structure packings

#ifdef __cplusplus
extern "C" {
#endif

// ====================================================
// Universal NvAPI Definitions
// ====================================================
#ifndef _WIN32
#define __cdecl
#endif

#define NVAPI_INTERFACE extern NvAPI_Status __cdecl

/* 64-bit types for compilers that support them, plus some obsolete variants */
#if defined(__GNUC__) || defined(__arm) || defined(__IAR_SYSTEMS_ICC__) || defined(__ghs__) || defined(_WIN64)
typedef unsigned long long NvU64; /* 0 to 18446744073709551615          */
#else
typedef unsigned __int64   NvU64; /* 0 to 18446744073709551615              */
#endif

// mac os 32-bit still needs this
#if (defined(macintosh) || defined(__APPLE__)) && !defined(__LP64__)
typedef signed long        NvS32; /* -2147483648 to 2147483647               */
#else
typedef signed int         NvS32; /* -2147483648 to 2147483647               */
#endif

// mac os 32-bit still needs this
#if ( (defined(macintosh) && defined(__LP64__) && (__NVAPI_RESERVED0__)) || \
      (!defined(macintosh) && defined(__NVAPI_RESERVED0__)) ) 
typedef unsigned int       NvU32; /* 0 to 4294967295                         */
#else
typedef unsigned long      NvU32; /* 0 to 4294967295                         */
#endif

typedef unsigned short   NvU16;
typedef unsigned char    NvU8;

#define NV_DECLARE_HANDLE(name) struct name##__ { int unused; }; typedef struct name##__ *name

// NVAPI Handles - These handles are retrieved from various calls and passed in to others in NvAPI
//                 These are meant to be opaque types.  Do not assume they correspond to indices, HDCs,
//                 display indexes or anything else.
//
//                 Most handles remain valid until a display re-configuration (display mode set) or GPU
//                 reconfiguration (going into or out of SLI modes) occurs.  If NVAPI_HANDLE_INVALIDATED
//                 is received by an app, it should discard all handles, and re-enumerate them.
//
NV_DECLARE_HANDLE(NvDisplayHandle);                // Display Device driven by NVIDIA GPU(s) (an attached display)
NV_DECLARE_HANDLE(NvUnAttachedDisplayHandle);      // Unattached Display Device driven by NVIDIA GPU(s)
NV_DECLARE_HANDLE(NvLogicalGpuHandle);             // One or more physical GPUs acting in concert (SLI)
NV_DECLARE_HANDLE(NvPhysicalGpuHandle);            // A single physical GPU
NV_DECLARE_HANDLE(NvEventHandle);                  // A handle to an event registration instance
NV_DECLARE_HANDLE(NvVisualComputingDeviceHandle);  // A handle to Visual Computing Device
NV_DECLARE_HANDLE(NvGSyncDeviceHandle);            // A handle to a GSync device
NV_DECLARE_HANDLE(NvVioHandle);                    // A handle to a SDI device
NV_DECLARE_HANDLE(NvTransitionHandle);             // A handle to address a single transition request
NV_DECLARE_HANDLE(NvAudioHandle);                  // Nvidia HD Audio Device
NV_DECLARE_HANDLE(NvIDMHandle);                    // A handle to a Win7 IDM-enabled display

typedef void* StereoHandle;

NV_DECLARE_HANDLE(NvSourceHandle);                 // Unique source handle on the system
NV_DECLARE_HANDLE(NvTargetHandle);                 // Unique target handle on the system

#define NVAPI_DEFAULT_HANDLE        0

#define NVAPI_GENERIC_STRING_MAX    4096
#define NVAPI_LONG_STRING_MAX       256
#define NVAPI_SHORT_STRING_MAX      64

typedef struct
{
    NvS32   sX;
    NvS32   sY;
    NvS32   sWidth;
    NvS32   sHeight;
} NvSBox;

#define NVAPI_MAX_PHYSICAL_GPUS             64
#define NVAPI_MAX_LOGICAL_GPUS              64
#define NVAPI_MAX_AVAILABLE_GPU_TOPOLOGIES  256
#define NVAPI_MAX_AVAILABLE_SLI_GROUPS      256
#define NVAPI_MAX_GPU_TOPOLOGIES            NVAPI_MAX_PHYSICAL_GPUS
#define NVAPI_MAX_GPU_PER_TOPOLOGY          8
#define NVAPI_MAX_DISPLAY_HEADS             2
#define NVAPI_MAX_DISPLAYS                  NVAPI_MAX_PHYSICAL_GPUS * NVAPI_MAX_DISPLAY_HEADS
#define NVAPI_MAX_ACPI_IDS                  16
#define NVAPI_MAX_VIEW_MODES                8
#define NV_MAX_HEADS                        4   // Maximum heads, each with NVAPI_DESKTOP_RES resolution
#define NVAPI_MAX_HEADS_PER_GPU             32

#define NV_MAX_HEADS        4   // Maximum heads, each with NVAPI_DESKTOP_RES resolution
#define NV_MAX_VID_STREAMS  4   // Maximum input video streams, each with a NVAPI_VIDEO_SRC_INFO
#define NV_MAX_VID_PROFILES 4   // Maximum output video profiles supported

#define NVAPI_SYSTEM_MAX_DISPLAYS           NVAPI_MAX_PHYSICAL_GPUS * NV_MAX_HEADS

typedef char NvAPI_String[NVAPI_GENERIC_STRING_MAX];
typedef char NvAPI_LongString[NVAPI_LONG_STRING_MAX];
typedef char NvAPI_ShortString[NVAPI_SHORT_STRING_MAX];

// =========================================================================================
// NvAPI Version Definition
// Maintain per structure specific version define using the MAKE_NVAPI_VERSION macro.
// Usage: #define NV_GENLOCK_STATUS_VER  MAKE_NVAPI_VERSION(NV_GENLOCK_STATUS, 1)
// =========================================================================================
#define MAKE_NVAPI_VERSION(typeName,ver) (NvU32)(sizeof(typeName) | ((ver)<<16))
#define GET_NVAPI_VERSION(ver) (NvU32)((ver)>>16)
#define GET_NVAPI_SIZE(ver) (NvU32)((ver) & 0xffff)

// ====================================================
// NvAPI Status Values
//    All NvAPI functions return one of these codes.
// ====================================================


typedef enum
{
    NVAPI_OK                                    =  0,      // Success
    NVAPI_ERROR                                 = -1,      // Generic error
    NVAPI_LIBRARY_NOT_FOUND                     = -2,      // nvapi.dll can not be loaded
    NVAPI_NO_IMPLEMENTATION                     = -3,      // not implemented in current driver installation
    NVAPI_API_NOT_INTIALIZED                    = -4,      // NvAPI_Initialize has not been called (successfully)
    NVAPI_INVALID_ARGUMENT                      = -5,      // invalid argument
    NVAPI_NVIDIA_DEVICE_NOT_FOUND               = -6,      // no NVIDIA display driver was found
    NVAPI_END_ENUMERATION                       = -7,      // no more to enum
    NVAPI_INVALID_HANDLE                        = -8,      // invalid handle
    NVAPI_INCOMPATIBLE_STRUCT_VERSION           = -9,      // an argument's structure version is not supported
    NVAPI_HANDLE_INVALIDATED                    = -10,     // handle is no longer valid (likely due to GPU or display re-configuration)
    NVAPI_OPENGL_CONTEXT_NOT_CURRENT            = -11,     // no NVIDIA OpenGL context is current (but needs to be)
    NVAPI_INVALID_POINTER                       = -14,     // An invalid pointer, usually NULL, was passed as a parameter
    NVAPI_NO_GL_EXPERT                          = -12,     // OpenGL Expert is not supported by the current drivers
    NVAPI_INSTRUMENTATION_DISABLED              = -13,     // OpenGL Expert is supported, but driver instrumentation is currently disabled
    NVAPI_EXPECTED_LOGICAL_GPU_HANDLE           = -100,    // expected a logical GPU handle for one or more parameters
    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE          = -101,    // expected a physical GPU handle for one or more parameters
    NVAPI_EXPECTED_DISPLAY_HANDLE               = -102,    // expected an NV display handle for one or more parameters
    NVAPI_INVALID_COMBINATION                   = -103,    // used in some commands to indicate that the combination of parameters is not valid
    NVAPI_NOT_SUPPORTED                         = -104,    // Requested feature not supported in the selected GPU
    NVAPI_PORTID_NOT_FOUND                      = -105,    // NO port ID found for I2C transaction
    NVAPI_EXPECTED_UNATTACHED_DISPLAY_HANDLE    = -106,    // expected an unattached display handle as one of the input param
    NVAPI_INVALID_PERF_LEVEL                    = -107,    // invalid perf level
    NVAPI_DEVICE_BUSY                           = -108,    // device is busy, request not fulfilled
    NVAPI_NV_PERSIST_FILE_NOT_FOUND             = -109,    // NV persist file is not found
    NVAPI_PERSIST_DATA_NOT_FOUND                = -110,    // NV persist data is not found
    NVAPI_EXPECTED_TV_DISPLAY                   = -111,    // expected TV output display
    NVAPI_EXPECTED_TV_DISPLAY_ON_DCONNECTOR     = -112,    // expected TV output on D Connector - HDTV_EIAJ4120.
    NVAPI_NO_ACTIVE_SLI_TOPOLOGY                = -113,    // SLI is not active on this device
    NVAPI_SLI_RENDERING_MODE_NOTALLOWED         = -114,    // setup of SLI rendering mode is not possible right now
    NVAPI_EXPECTED_DIGITAL_FLAT_PANEL           = -115,    // expected digital flat panel
    NVAPI_ARGUMENT_EXCEED_MAX_SIZE              = -116,    // argument exceeds expected size
    NVAPI_DEVICE_SWITCHING_NOT_ALLOWED          = -117,    // inhibit ON due to one of the flags in NV_GPU_DISPLAY_CHANGE_INHIBIT or SLI Active
    NVAPI_TESTING_CLOCKS_NOT_SUPPORTED          = -118,    // testing clocks not supported
    NVAPI_UNKNOWN_UNDERSCAN_CONFIG              = -119,    // the specified underscan config is from an unknown source (e.g. INF)
    NVAPI_TIMEOUT_RECONFIGURING_GPU_TOPO        = -120,    // timeout while reconfiguring GPUs
    NVAPI_DATA_NOT_FOUND                        = -121,    // Requested data was not found
    NVAPI_EXPECTED_ANALOG_DISPLAY               = -122,    // expected analog display
    NVAPI_NO_VIDLINK                            = -123,    // No SLI video bridge present
    NVAPI_REQUIRES_REBOOT                       = -124,    // NVAPI requires reboot for its settings to take effect
    NVAPI_INVALID_HYBRID_MODE                   = -125,    // the function is not supported with the current hybrid mode.
    NVAPI_MIXED_TARGET_TYPES                    = -126,    // The target types are not all the same
    NVAPI_SYSWOW64_NOT_SUPPORTED                = -127,    // the function is not supported from 32-bit on a 64-bit system
    NVAPI_IMPLICIT_SET_GPU_TOPOLOGY_CHANGE_NOT_ALLOWED = -128,    //there is any implicit GPU topo active. Use NVAPI_SetHybridMode to change topology.
    NVAPI_REQUEST_USER_TO_CLOSE_NON_MIGRATABLE_APPS = -129,      //Prompt the user to close all non-migratable apps.
    NVAPI_OUT_OF_MEMORY                         = -130,    // Could not allocate sufficient memory to complete the call
    NVAPI_WAS_STILL_DRAWING                     = -131,    // The previous operation that is transferring information to or from this surface is incomplete
    NVAPI_FILE_NOT_FOUND                        = -132,    // The file was not found
    NVAPI_TOO_MANY_UNIQUE_STATE_OBJECTS         = -133,    // There are too many unique instances of a particular type of state object
    NVAPI_INVALID_CALL                          = -134,    // The method call is invalid. For example, a method's parameter may not be a valid pointer
    NVAPI_D3D10_1_LIBRARY_NOT_FOUND             = -135,    // d3d10_1.dll can not be loaded
    NVAPI_FUNCTION_NOT_FOUND                    = -136,    // Couldn't find the function in loaded dll library
    NVAPI_INVALID_USER_PRIVILEDGE               = -137,    // Current User is not Admin 
    NVAPI_EXPECTED_NON_PRIMARY_DISPLAY_HANDLE   = -138,    // The handle corresponds to GDIPrimary
    NVAPI_EXPECTED_COMPUTE_GPU_HANDLE           = -139,    // Setting Physx GPU requires that the GPU is compute capable
    NVAPI_STEREO_NOT_INITIALIZED                = -140,    // Stereo part of NVAPI failed to initialize completely. Check if stereo driver is installed.
    NVAPI_STEREO_REGISTRY_ACCESS_FAILED         = -141,    // Access to stereo related registry keys or values failed.
    NVAPI_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED = -142, // Given registry profile type is not supported.
    NVAPI_STEREO_REGISTRY_VALUE_NOT_SUPPORTED   = -143,    // Given registry value is not supported.
    NVAPI_STEREO_NOT_ENABLED                    = -144,    // Stereo is not enabled and function needed it to execute completely.
    NVAPI_STEREO_NOT_TURNED_ON                  = -145,    // Stereo is not turned on and function needed it to execute completely.
    NVAPI_STEREO_INVALID_DEVICE_INTERFACE       = -146,    // Invalid device interface.
    NVAPI_STEREO_PARAMETER_OUT_OF_RANGE         = -147,    // Separation percentage or JPEG image capture quality out of [0-100] range.
    NVAPI_STEREO_FRUSTUM_ADJUST_MODE_NOT_SUPPORTED = -148, // Given frustum adjust mode is not supported.
    NVAPI_TOPO_NOT_POSSIBLE                     = -149,    // The mosaic topo is not possible given the current state of HW
    NVAPI_MODE_CHANGE_FAILED                    = -150,    // An attempt to do a display resolution mode change has failed
    NVAPI_D3D11_LIBRARY_NOT_FOUND               = -151,    // d3d11.dll/d3d11_beta.dll cannot be loaded.
    NVAPI_INVALID_ADDRESS                       = -152,    // Address outside of valid range.
    NVAPI_STRING_TOO_SMALL                      = -153,    // The pre-allocated string is too small to hold the result.
    NVAPI_MATCHING_DEVICE_NOT_FOUND             = -154,    // The input does not match any of the available devices.
    NVAPI_DRIVER_RUNNING                        = -155,    // Driver is running
    NVAPI_DRIVER_NOTRUNNING                     = -156,    // Driver is not running
    NVAPI_ERROR_DRIVER_RELOAD_REQUIRED          = -157,    // A driver reload is required to apply these settings
    NVAPI_SET_NOT_ALLOWED                       = -158,    // Intended Setting is not allowed
} NvAPI_Status;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Initialize
//
//   DESCRIPTION: Initializes NVAPI library. This must be called before any
//                other NvAPI_ function.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_ERROR            Something is wrong during the initialization process (generic error)
//                NVAPI_LIBRARYNOTFOUND  Can not load nvapi.dll
//                NVAPI_OK                  Initialized
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Initialize();

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetErrorMessage
//
//   DESCRIPTION: converts an NvAPI error code into a null terminated string
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: null terminated string (always, never NULL)
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetErrorMessage(NvAPI_Status nr,NvAPI_ShortString szDesc);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetInterfaceVersionString
//
//   DESCRIPTION: Returns a string describing the version of the NvAPI library.
//                Contents of the string are human readable.  Do not assume a fixed
//                format.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: User readable string giving info on NvAPI's version
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetInterfaceVersionString(NvAPI_ShortString szDesc);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetDisplayDriverVersion
//
//   DESCRIPTION: Returns a struct that describes aspects of the display driver
//                build.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////
typedef struct
{
    NvU32              version;             // Structure version
    NvU32              drvVersion;
    NvU32              bldChangeListNum;
    NvAPI_ShortString  szBuildBranchString;
    NvAPI_ShortString  szAdapterString;
} NV_DISPLAY_DRIVER_VERSION;
#define NV_DISPLAY_DRIVER_VERSION_VER  MAKE_NVAPI_VERSION(NV_DISPLAY_DRIVER_VERSION,1)
NVAPI_INTERFACE NvAPI_GetDisplayDriverVersion(NvDisplayHandle hNvDisplay, NV_DISPLAY_DRIVER_VERSION *pVersion);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_EnumNvidiaDisplayHandle
//
//   DESCRIPTION: Returns the handle of the NVIDIA display specified by the enum
//                index (thisEnum). The client should keep enumerating until it
//                returns NVAPI_END_ENUMERATION.
//
//                Note: Display handles can get invalidated on a modeset, so the calling applications need to
//                renum the handles after every modeset.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: either the handle pointer is NULL or enum index too big
//                NVAPI_OK: return a valid NvDisplayHandle based on the enum index
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA device found in the system
//                NVAPI_END_ENUMERATION: no more display device to enumerate.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_EnumNvidiaDisplayHandle(NvU32 thisEnum, NvDisplayHandle *pNvDispHandle);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_EnumNvidiaUnAttachedDisplayHandle
//
//   DESCRIPTION: Returns the handle of the NVIDIA UnAttached display specified by the enum
//                index (thisEnum). The client should keep enumerating till it
//                return error.
//
//                Note: Display handles can get invalidated on a modeset, so the calling applications need to
//                renum the handles after every modeset.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: either the handle pointer is NULL or enum index too big
//                NVAPI_OK: return a valid NvDisplayHandle based on the enum index
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA device found in the system
//                NVAPI_END_ENUMERATION: no more display device to enumerate.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_EnumNvidiaUnAttachedDisplayHandle(NvU32 thisEnum, NvUnAttachedDisplayHandle *pNvUnAttachedDispHandle);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_EnumPhysicalGPUs
//
//   DESCRIPTION: Returns an array of physical GPU handles.
//
//                Each handle represents a physical GPU present in the system.
//                That GPU may be part of a SLI configuration, or not be visible to the OS directly.
//
//                At least 1 GPU must be present in the system and running an NV display driver.
//
//                The array nvGPUHandle will be filled with physical GPU handle values.  The returned
//                gpuCount determines how many entries in the array are valid.
//
//                Note: In drivers older than 105.00, all physical GPU handles get invalidated on a modeset. So the calling applications
//                      need to renum the handles after every modeset.
//                      With drivers 105.00 and up all physical GPU handles are constant.
//                      Physical GPU handles are constant as long as the GPUs are not physically moved and the SBIOS VGA order is unchanged.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: nvGPUHandle or pGpuCount is NULL
//                NVAPI_OK: one or more handles were returned
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_EnumPhysicalGPUs(NvPhysicalGpuHandle nvGPUHandle[NVAPI_MAX_PHYSICAL_GPUS], NvU32 *pGpuCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_EnumLogicalGPUs
//
//   DESCRIPTION: Returns an array of logical GPU handles.
//
//                Each handle represents one or more GPUs acting in concert as a single graphics device.
//
//                At least 1 GPU must be present in the system and running an NV display driver.
//
//                The array nvGPUHandle will be filled with logical GPU handle values.  The returned
//                gpuCount determines how many entries in the array are valid.
//
//                Note: All logical GPUs handles get invalidated on a GPU topology change, so the calling application is required to
//                renum the logical GPU handles to get latest physical handle mapping after every GPU topology change activated
//                by a call to NvAPI_SetGpuTopologies.
//
//                To detect if SLI rendering is enabled please use NvAPI_D3D_GetCurrentSLIState
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: nvGPUHandle or pGpuCount is NULL
//                NVAPI_OK: one or more handles were returned
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_EnumLogicalGPUs(NvLogicalGpuHandle nvGPUHandle[NVAPI_MAX_LOGICAL_GPUS], NvU32 *pGpuCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetPhysicalGPUsFromDisplay
//
//   DESCRIPTION: Returns an array of physical GPU handles associated with the specified display.
//
//                At least 1 GPU must be present in the system and running an NV display driver.
//
//                The array nvGPUHandle will be filled with physical GPU handle values.  The returned
//                gpuCount determines how many entries in the array are valid.
//
//                If the display corresponds to more than one physical GPU, the first GPU returned
//                is the one with the attached active output.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hNvDisp is not valid; nvGPUHandle or pGpuCount is NULL
//                NVAPI_OK: one or more handles were returned
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetPhysicalGPUsFromDisplay(NvDisplayHandle hNvDisp, NvPhysicalGpuHandle nvGPUHandle[NVAPI_MAX_PHYSICAL_GPUS], NvU32 *pGpuCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_EnumPhysicalGPUsInternal
//
//   DESCRIPTION: Description and usage same as NvAPI_EnumPhysicalGPUs.  
//                Only Phsyx engine and Phsyx APIs can use this due to the WAR(for http://nvbugs/388093).
//                This WAR applies only for NvAPI_EnumPhysicalGPUs and NvAPI_EnumLogicalGPUs.
//                The WAR is for the list of apps like 3dmarkvantage.exe, crysis64.exe, etc 
//                we are returning fake logical and physical GPUs instead of system wide GPUs.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_EnumPhysicalGPUsInternal(NvPhysicalGpuHandle nvGPUHandle[NVAPI_MAX_PHYSICAL_GPUS], NvU32 *pGpuCount);
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_EnumLogicalGPUsInternal
//
//   DESCRIPTION: Description and usage same as NvAPI_EnumLogicalGPUs.  
//                Only Phsyx engine and Phsyx APIs can use this due to the WAR(for http://nvbugs/388093).
//                This WAR applies only for NvAPI_EnumLogicalGPUs and NvAPI_EnumPhysicalGPUs.
//                The WAR is for the list of apps like 3dmarkvantage.exe, crysis64.exe, etc 
//                we are returning fake logical and physical GPUs instead of system wide GPUs.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_EnumLogicalGPUsInternal(NvLogicalGpuHandle nvGPUHandle[NVAPI_MAX_LOGICAL_GPUS], NvU32 *pGpuCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetDisplayFromPhysicalGPU
//
//   DESCRIPTION: Returns a display a associated with a physical GPU handle.
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: nvGPUHandle is not valid; hNvDisp is NULL
//                NVAPI_OK: one handle was returned
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetDisplayFromPhysicalGPU(NvPhysicalGpuHandle nvGPUHandle, NvDisplayHandle *hNvDisp);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DISP_GetUnAttachedDisplayFromPhysicalGPU
//
//   DESCRIPTION: Returns an unattached display associated with a physical GPU handle.
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: nvGPUHandle is not valid; hNvDisp is NULL
//                NVAPI_OK: one handle was returned
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_GetUnAttachedDisplayFromPhysicalGPU(NvPhysicalGpuHandle nvGPUHandle, NvUnAttachedDisplayHandle *hUnAttachedNvDisp);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetAssociatedDisplayFromOutputId
//
//   DESCRIPTION: Returns a display a associated with a physical GPU handle and the outputId.
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: nvGPUHandle is not valid; hNvDisp is NULL
//                NVAPI_OK: one handle was returned
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetAssociatedDisplayFromOutputId(NvPhysicalGpuHandle nvGPUHandle, NvU32 outputId, NvDisplayHandle *hNvDisp);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetPhysicalGPUFromUnAttachedDisplay
//
//   DESCRIPTION: Returns a physical source GPU handle associated with the specified unattached display.
//                The source GPU is a physical render GPU which renders the frame buffer but may or may not drive the scan out.
//
//                At least 1 GPU must be present in the system and running an NV display driver.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hNvUnAttachedDisp is not valid or pPhysicalGpu is NULL.
//                NVAPI_OK: one or more handles were returned
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetPhysicalGPUFromUnAttachedDisplay(NvUnAttachedDisplayHandle hNvUnAttachedDisp, NvPhysicalGpuHandle *pPhysicalGpu);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_CreateDisplayFromUnAttachedDisplay
//
//   DESCRIPTION: The unattached display handle is converted to a active attached display handle.
//
//                At least 1 GPU must be present in the system and running an NV display driver.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hNvUnAttachedDisp is not valid or pNvDisplay is NULL.
//                NVAPI_OK: one or more handles were returned
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_CreateDisplayFromUnAttachedDisplay(NvUnAttachedDisplayHandle hNvUnAttachedDisp, NvDisplayHandle *pNvDisplay);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetLogicalGPUFromDisplay
//
//   DESCRIPTION: Returns the logical GPU handle associated with the specified display.
//
//                At least 1 GPU must be present in the system and running an NV display driver.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hNvDisp is not valid; pLogicalGPU is NULL
//                NVAPI_OK: one or more handles were returned
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetLogicalGPUFromDisplay(NvDisplayHandle hNvDisp, NvLogicalGpuHandle *pLogicalGPU);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DISP_GetLogicalCudaGPUFromDisplay
//
//   DESCRIPTION: Returns a logical GPU handle associated with the specified display.
//                On hybrid systems, this returns the GPU on which Cuda's work will be 
//                running (so the rendering GPU, not the scan-out GPU, unlike the behavior
//                of NvAPI_GetLogicalGPUFromDisplay).  This is a hotfix for bug 506582.  
//                For fixing bug 523171, we will need a more  comprehensive solution.
//
//                At least 1 GPU must be present in the system and running an NV display driver.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hNvDisp is not valid; pLogicalGPU is NULL
//                NVAPI_OK: one or more handles were returned
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_GetLogicalCudaGPUFromDisplay(NvDisplayHandle hNvDisp, NvLogicalGpuHandle *pLogicalGPU);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetLogicalGPUFromPhysicalGPU
//
//   DESCRIPTION: Returns the logical GPU handle associated with specified physical GPU handle.
//
//                At least 1 GPU must be present in the system and running an NV display driver.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hPhysicalGPU is not valid; pLogicalGPU is NULL
//                NVAPI_OK: one or more handles were returned
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetLogicalGPUFromPhysicalGPU(NvPhysicalGpuHandle hPhysicalGPU, NvLogicalGpuHandle *pLogicalGPU);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetPhysicalGPUsFromLogicalGPU
//
//   DESCRIPTION: Returns the physical GPU handles associated with the specified logical GPU handle.
//
//                At least 1 GPU must be present in the system and running an NV display driver.
//
//                The array hPhysicalGPU will be filled with physical GPU handle values.  The returned
//                gpuCount determines how many entries in the array are valid.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hLogicalGPU is not valid; hPhysicalGPU is NULL
//                NVAPI_OK: one or more handles were returned
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_LOGICAL_GPU_HANDLE: hLogicalGPU was not a logical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetPhysicalGPUsFromLogicalGPU(NvLogicalGpuHandle hLogicalGPU,NvPhysicalGpuHandle hPhysicalGPU[NVAPI_MAX_PHYSICAL_GPUS], NvU32 *pGpuCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetPhysicalGPUFromDisplay
//
//   DESCRIPTION: Returns a physical GPU handle associated with the specified attached display handle.
//                Note: This API reflects the GPU association that the OS is aware of unlike NvAPI_GetPhysicalGPUsFromDisplay.
//
//                At least 1 GPU must be present in the system and running an NV display driver.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hNvDisplay is not valid or pPhysicalGpu is NULL.
//                NVAPI_OK: one or more handles were returned
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetPhysicalGPUFromDisplay(NvDisplayHandle hNvDisplay, NvPhysicalGpuHandle *pPhysicalGpu);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetPhysicalGPUFromGPUID
//
//   DESCRIPTION: Returns the physical GPU handle associated with the RM's gpuId value.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: gpuId is zero or pPhysicalGPU is NULL
//                NVAPI_OK: handle was returned
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetPhysicalGPUFromGPUID(NvU32 gpuId, NvPhysicalGpuHandle *pPhysicalGPU);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetGPUIDfromPhysicalGPU
//
//   DESCRIPTION: Returns the GPUID for the queried GPU handle. This ID can be used to maintain persistence
//                in the calling applications when switching between GPU topologies.
//                Note: GPUIds are invalid if the graphics boards are physically removed or swapped.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hPhysicalGPU is NULL or invalid. Re-enumerate the gpu handles.
//                NVAPI_OK: handle was returned
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetGPUIDfromPhysicalGPU(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pGpuId);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DISP_GetTargetPhysicalGPUsFromUnAttachedDisplay
//
//   DESCRIPTION: Returns an array of physical display GPU handles which can possibly drive the specified unattached display handle.
//                The target GPU is a physical display GPU which can be used to drive scan out but may or may not renders the frame buffer. 
//
//                At least 1 GPU must be present in the system and running an NV display driver.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hNvUnAttachedDisp is not valid or pPhysicalGpu is NULL.
//                NVAPI_OK: one or more handles were returned
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_GetTargetPhysicalGPUsFromUnAttachedDisplay(NvUnAttachedDisplayHandle hNvUnAttachedDisp, NvPhysicalGpuHandle nvGPUHandle[NVAPI_MAX_PHYSICAL_GPUS], NvU32 *pGpuCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetAssociatedNvidiaDisplayHandle
//
//   DESCRIPTION: Returns the handle of the NVIDIA display that is associated
//                with the display name given.  Eg: "\\DISPLAY1"
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: either argument is NULL
//                NVAPI_OK: *pNvDispHandle is now valid
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA device maps to that display name
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetAssociatedNvidiaDisplayHandle(const char *szDisplayName, NvDisplayHandle *pNvDispHandle);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DISP_GetAssociatedUnAttachedNvidiaDisplayHandle
//
//   DESCRIPTION: Returns the handle of an unattached NVIDIA display that is 
//                associated with the display name given.  Eg: "\\DISPLAY1"
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: either argument is NULL
//                NVAPI_OK: *pNvUnAttachedDispHandle is now valid
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA device maps to that display name
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_GetAssociatedUnAttachedNvidiaDisplayHandle(const char *szDisplayName, NvUnAttachedDisplayHandle *pNvUnAttachedDispHandle);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetAssociatedNvidiaDisplayName
//
//   DESCRIPTION: Returns the display name given.  Eg: "\\DISPLAY1" using the NVIDIA display handle
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: either argument is NULL
//                NVAPI_OK: *pNvDispHandle is now valid
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA device maps to that display name
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetAssociatedNvidiaDisplayName(NvDisplayHandle NvDispHandle, NvAPI_ShortString szDisplayName);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetUnAttachedAssociatedDisplayName
//
//   DESCRIPTION: Returns the display name given.  Eg: "\\DISPLAY1" using the NVIDIA unattached display handle
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: either argument is NULL
//                NVAPI_OK: *pNvDispHandle is now valid
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA device maps to that display name
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetUnAttachedAssociatedDisplayName(NvUnAttachedDisplayHandle hNvUnAttachedDisp, NvAPI_ShortString szDisplayName);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_EnableHWCursor
//
//   DESCRIPTION: Enable hardware cursor support
//
//  SUPPORTED OS: Windows XP
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_EnableHWCursor(NvDisplayHandle hNvDisplay);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DisableHWCursor
//
//   DESCRIPTION: Disable hardware cursor support
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DisableHWCursor(NvDisplayHandle hNvDisplay);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetVBlankCounter
//
//   DESCRIPTION: get vblank counter
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetVBlankCounter(NvDisplayHandle hNvDisplay, NvU32 *pCounter);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_SetRefreshRateOverride
//   DESCRIPTION: Override the refresh rate on the given  display/outputsMask.
//                The new refresh rate can be applied right away in this API call or deferred to happen with the
//                next OS modeset. The override is only good for one modeset (doesn't matter it's deferred or immediate).
//
//  SUPPORTED OS: Windows XP
//
//
//         INPUT: hNvDisplay - the NVIDIA display handle. It can be NVAPI_DEFAULT_HANDLE or a handle
//                             enumerated from NvAPI_EnumNVidiaDisplayHandle().
//
//                outputsMask - a set of bits that identify all target outputs which are associated with the NVIDIA
//                              display handle to apply the refresh rate override. Note when SLI is enabled,  the
//                              outputsMask only applies to the GPU that is driving the display output.
//
//                refreshRate - the override value. "0.0" means cancel the override.
//
//
//                bSetDeferred - "0": apply the refresh rate override immediately in this API call.
//                               "1":  apply refresh rate at the next OS modeset.
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hNvDisplay or outputsMask is invalid
//                NVAPI_OK: the refresh rate override is correct set
//                NVAPI_ERROR: the operation failed
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetRefreshRateOverride(NvDisplayHandle hNvDisplay, NvU32 outputsMask, float refreshRate, NvU32 bSetDeferred);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetAssociatedDisplayOutputId
//
//   DESCRIPTION: Gets the active outputId associated with the display handle.
//
//  SUPPORTED OS: Windows XP and higher
//
//    PARAMETERS: hNvDisplay(IN) - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                outputId(OUT)  - The active display output id associated with the selected display handle hNvDisplay.
//                                 The outputid will have only one bit set. In case of clone or span this  will indicate the display
//                                 outputId of the primary display that the GPU is driving.
// RETURN STATUS: NVAPI_OK: call successful.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found.
//                NVAPI_EXPECTED_DISPLAY_HANDLE: hNvDisplay is not a valid display handle.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetAssociatedDisplayOutputId(NvDisplayHandle hNvDisplay, NvU32 *pOutputId);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetAssociatedDisplayOutputIdEx
//
//   DESCRIPTION: Gets the active outputId associated with the display handle.
//
//  SUPPORTED OS: Windows XP and higher
//
//    PARAMETERS: hNvDisplay(IN) - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                outputId(OUT)  - The active display output id associated with the selected display handle hNvDisplay.
//                                 The outputid will have only one bit set. In case of clone or span this  will indicate the display
//                                 outputId of the primary display that the GPU is driving.
//                gpuId(OUT)     - The gpu ID of the physical GPU associated with the selected display handle hNvDisplay.
// RETURN STATUS: NVAPI_OK: call successful.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found.
//                NVAPI_EXPECTED_DISPLAY_HANDLE: hNvDisplay is not a valid display handle.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetAssociatedDisplayOutputIdEx(NvDisplayHandle hNvDisplay, NvU32 *pOutputId, NvU32 *pGpuId);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetDisplayPortInfo
//
// DESCRIPTION:     This API returns the current DP related into on the specified device(monitor)
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:      hNvDisplay(IN) - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                  outputId(IN)   - The display output id. If it's "0" then the default outputId from NvAPI_GetAssociatedDisplayOutputId() will be used.
//                  pInfo(OUT)     - The display port info
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT: Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////
typedef enum
{
    NV_DP_1_62GBPS            = 6,
    NV_DP_2_70GBPS            = 0xA,
} NV_DP_LINK_RATE;

typedef enum
{
    NV_DP_1_LANE              = 1,
    NV_DP_2_LANE              = 2,
    NV_DP_4_LANE              = 4,
} NV_DP_LANE_COUNT;

typedef enum
{
    NV_DP_COLOR_FORMAT_RGB     = 0,
    NV_DP_COLOR_FORMAT_YCbCr422,
    NV_DP_COLOR_FORMAT_YCbCr444,
} NV_DP_COLOR_FORMAT;

typedef enum
{
    NV_DP_COLORIMETRY_RGB = 0,
    NV_DP_COLORIMETRY_YCbCr_ITU601,
    NV_DP_COLORIMETRY_YCbCr_ITU709,
} NV_DP_COLORIMETRY;

typedef enum
{
    NV_DP_DYNAMIC_RANGE_VESA  = 0,
    NV_DP_DYNAMIC_RANGE_CEA,
} NV_DP_DYNAMIC_RANGE;

typedef enum
{
    NV_DP_BPC_DEFAULT         = 0,
    NV_DP_BPC_6,
    NV_DP_BPC_8,
    NV_DP_BPC_10,
    NV_DP_BPC_12,
    NV_DP_BPC_16,
} NV_DP_BPC;

typedef struct
{
    NvU32               version;                     // structure version
    NvU32               dpcd_ver;                    // the DPCD version of the monitor
    NV_DP_LINK_RATE     maxLinkRate;                 // the max supported link rate
    NV_DP_LANE_COUNT    maxLaneCount;                // the max supported lane count
    NV_DP_LINK_RATE     curLinkRate;                 // the current link rate
    NV_DP_LANE_COUNT    curLaneCount;                // the current lane count
    NV_DP_COLOR_FORMAT  colorFormat;                 // the current color format
    NV_DP_DYNAMIC_RANGE dynamicRange;                // the dynamic range
    NV_DP_COLORIMETRY   colorimetry;                 // ignored in RGB space
    NV_DP_BPC           bpc;                         // the current bit-per-component;
    NvU32               isDp                   : 1;  // if the monitor is driven by display port
    NvU32               isInternalDp           : 1;  // if the monitor is driven by NV Dp transmitter
    NvU32               isColorCtrlSupported   : 1;  // if the color format change is supported
    NvU32               is6BPCSupported        : 1;  // if 6 bpc is supported
    NvU32               is8BPCSupported        : 1;  // if 8 bpc is supported
    NvU32               is10BPCSupported       : 1;  // if 10 bpc is supported
    NvU32               is12BPCSupported       : 1;  // if 12 bpc is supported
    NvU32               is16BPCSupported       : 1;  // if 16 bpc is supported
    NvU32               isYCrCb422Supported    : 1;  // if YCrCb422 is supported                                                  
    NvU32               isYCrCb444Supported    : 1;  // if YCrCb444 is supported
 } NV_DISPLAY_PORT_INFO;

#define NV_DISPLAY_PORT_INFO_VER   MAKE_NVAPI_VERSION(NV_DISPLAY_PORT_INFO,1)

NVAPI_INTERFACE NvAPI_GetDisplayPortInfo(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_DISPLAY_PORT_INFO *pInfo);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SetDisplayPort
//
// DESCRIPTION:     This API is used to setup DP related configurations.
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:      hNvDisplay(IN) - NVIDIA display handle. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                  outputId(IN)   - This display output ID, when it's "0" it means the default outputId generated from the return of NvAPI_GetAssociatedDisplayOutputId().
//                  pCfg(IN)       - The display port config structure. If pCfg is NULL, it means to use the driver's default value to setup.
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT: Invalid input parameter.
///////////////////////////////////////////////////////////////////////////////
typedef struct
{
    NvU32               version;                     // structure version - 2 is latest
    NV_DP_LINK_RATE     linkRate;                    // the link rate
    NV_DP_LANE_COUNT    laneCount;                   // the lane count
    NV_DP_COLOR_FORMAT  colorFormat;                 // the color format to set
    NV_DP_DYNAMIC_RANGE dynamicRange;                // the dynamic range
    NV_DP_COLORIMETRY   colorimetry;                 // ignored in RGB space
    NV_DP_BPC           bpc;                         // the current bit-per-component;
    NvU32               isHPD               : 1;     // if CPL is making this call due to HPD
    NvU32               isSetDeferred       : 1;     // requires an OS modeset to finalize the setup if set
    NvU32               isChromaLpfOff      : 1;     // force the chroma low_pass_filter to be off
    NvU32               isDitherOff         : 1;     // force to turn off dither
    NvU32               testLinkTrain       : 1;     // if testing mode, skip validation
    NvU32               testColorChange     : 1;     // if testing mode, skip validation
} NV_DISPLAY_PORT_CONFIG;

#define NV_DISPLAY_PORT_CONFIG_VER   MAKE_NVAPI_VERSION(NV_DISPLAY_PORT_CONFIG,2)
#define NV_DISPLAY_PORT_CONFIG_VER_1 MAKE_NVAPI_VERSION(NV_DISPLAY_PORT_CONFIG,1)
#define NV_DISPLAY_PORT_CONFIG_VER_2 MAKE_NVAPI_VERSION(NV_DISPLAY_PORT_CONFIG,2)

NVAPI_INTERFACE NvAPI_SetDisplayPort(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_DISPLAY_PORT_CONFIG *pCfg);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetHDMISupportInfo
//
// DESCRIPTION:     This API returns the current infoframe data on the specified device(monitor)
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      hNvDisplay(IN) - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                  outputId(IN)   - The display output id. If it's "0" then the default outputId from NvAPI_GetAssociatedDisplayOutputId() will be used.
//                  pInfo(OUT)     - The monitor and GPU's HDMI support info
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT: Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////
typedef struct
{
    NvU32      version;                     // structure version
    NvU32      isGpuHDMICapable       : 1;  // if the GPU can handle HDMI
    NvU32      isMonUnderscanCapable  : 1;  // if the monitor supports underscan
    NvU32      isMonBasicAudioCapable : 1;  // if the monitor supports basic audio
    NvU32      isMonYCbCr444Capable   : 1;  // if YCbCr 4:4:4 is supported
    NvU32      isMonYCbCr422Capable   : 1;  // if YCbCr 4:2:2 is supported
    NvU32      isMonxvYCC601Capable   : 1;  // if xvYCC 601 is supported
    NvU32      isMonxvYCC709Capable   : 1;  // if xvYCC 709 is supported
    NvU32      isMonHDMI              : 1;  // if the monitor is HDMI (with IEEE's HDMI registry ID)
    NvU32      EDID861ExtRev;               // the revision number of the EDID 861 extension
 } NV_HDMI_SUPPORT_INFO;

#define NV_HDMI_SUPPORT_INFO_VER  MAKE_NVAPI_VERSION(NV_HDMI_SUPPORT_INFO,1)

NVAPI_INTERFACE NvAPI_GetHDMISupportInfo(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_HDMI_SUPPORT_INFO *pInfo);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetInfoFrame
//
// DESCRIPTION:     This API returns the current infoframe data on the specified device(monitor)
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:      hNvDisplay(IN) - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                  outputId(IN)   - The display output id. If it's "0" then the default outputId from NvAPI_GetAssociatedDisplayOutputId() will be used.
//                  type(IN)       - The type of infoframe to set
//                  pInfoFrame(IN) - The infoframe data
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT: Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////
typedef enum _NV_INFOFRAME_TYPE
{
    NV_INFOFRAME_TYPE_AVI   = 2,
    NV_INFOFRAME_TYPE_SPD   = 3,
    NV_INFOFRAME_TYPE_AUDIO = 4,
    NV_INFOFRAME_TYPE_MS    = 5,
} NV_INFOFRAME_TYPE;

typedef struct
{
    NvU8 type;
    NvU8 version;
    NvU8 length;
} NV_INFOFRAME_HEADER;

// since this is for Windows OS so far, we use this bit little endian defination
// to handle the translation
typedef struct
{
    // byte 1
    NvU8 channelCount     : 3;
    NvU8 rsvd_bits_byte1  : 1;
    NvU8 codingType       : 4;

    // byte 2
    NvU8 sampleSize       : 2;
    NvU8 sampleRate       : 3;
    NvU8 rsvd_bits_byte2  : 3;

    // byte 3
    NvU8  byte3;

    // byte 4
    NvU8  speakerPlacement;

    // byte 5
    NvU8 rsvd_bits_byte5  : 3;
    NvU8 levelShift       : 4;
    NvU8 downmixInhibit   : 1;

    // byte 6~10
    NvU8 rsvd_byte6;
    NvU8 rsvd_byte7;
    NvU8 rsvd_byte8;
    NvU8 rsvd_byte9;
    NvU8 rsvd_byte10;

}NV_AUDIO_INFOFRAME;

typedef struct
{
    // byte 1
    NvU8 scanInfo                : 2;
    NvU8 barInfo                 : 2;
    NvU8 activeFormatInfoPresent : 1;
    NvU8 colorSpace              : 2;
    NvU8 rsvd_bits_byte1         : 1;

    // byte 2
    NvU8 activeFormatAspectRatio : 4;
    NvU8 picAspectRatio          : 2;
    NvU8 colorimetry             : 2;

    // byte 3
    NvU8 nonuniformScaling       : 2;
    NvU8 rgbQuantizationRange    : 2;
    NvU8 extendedColorimetry     : 3;
    NvU8 itContent               : 1;

    // byte 4
    NvU8 vic                     : 7;
    NvU8 rsvd_bits_byte4         : 1;

    // byte 5
    NvU8 pixelRepeat             : 4;
    NvU8 rsvd_bits_byte5         : 4;

    // byte 6~13
    NvU8 topBarLow;
    NvU8 topBarHigh;
    NvU8 bottomBarLow;
    NvU8 bottomBarHigh;
    NvU8 leftBarLow;
    NvU8 leftBarHigh;
    NvU8 rightBarLow;
    NvU8 rightBarHigh;

} NV_VIDEO_INFOFRAME;

typedef struct
{
    NV_INFOFRAME_HEADER    header;
    union
    {
        NV_AUDIO_INFOFRAME audio;
        NV_VIDEO_INFOFRAME video;
    }u;
} NV_INFOFRAME;
NVAPI_INTERFACE NvAPI_GetInfoFrame(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_INFOFRAME_TYPE type, NV_INFOFRAME *pInfoFrame);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SetInfoFrame
//
// DESCRIPTION:     This API returns the current infoframe data on the specified device(monitor)
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:      hNvDisplay(IN) - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                  outputId(IN)   - The display output id. If it's "0" then the default outputId from NvAPI_GetAssociatedDisplayOutputId() will be used.
//                  type(IN)       - The type of infoframe to set
//                  pInfoFrame(IN) - The infoframe data, NULL mean reset to the default value.
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT: Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_SetInfoFrame(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_INFOFRAME_TYPE type, NV_INFOFRAME *pInfoFrame);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SetInfoFrameState
//
// DESCRIPTION:     Disables or enabled the sending of infoframe packets. Currently, this is supported for audio packets only
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      hNvDisplay(IN) - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                  outputId(IN)   - The display output id. If it's "0" then the default outputId from NvAPI_GetAssociatedDisplayOutputId() will be used.
//                  type(IN)       - The type of infoframe to set
//                  state(IN)      - state of infoframe to set
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT: Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////

typedef struct _NV_INFOFRAME_STATE
{
    NvU32 bDisabled    :    1;       // enable or disable the infoframe when "bDriverCtrl" is 0
    NvU32 bDriverCtrl  :    1;       // if set, let the driver control the infoframe state and "bDisabled" is ignored.
    NvU32 reserved     :   30;
} NV_INFOFRAME_STATE;

NVAPI_INTERFACE NvAPI_SetInfoFrameState(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_INFOFRAME_TYPE type, NV_INFOFRAME_STATE *pState);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetInfoFrameState
//
// DESCRIPTION:     Gets the state of the infoframe. Currently, this is supported for audio packets only
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      hNvDisplay(IN) - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                  outputId(IN)   - The display output id. If it's "0" then the default outputId from NvAPI_GetAssociatedDisplayOutputId() will be used.
//                  type(IN)       - The type of infoframe to get state of
//                  state(OUT)      - state of infoframe
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT: Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_GetInfoFrameState(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_INFOFRAME_TYPE type, NV_INFOFRAME_STATE *pState);

typedef struct _NV_INFOFRAME_STATE_PVT
{
    NV_INFOFRAME_STATE  state;
    NvU32 bInHDMIBlackList :    1;   // ready only, indicate the monitor is in driver's HDMI black list
    NvU32 reserved         :   31;
} NV_INFOFRAME_STATE_PVT;

//  SUPPORTED OS: Windows Vista and higher
NVAPI_INTERFACE NvAPI_GetInfoFrameStatePvt(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_INFOFRAME_TYPE type, NV_INFOFRAME_STATE_PVT *pState);

typedef struct
{
    NvU32   version;                           // version info
    NvU32   dedicatedVideoMemory;              // size(in kb) of the physical framebuffer.
    NvU32   availableDedicatedVideoMemory;     // size(in kb) of the available physical framebuffer for allocating video memory surfaces.
    NvU32   systemVideoMemory;                 // size(in kb) of system memory the driver allocates at load time.
    NvU32   sharedSystemMemory;                // size(in kb) of shared system memory that driver is allowed to commit for surfaces across all allocations.

} NV_DISPLAY_DRIVER_MEMORY_INFO_V1;

typedef struct
{
    NvU32   version;                           // version info
    NvU32   dedicatedVideoMemory;              // size(in kb) of the physical framebuffer.
    NvU32   availableDedicatedVideoMemory;     // size(in kb) of the available physical framebuffer for allocating video memory surfaces.
    NvU32   systemVideoMemory;                 // size(in kb) of system memory the driver allocates at load time.
    NvU32   sharedSystemMemory;                // size(in kb) of shared system memory that driver is allowed to commit for surfaces across all allocations.
    NvU32   curAvailableDedicatedVideoMemory;  // size(in kb) of the current available physical framebuffer for allocating video memory surfaces.

} NV_DISPLAY_DRIVER_MEMORY_INFO_V2;

typedef NV_DISPLAY_DRIVER_MEMORY_INFO_V2 NV_DISPLAY_DRIVER_MEMORY_INFO;

#define NV_DISPLAY_DRIVER_MEMORY_INFO_VER_1  MAKE_NVAPI_VERSION(NV_DISPLAY_DRIVER_MEMORY_INFO_V1,1)
#define NV_DISPLAY_DRIVER_MEMORY_INFO_VER_2  MAKE_NVAPI_VERSION(NV_DISPLAY_DRIVER_MEMORY_INFO_V2,2)
#define NV_DISPLAY_DRIVER_MEMORY_INFO_VER    NV_DISPLAY_DRIVER_MEMORY_INFO_VER_2

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetMemoryInfo
//
//   DESCRIPTION:
//
//  SUPPORTED OS: Windows XP and higher
//
//    PARAMETERS: hPhysicalGpu(IN) - Handle for Physical GPU Handle for which Memory information is to be extracted.
//                pMemoryInfo(OUT) - The memory footprint available in the driver.
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pMemoryInfo is NULL.
//                NVAPI_OK: call successful.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found.
//                NVAPI_INCOMPATIBLE_STRUCT_VERSION: NV_DISPLAY_DRIVER_MEMORY_INFO structure version mismatch.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetMemoryInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_DISPLAY_DRIVER_MEMORY_INFO *pMemoryInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetDisplayDriverMemoryInfo
//
//   DESCRIPTION: Retrieves the display driver memory information for the active display handle.
//                In case of multiGPU scenario the physical framebuffer information is obtained for the GPU associated with active display handle.
//                In case of SLI physical framebuffer information is obtained only from the display owner GPU.
//
//  SUPPORTED OS: Windows XP and higher
//
//    PARAMETERS: hNvDisplay(IN) - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                pMemoryInfo(OUT) - The memory footprint available in the driver.
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pMemoryInfo is NULL.
//                NVAPI_OK: call successful.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found.
//                NVAPI_EXPECTED_DISPLAY_HANDLE: hNvDisplay is not a valid display handle.
//                NVAPI_INCOMPATIBLE_STRUCT_VERSION: NV_DISPLAY_DRIVER_MEMORY_INFO structure version mismatch.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetDisplayDriverMemoryInfo(NvDisplayHandle hNvDisplay, NV_DISPLAY_DRIVER_MEMORY_INFO *pMemoryInfo);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetDriverMemoryInfo
//
//   DESCRIPTION: Retrieves the display driver memory information for the active display handle.
//                In case of multiGPU scenario the physical framebuffer information is obtained for the GPU associated with active display handle.
//                In case of SLI physical framebuffer information is obtained only from the display owner GPU.
//
//  SUPPORTED OS: Windows XP and higher
//
//    PARAMETERS: hNvDisplay(IN) - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                pMemoryInfo(OUT) - The memory footprint available in the driver.
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pMemoryInfo is NULL.
//                NVAPI_OK: call successful.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found.
//                NVAPI_EXPECTED_DISPLAY_HANDLE: hNvDisplay is not a valid display handle.
//                NVAPI_INCOMPATIBLE_STRUCT_VERSION: NV_DISPLAY_DRIVER_MEMORY_INFO structure version mismatch.
//
///////////////////////////////////////////////////////////////////////////////
typedef struct
{
    NvU32   version;                        // version info
    NvU32   dedicatedVideoMemory;           // size(in kb) of the physical framebuffer.
    NvU32   systemVideoMemory;              // size(in kb) of system memory the driver allocates at load time.
    NvU32   sharedSystemMemory;             // size(in kb) of shared system memory that driver is allowed to commit for surfaces across all allocations.

} NV_DRIVER_MEMORY_INFO;

#define NV_DRIVER_MEMORY_INFO_VER   MAKE_NVAPI_VERSION(NV_DRIVER_MEMORY_INFO,1)

NVAPI_INTERFACE NvAPI_GetDriverMemoryInfo(NvDisplayHandle hNvDisplay, NV_DRIVER_MEMORY_INFO *pMemoryInfo);



typedef struct
{
    NvU32   version;            //IN version info  
    NvU32   currentLevel;       //OUT current DVC level
    NvU32   minLevel;           //OUT min range level
    NvU32   maxLevel;           //OUT max range level
} NV_DISPLAY_DVC_INFO;

#define NV_DISPLAY_DVC_INFO_VER  MAKE_NVAPI_VERSION(NV_DISPLAY_DVC_INFO,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetDVCInfo
//
//   DESCRIPTION: Retrieves the Digital Vibrance Control(DVC) information of the selected display.
//
//  SUPPORTED OS: Windows XP and higher
//
//    PARAMETERS: hNvDisplay(IN) - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                outputId(IN)   - One of the selected outputId retrieved from NvAPI_GPU_GetActiveOutputs or NvAPI_GetView, to identify the target
//                                 output in case multiple targets are associated with the selected hNvDisplay.
//                                 Can be NULL to pick the display output id associated with hNvDisplay.
//                pDVCInfo(OUT)  - The returned DVC information.
//
// RETURN STATUS: NVAPI_OK: call successful.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found.
//                NVAPI_EXPECTED_DISPLAY_HANDLE: hNvDisplay is not a valid display handle.
//                NVAPI_INVALID_ARGUMENT: pDVCInfo is NULL.
//                NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the NV_DISPLAY_DVC_INFO struct is not supported
//                NVAPI_NOT_SUPPORTED - DVC feature is not supported on the selected GPU
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetDVCInfo(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_DISPLAY_DVC_INFO *pDVCInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SetDVCLevel
//
//   DESCRIPTION: Sets the DVC level for the selected display.
//
//  SUPPORTED OS: Windows XP and higher
//
//    PARAMETERS: hNvDisplay(IN) - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                outputId(IN)   - One of the selected outputId retrieved from NvAPI_GPU_GetActiveOutputs or NvAPI_GetView, to identify the target
//                                 output in case multiple targets are associated with the selected hNvDisplay.
//                                 Can be NULL to pick the display output id associated with hNvDisplay.
//                level(IN)      - The new level to apply. Value should be within the range of min and max.
//
// RETURN STATUS: NVAPI_OK: call successful.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found.
//                NVAPI_EXPECTED_DISPLAY_HANDLE: hNvDisplay is not a valid display handle.
//                NVAPI_NOT_SUPPORTED - DVC is not supported on the selected GPU
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetDVCLevel(NvDisplayHandle hNvDisplay, NvU32 outputId, NvU32 level);


typedef struct
{
    NvU32   version;            //IN version info  
    NvS32   currentLevel;       //OUT current DVC level
    NvS32   minLevel;           //OUT min range level
    NvS32   maxLevel;           //OUT max range level
    NvS32   defaultLevel;       //OUT default DVC level
} NV_DISPLAY_DVC_INFO_EX;

#define NV_DISPLAY_DVC_INFO_EX_VER  MAKE_NVAPI_VERSION(NV_DISPLAY_DVC_INFO_EX,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetDVCInfoEx
//
//   DESCRIPTION: Retrieves the Digital Vibrance Control(DVC) information of the selected display.
//
//  SUPPORTED OS: Windows XP and higher
//
//    PARAMETERS: hNvDisplay(IN) - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                outputId(IN)   - One of the selected outputId retrieved from NvAPI_GPU_GetActiveOutputs or NvAPI_GetView, to identify the target
//                                 output in case multiple targets are associated with the selected hNvDisplay.
//                                 Can be NULL to pick the display output id associated with hNvDisplay.
//                pDVCInfo(OUT)  - The returned DVC information.
//
// RETURN STATUS: NVAPI_OK: call successful.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found.
//                NVAPI_EXPECTED_DISPLAY_HANDLE: hNvDisplay is not a valid display handle.
//                NVAPI_INVALID_ARGUMENT: pDVCInfo is NULL.
//                NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the NV_DISPLAY_DVC_INFO struct is not supported
//                NVAPI_NOT_SUPPORTED - DVC feature is not supported on the selected GPU
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetDVCInfoEx(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_DISPLAY_DVC_INFO_EX *pDVCInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SetDVCLevelEx
//
//   DESCRIPTION: Sets the DVC level for the selected display.
//
//  SUPPORTED OS: Windows XP and higher
//
//    PARAMETERS: hNvDisplay(IN) - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                outputId(IN)   - One of the selected outputId retrieved from NvAPI_GPU_GetActiveOutputs or NvAPI_GetView, to identify the target
//                                 output in case multiple targets are associated with the selected hNvDisplay.
//                                 Can be NULL to pick the display output id associated with hNvDisplay.
//                dvcInfo(IN)    - The new DVC to apply. This structure can be accessed by GetDVCInfo API.
//
// RETURN STATUS: NVAPI_OK: call successful.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found.
//                NVAPI_EXPECTED_DISPLAY_HANDLE: hNvDisplay is not a valid display handle.
//                NVAPI_NOT_SUPPORTED - DVC is not supported on the selected GPU
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_SetDVCLevelEx(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_DISPLAY_DVC_INFO_EX *pDVCInfo);

typedef struct
{
    NvU32   version;            //IN version info
    NvU32   currentHueAngle;    //OUT current HUE Angle. Typically between 0 - 360 degrees
    NvU32   defaultHueAngle;    //OUT default HUE Angle
} NV_DISPLAY_HUE_INFO;

#define NV_DISPLAY_HUE_INFO_VER  MAKE_NVAPI_VERSION(NV_DISPLAY_HUE_INFO,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetHUEInfo
//
//   DESCRIPTION: Retrieves the HUE information of the selected display.
//
//  SUPPORTED OS: Windows XP and higher
//
//    PARAMETERS: hNvDisplay(IN) - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                outputId(IN)   - One of the selected outputId retrieved from NvAPI_GPU_GetActiveOutputs or NvAPI_GetView, to identify the target 
//                                 output in case multiple targets are associated with the selected hNvDisplay.
//                                 Can be NULL to pick the display output id associated with hNvDisplay.
//                pHUEInfo(OUT)  - The returned HUE information.
//
// RETURN STATUS: NVAPI_OK: call successful.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVidia GPU driving a display was found.
//                NVAPI_EXPECTED_DISPLAY_HANDLE: hNvDisplay is not a valid display handle.
//                NVAPI_INVALID_ARGUMENT: pHUEInfo is NULL.
//                NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the NV_DISPLAY_HUE_INFO struct is not supported
//                NVAPI_NOT_SUPPORTED - HUE feature is not supported on the selected GPU
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetHUEInfo(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_DISPLAY_HUE_INFO *pHUEInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SetHUEAngle
//
//   DESCRIPTION: Sets the HUE level for the selected display.
//
//  SUPPORTED OS: Windows XP and higher
//
//    PARAMETERS: hNvDisplay(IN) - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                outputId(IN)   - One of the selected outputId retrieved from NvAPI_GPU_GetActiveOutputs or NvAPI_GetView, to identify the target 
//                                 output in case multiple targets are associated with the selected hNvDisplay.
//                                 Can be NULL to pick the display output id associated with hNvDisplay.
//                level(IN)      - The new level to apply. Value should be within the range of min and max.
//
// RETURN STATUS: NVAPI_OK: call successful.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVidia GPU driving a display was found.
//                NVAPI_EXPECTED_DISPLAY_HANDLE: hNvDisplay is not a valid display handle.
//                NVAPI_NOT_SUPPORTED - HUE feature is not supported on the selected GPU
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetHUEAngle(NvDisplayHandle hNvDisplay, NvU32 outputId, NvU32 hueAngle);

typedef struct
{
    NvU32   version;            //IN version info
    NvU32   currentLevel;       //OUT current Image Sharpening level
    NvU32   minLevel;           //OUT min range level
    NvU32   maxLevel;           //OUT max range level
} NV_DISPLAY_IMAGE_SHARPENING_INFO;

#define NV_DISPLAY_IMAGE_SHARPENING_INFO_VER  MAKE_NVAPI_VERSION(NV_DISPLAY_IMAGE_SHARPENING_INFO,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetImageSharpeningInfo
//
//   DESCRIPTION: Retrieves the Image Sharpening information of the selected display.
//
//  SUPPORTED OS: Windows XP and higher
//
//    PARAMETERS: hNvDisplay(IN) - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                outputId(IN)   - One of the selected outputId retrieved from NvAPI_GPU_GetActiveOutputs or NvAPI_GetView, to identify the target
//                                 output in case multiple targets are associated with the selected hNvDisplay.
//                                 Can be NULL to pick the display output id associated with hNvDisplay.
//                pImageSharpeningInfo(OUT)  - The returned Image Sharpening information.
//
// RETURN STATUS: NVAPI_OK: call successful.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found.
//                NVAPI_EXPECTED_DISPLAY_HANDLE: hNvDisplay is not a valid display handle.
//                NVAPI_INVALID_ARGUMENT: pImageSharpeningInfo is NULL.
//                NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the NV_DISPLAY_IMAGE_SHARPENING_INFO struct is not supported
//                NVAPI_NOT_SUPPORTED - Image Sharpening is not supported on the selected GPU
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetImageSharpeningInfo(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_DISPLAY_IMAGE_SHARPENING_INFO *pImageSharpeningInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SetImageSharpeningLevel
//
//   DESCRIPTION: Sets the Image Sharpening level for the selected display.
//
//  SUPPORTED OS: Windows XP and higher
//
//    PARAMETERS: hNvDisplay(IN) - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                outputId(IN)   - One of the selected outputId retrieved from NvAPI_GPU_GetActiveOutputs or NvAPI_GetView, to identify the target
//                                 output in case multiple targets are associated with the selected hNvDisplay.
//                                 Can be NULL to pick the display output id associated with hNvDisplay.
//                level(IN)      - The new level to apply. Value should be within the range of min and max.
//
// RETURN STATUS: NVAPI_OK: call successful.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found.
//                NVAPI_EXPECTED_DISPLAY_HANDLE: hNvDisplay is not a valid display handle.
//                NVAPI_NOT_SUPPORTED - Image Sharpening is not supported on the selected GPU
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetImageSharpeningLevel(NvDisplayHandle hNvDisplay, NvU32 outputId, NvU32 level);


#ifndef NV_VIDEO_POSTPROCESSING_DEFINE
#define NV_VIDEO_POSTPROCESSING_DEFINE

typedef struct
{
    NvU32 value;
    NvU32 min;
    NvU32 max;
} NV_VIDEO_POSTPROCESSING_RANGE_VALUE;

typedef enum
{
    NV_VIDEO_POSTPROCESSING_CAPS_FEATURE_SUPPORTED          = 0x00,
    NV_VIDEO_POSTPROCESSING_CAPS_FEATURE_NOT_SUPPORTED      = 0x01,
} NV_VIDEO_POSTPROCESSING_CAPS;


//Deinterlace

typedef enum _NV_VIDEO_POSTPROCESSING_DEINTERLACE_FEATURE
{
    NV_VIDEO_POSTPROCESSING_DEINTERLACE_FEATURE_DISABLE           = 0x00,
    NV_VIDEO_POSTPROCESSING_DEINTERLACE_FEATURE_ENABLE            = 0x01,
} NV_VIDEO_POSTPROCESSING_DEINTERLACE_FEATURE;

typedef enum _NV_VIDEO_POSTPROCESSING_DEINTERLACE_ALG
{
    NV_VIDEO_POSTPROCESSING_DEINTERLACE_ALG_BOB              = 0x01,
    NV_VIDEO_POSTPROCESSING_DEINTERLACE_ALG_WEAVE            = 0x02,
    NV_VIDEO_POSTPROCESSING_DEINTERLACE_ALG_SIMPLE_ADAPTIVE  = 0x03,
    NV_VIDEO_POSTPROCESSING_DEINTERLACE_ALG_GRADIENT_SIMPLE  = 0x04,
    NV_VIDEO_POSTPROCESSING_DEINTERLACE_ALG_GRADIENT_FULL    = 0x05,
    NV_VIDEO_POSTPROCESSING_DEINTERLACE_ALG_ADVANCED         = 0x06,
} NV_VIDEO_POSTPROCESSING_DEINTERLACE_ALG;

typedef enum _NV_VIDEO_POSTPROCESSING_DEINTERLACE_ENHANCE
{
    NV_VIDEO_POSTPROCESSING_DEINTERLACE_ENHANCE_DIR_SPATIAL_DEFAULT  = 0x01,
    NV_VIDEO_POSTPROCESSING_DEINTERLACE_ENHANCE_DIR_SPATIAL_SIMPLE   = 0x02,
    NV_VIDEO_POSTPROCESSING_DEINTERLACE_ENHANCE_DIR_SPATIAL_ADVANCED = 0x03,
} NV_VIDEO_POSTPROCESSING_DEINTERLACE_ENHANCE;

typedef enum _NV_VIDEO_POSTPROCESSING_DEINTERLACE_MISC
{
    NV_VIDEO_POSTPROCESSING_DEINTERLACE_MISC_NONE = 0x00,  // none so far

} NV_VIDEO_POSTPROCESSING_DEINTERLACE_MISC;

typedef struct
{
    NV_VIDEO_POSTPROCESSING_CAPS caps;
    NV_VIDEO_POSTPROCESSING_DEINTERLACE_FEATURE feature;
    NV_VIDEO_POSTPROCESSING_DEINTERLACE_ALG     alg;
    NV_VIDEO_POSTPROCESSING_DEINTERLACE_ENHANCE enhance;
    NV_VIDEO_POSTPROCESSING_DEINTERLACE_MISC    misc;
} NV_VIDEO_POSTPROCESSING_DEINTERLACE_INFO;


//Scaling

typedef enum _NV_VIDEO_POSTPROCESSING_SCALING_FEATURE
{
    NV_VIDEO_POSTPROCESSING_SCALING_FEATURE_DISABLE            = 0x00,
    NV_VIDEO_POSTPROCESSING_SCALING_FEATURE_ENABLE             = 0x01,
} NV_VIDEO_POSTPROCESSING_SCALING_FEATURE;

typedef enum _NV_VIDEO_POSTPROCESSING_SCALING_ALG
{
    NV_VIDEO_POSTPROCESSING_SCALING_ALG_DEFAULT                = 0x01,
    NV_VIDEO_POSTPROCESSING_SCALING_ALG_4x4FILTER              = 0x02,
} NV_VIDEO_POSTPROCESSING_SCALING_ALG;

typedef enum _NV_VIDEO_POSTPROCESSING_SCALING_ENHANCE
{
    NV_VIDEO_POSTPROCESSING_SCALING_ENHANCE_NONE               = 0x00,   // None so far
} NV_VIDEO_POSTPROCESSING_SCALING_ENHANCE;

typedef enum _NV_VIDEO_POSTPROCESSING_SCALING_MISC
{
    NV_VIDEO_POSTPROCESSING_SCALING_MISC_NONE                  = 0x00,  // none so far
} NV_VIDEO_POSTPROCESSING_SCALING_MISC;

typedef struct
{
    NV_VIDEO_POSTPROCESSING_CAPS caps;
    NV_VIDEO_POSTPROCESSING_SCALING_FEATURE feature;
    NV_VIDEO_POSTPROCESSING_SCALING_ALG     alg;
    NV_VIDEO_POSTPROCESSING_SCALING_ENHANCE enhance;
    NV_VIDEO_POSTPROCESSING_SCALING_MISC    misc;
} NV_VIDEO_POSTPROCESSING_SCALING_INFO;


//Cadence

typedef enum _NV_VIDEO_POSTPROCESSING_CADENCE_FEATURE
{
    NV_VIDEO_POSTPROCESSING_CADENCE_FEATURE_DISABLE            = 0x00,
    NV_VIDEO_POSTPROCESSING_CADENCE_FEATURE_ENABLE             = 0x01,
} NV_VIDEO_POSTPROCESSING_CADENCE_FEATURE;

typedef enum _NV_VIDEO_POSTPROCESSING_CADENCE_ALG
{
    NV_VIDEO_POSTPROCESSING_CADENCE_ALG_NONE                   = 0x00, //None so far
} NV_VIDEO_POSTPROCESSING_CADENCE_ALG;

typedef enum _NV_VIDEO_POSTPROCESSING_CADENCE_ENHANCE
{
    NV_VIDEO_POSTPROCESSING_CADENCE_ENHANCE_NONE               = 0x00,
    NV_VIDEO_POSTPROCESSING_CADENCE_ENHANCE_VOF                = 0x01,
} NV_VIDEO_POSTPROCESSING_CADENCE_ENHANCE;

typedef enum _NV_VIDEO_POSTPROCESSING_CADENCE_MISC
{
    NV_VIDEO_POSTPROCESSING_CADENCE_MISC_NONE                  = 0x00,  // none so far
} NV_VIDEO_POSTPROCESSING_CADENCE_MISC;

typedef struct
{
    NV_VIDEO_POSTPROCESSING_CAPS caps;
    NV_VIDEO_POSTPROCESSING_CADENCE_FEATURE feature;
    NV_VIDEO_POSTPROCESSING_CADENCE_ALG     alg;
    NV_VIDEO_POSTPROCESSING_CADENCE_ENHANCE enhance;
    NV_VIDEO_POSTPROCESSING_CADENCE_MISC    misc;
} NV_VIDEO_POSTPROCESSING_CADENCE_INFO;



//Edge Enhance

typedef enum _NV_VIDEO_POSTPROCESSING_EE_FEATURE
{
    NV_VIDEO_POSTPROCESSING_EE_FEATURE_DISABLE            = 0x00,
    NV_VIDEO_POSTPROCESSING_EE_FEATURE_ENABLE             = 0x01,
} NV_VIDEO_POSTPROCESSING_EE_FEATURE;

typedef enum _NV_VIDEO_POSTPROCESSING_EE_ALG
{
    NV_VIDEO_POSTPROCESSING_EE_ALG_NONE                   = 0x00, //None so far
} NV_VIDEO_POSTPROCESSING_EE_ALG;

typedef enum _NV_VIDEO_POSTPROCESSING_EE_ENHANCE
{
    NV_VIDEO_POSTPROCESSING_EE_ENHANCE_NONE                = 0x00,
} NV_VIDEO_POSTPROCESSING_EE_ENHANCE;

typedef enum _NV_VIDEO_POSTPROCESSING_EE_MISC
{
    NV_VIDEO_POSTPROCESSING_EE_MISC_NONE                  = 0x00,  // none so far
} NV_VIDEO_POSTPROCESSING_EE_MISC;

typedef struct
{
    NV_VIDEO_POSTPROCESSING_CAPS caps;
    NV_VIDEO_POSTPROCESSING_EE_FEATURE     feature;
    NV_VIDEO_POSTPROCESSING_EE_ALG         alg ;
    NV_VIDEO_POSTPROCESSING_EE_ENHANCE     enhance;
    NV_VIDEO_POSTPROCESSING_EE_MISC        misc;
    NV_VIDEO_POSTPROCESSING_RANGE_VALUE    rangeValue;
} NV_VIDEO_POSTPROCESSING_EE_INFO;

//Noise Reduction

typedef enum _NV_VIDEO_POSTPROCESSING_NR_FEATURE
{
    NV_VIDEO_POSTPROCESSING_NR_FEATURE_DISABLE            = 0x00,
    NV_VIDEO_POSTPROCESSING_NR_FEATURE_ENABLE             = 0x01,
} NV_VIDEO_POSTPROCESSING_NR_FEATURE;

typedef enum _NV_VIDEO_POSTPROCESSING_NR_ALG
{
    NV_VIDEO_POSTPROCESSING_NR_ALG_NONE                   = 0x00, //None so far
} NV_VIDEO_POSTPROCESSING_NR_ALG;

typedef enum _NV_VIDEO_POSTPROCESSING_NR_ENHANCE
{
    NV_VIDEO_POSTPROCESSING_NR_ENHANCE_NONE                = 0x00,
} NV_VIDEO_POSTPROCESSING_NR_ENHANCE;

typedef enum _NV_VIDEO_POSTPROCESSING_NR_MISC
{
    NV_VIDEO_POSTPROCESSING_NR_MISC_NONE                  = 0x00,  // none so far
} NV_VIDEO_POSTPROCESSING_NR_MISC;

typedef struct
{
    NV_VIDEO_POSTPROCESSING_CAPS caps;
    NV_VIDEO_POSTPROCESSING_NR_FEATURE     feature;
    NV_VIDEO_POSTPROCESSING_NR_ALG         alg;
    NV_VIDEO_POSTPROCESSING_NR_ENHANCE     enhance;
    NV_VIDEO_POSTPROCESSING_NR_MISC        misc;
    NV_VIDEO_POSTPROCESSING_RANGE_VALUE    rangeValue;
} NV_VIDEO_POSTPROCESSING_NR_INFO;


//Over Drive

typedef enum _NV_VIDEO_POSTPROCESSING_OVERDRIVE_FEATURE
{
    NV_VIDEO_POSTPROCESSING_OVERDRIVE_FEATURE_DISABLE            = 0x00,
    NV_VIDEO_POSTPROCESSING_OVERDRIVE_FEATURE_ENABLE             = 0x01,
} NV_VIDEO_POSTPROCESSING_OVERDRIVE_FEATURE;

typedef enum _NV_VIDEO_POSTPROCESSING_OVERDRIVE_ALG
{
    NV_VIDEO_POSTPROCESSING_OVERDRIVE_ALG_NONE                   = 0x00, //None so far
} NV_VIDEO_POSTPROCESSING_OVERDRIVE_ALG;

typedef enum _NV_VIDEO_POSTPROCESSING_OVERDRIVE_ENHANCE
{
    NV_VIDEO_POSTPROCESSING_OVERDRIVE_ENHANCE_NONE                = 0x00,
} NV_VIDEO_POSTPROCESSING_OVERDRIVE_ENHANCE;

typedef enum _NV_VIDEO_POSTPROCESSING_OVERDRIVE_MISC
{
    NV_VIDEO_POSTPROCESSING_OVERDRIVE_MISC_NONE                  = 0x00,  // none so far
} NV_VIDEO_POSTPROCESSING_OVERDRIVE_MISC;

typedef struct
{
    NV_VIDEO_POSTPROCESSING_CAPS caps;
    NV_VIDEO_POSTPROCESSING_OVERDRIVE_FEATURE feature;
    NV_VIDEO_POSTPROCESSING_OVERDRIVE_ALG     alg;
    NV_VIDEO_POSTPROCESSING_OVERDRIVE_ENHANCE enhance;
    NV_VIDEO_POSTPROCESSING_OVERDRIVE_MISC    misc;
} NV_VIDEO_POSTPROCESSING_OVERDRIVE_INFO;


//Postprocessing info struct
typedef struct
{
    NvU32 version;                                              // structure version
    NV_VIDEO_POSTPROCESSING_DEINTERLACE_INFO  deinterlaceInfo;  // deinterlace info struct
    NV_VIDEO_POSTPROCESSING_SCALING_INFO      scalingInfo;      // scaling info struct
    NV_VIDEO_POSTPROCESSING_CADENCE_INFO      cadenceInfo;      // cadence info struct
    NV_VIDEO_POSTPROCESSING_NR_INFO           nrInfo;           // noise reduction info struct
    NV_VIDEO_POSTPROCESSING_EE_INFO           eeInfo;           // edge enhance info struct
    NV_VIDEO_POSTPROCESSING_OVERDRIVE_INFO    overDriveInfo;    // overdrive info struct
} NV_VIDEO_POSTPROCESSING_CTRL_INFO;
#define NV_VIDEO_POSTPROCESSING_CTRL_NVAPI_VER MAKE_NVAPI_VERSION(NV_VIDEO_POSTPROCESSING_CTRL_INFO,1)

//Video Color control

//This range value is exclusive for color controls, special fields may be added in the future
typedef struct
{
    NvU32 value;
    NvU32 min;
    NvU32 max;
} NV_VIDEO_COLORCONTROL_RANGE_VALUE;

//Color control caps are different from post processing caps
typedef enum
{
    NV_VIDEO_COLORCONTROL_CAPS_FEATURE_SUPPORTED          = 0x00,
    NV_VIDEO_COLORCONTROL_CAPS_FEATURE_NOT_SUPPORTED      = 0x01,
} NV_VIDEO_COLORCONTROL_CAPS;

typedef enum _NV_VIDEO_COLORCONTROL_FEATURE
{
    NV_VIDEO_COLORCONTROL_FEATURE_DISABLE            = 0x00,
    NV_VIDEO_COLORCONTROL_FEATURE_ENABLE             = 0x01,
} NV_VIDEO_COLORCONTROL_FEATURE;

typedef enum _NV_VIDEO_COLORTEMP_FEATURE
{
    NV_VIDEO_COLORTEMP_FEATURE_DISABLE            = 0x00,
    NV_VIDEO_COLORTEMP_FEATURE_ENABLE             = 0x01,
} NV_VIDEO_COLORTEMP_FEATURE;

typedef enum _NV_VIDEO_GAMMA_FEATURE
{
    NV_VIDEO_GAMMA_FEATURE_DISABLE            = 0x00,
    NV_VIDEO_GAMMA_FEATURE_ENABLE_Y           = 0x01,
    NV_VIDEO_GAMMA_FEATURE_ENABLE_RGB         = 0x02,
} NV_VIDEO_GAMMA_FEATURE;

typedef enum _NV_VIDEO_COLOR_CONTROL_SETTING
{
    NV_VIDEO_COLORCONTROL_SETTING_OVERRIDE_APP_CTRLS  = 0x00,  // Overrides app control with nvapi settings
    NV_VIDEO_COLORCONTROL_SETTING_USE_APP_CTRLS       = 0x01,  // inverse of the above
                                                               // In the future we may add app profile setting here

}NV_VIDEO_COLORCONTROL_SETTING;

typedef struct
{
    NvU32 version;          // structure version

    NV_VIDEO_COLORCONTROL_SETTING colorControlSettings;

    //Set #1  brightness contrast hue and saturation
    NV_VIDEO_COLORCONTROL_CAPS            colorCaps;
    NV_VIDEO_COLORCONTROL_FEATURE         colorFeature;
    NV_VIDEO_COLORCONTROL_RANGE_VALUE     brightnessRangeValue;
    NV_VIDEO_COLORCONTROL_RANGE_VALUE     contrastRangeValue;
    NV_VIDEO_COLORCONTROL_RANGE_VALUE     hueRangeValue;
    NV_VIDEO_COLORCONTROL_RANGE_VALUE     saturationRangeValue;

    //Set #2  colorTemp
    NV_VIDEO_COLORCONTROL_CAPS            colorTempCaps;
    NV_VIDEO_COLORTEMP_FEATURE            colorTempFeature;
    NV_VIDEO_COLORCONTROL_RANGE_VALUE     colorTempRangeValue;

    //Set #3  Gamma
    NV_VIDEO_COLORCONTROL_CAPS            gammaCaps;
    NV_VIDEO_GAMMA_FEATURE                gammaFeature;

    NV_VIDEO_COLORCONTROL_RANGE_VALUE     yGammaRangeValue;
    NV_VIDEO_COLORCONTROL_RANGE_VALUE     rgbGammaRRangeValue;
    NV_VIDEO_COLORCONTROL_RANGE_VALUE     rgbGammaGRangeValue;
    NV_VIDEO_COLORCONTROL_RANGE_VALUE     rgbGammaBRangeValue;
} NV_VIDEO_COLORCONTROL_INFO;
#define NV_VIDEO_COLORCONTROL_NVAPI_VER MAKE_NVAPI_VERSION(NV_VIDEO_COLORCONTROL_INFO,1)




#endif // ifndef NV_VIDEO_POSTPROCESSING_DEFINE

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Video_PostProcessing_GetDefault
//
//   DESCRIPTION: Queries the video postprocessing default control info
//
//  SUPPORTED OS: Windows Vista and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_Video_PostProcessing_GetDefault(NvDisplayHandle hNvDisplay, NV_VIDEO_POSTPROCESSING_CTRL_INFO* pVideoPPCtrlInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Video_PostProcessing_Get
//
//   DESCRIPTION: Queries the video postprocessing current control info
//
//  SUPPORTED OS: Windows Vista and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_Video_PostProcessing_Get(NvDisplayHandle hNvDisplay, NV_VIDEO_POSTPROCESSING_CTRL_INFO* pVideoPPCtrlInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Video_PostProcessing_Set
//
//   DESCRIPTION: Sets the video postprocessing current control info
//
//  SUPPORTED OS: Windows Vista and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_Video_PostProcessing_Set(NvDisplayHandle hNvDisplay, NV_VIDEO_POSTPROCESSING_CTRL_INFO* pVideoPPCtrlInfo);



//color control apis


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Video_ColorControl_GetDefault
//
//   DESCRIPTION: Queries the video default color control info
//
//  SUPPORTED OS: Windows Vista and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_Video_ColorControl_GetDefault(NvDisplayHandle hNvDisplay, NV_VIDEO_COLORCONTROL_INFO* pVideoColorCtrlInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Video_ColorControl_Get
//
//   DESCRIPTION: Queries the video current color control info
//
//  SUPPORTED OS: Windows Vista and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_Video_ColorControl_Get(NvDisplayHandle hNvDisplay, NV_VIDEO_COLORCONTROL_INFO* pVideoColorCtrlInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Video_ColorControl_Set
//
//   DESCRIPTION: Sets the video current color control info
//
//  SUPPORTED OS: Windows Vista and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_Video_ColorControl_Set(NvDisplayHandle hNvDisplay, NV_VIDEO_COLORCONTROL_INFO* pVideoColorCtrlInfo);

//EVO Overlay LUT API
#define NV_EVO_VIDEO_LUT_VER  MAKE_NVAPI_VERSION(NV_EVO_VIDEO_LUT,1)
typedef struct {
    NvU16 Red;
    NvU16 Green;
    NvU16 Blue;
    NvU16 Unused;
} NVAPI_EVO_VIDEO_CLUTDATA;
#define EVO_LUT_ENTRIES 257

typedef NVAPI_EVO_VIDEO_CLUTDATA NVAPI_EVO_VIDEO_LUT[EVO_LUT_ENTRIES];

typedef struct
{
    NvU32 version;
    NVAPI_EVO_VIDEO_LUT lut;
} NV_EVO_VIDEO_LUT;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Video_EvoOverlayLUT_Get
//
//   DESCRIPTION: Sets the EVO Overlay LUT.  Verification use only.
//
//  SUPPORTED OS: Windows XP
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_Video_EvoOverlayLUT_Get(NvDisplayHandle hNvDisplay, NV_EVO_VIDEO_LUT* pLut);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Video_EvoOverlayLUT_Set
//
//   DESCRIPTION: Sets the EVO Overlay LUT.  Verification use only.
//
//  SUPPORTED OS: Windows XP
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_Video_EvoOverlayLUT_Set(NvDisplayHandle hNvDisplay, NV_EVO_VIDEO_LUT* pLut);


//-----------------------------------------------------------------------------
// DirectX APIs
//-----------------------------------------------------------------------------
typedef struct
{
    NvU32 version;                    // Structure version
    NvU32 maxNumAFRGroups;            // [OUT] The maximum possible value of numAFRGroups
    NvU32 numAFRGroups;               // [OUT] The number of AFR groups enabled in the system
    NvU32 currentAFRIndex;            // [OUT] The AFR group index for the frame currently being rendered
    NvU32 nextFrameAFRIndex;          // [OUT] What the AFR group index will be for the next frame (i.e. after calling Present)
    NvU32 previousFrameAFRIndex;      // [OUT] The AFR group index that was used for the previous frame (~0 if more than one frame has not been rendered yet)
    NvU32 bIsCurAFRGroupNew;          // [OUT] boolean: Is this frame the first time running on the current AFR group
} NV_GET_CURRENT_SLI_STATE;
#define NV_GET_CURRENT_SLI_STATE_VER  MAKE_NVAPI_VERSION(NV_GET_CURRENT_SLI_STATE,1)


#if defined(_D3D9_H_) || defined(__d3d10_h__)

NV_DECLARE_HANDLE(NVDX_ObjectHandle);  // DX Objects
static const NVDX_ObjectHandle NVDX_OBJECT_NONE = 0;

#endif //if defined(_D3D9_H_) || defined(__d3d10_h__)

#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D_GetCurrentSLIState
//
// DESCRIPTION:     Returns the current SLI state for this device.  The struct
//                  contains the number of AFR groups, the current AFR group index
//                  and what the AFR group index will be for the next frame.
//                  pDevice can be either a IDirect3DDevice9 or ID3D10Device ptr.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - error occurred
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_D3D_GetCurrentSLIState(IUnknown *pDevice, NV_GET_CURRENT_SLI_STATE *pSliState);

#endif //if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)

#if defined(_D3D9_H_) || defined(__d3d10_h__)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D_GetObjectHandleForResource
//
//   DESCRIPTION: Get a handle to a resource.
//
//         INPUT:  pDev      The ID3D10Device or IDirect3DDevice9 to use
//
//                 pResource The IDirect3DResource9 or ID3D10Resource of which
//                           we want the NvAPI handle
//
//        OUTPUT:  pHandle   A handle to the resource
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_OK if the handle was populated.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_GetObjectHandleForResource(
    IUnknown *pDevice,
    IUnknown *pResource,
    NVDX_ObjectHandle *pHandle);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D_SetResourceHint
//
//   DESCRIPTION: General purpose function for passing down various resource
//                related hints to the driver. Hints are divided into categories
//                and types within each category.
//
//  SUPPORTED OS: Windows XP and higher
//
//  INPUT: pDev            The ID3D10Device or IDirect3DDevice9 that is a using the resource
//         obj             Previously obtained HV resource handle
//         dwHintCategory  Category of the hints
//         dwHintType      A hint within this category
//         *pdwHintValue   Pointer to location containing hint value
// RETURN STATUS: an int which could be an NvAPI status or DX HRESULT code
//                NVAPI_OK               - function succeed
//                NVAPI_INVALID_ARGUMENT - bad argument(s) 
//                NVAPI_INVALID_CALL     - it is illegal to change a hint dynamically and  the resource was already bound.
// NVAPI_D3D_SETRESOURCEHINT_CATEGORY: valid categories for SetResourceHint

typedef enum _NVAPI_D3D_SETRESOURCEHINT_CATEGORY
{
    NVAPI_D3D_SRH_CATEGORY_SLI = 1
} NVAPI_D3D_SETRESOURCEHINT_CATEGORY;

// NVAPI_D3D_SETRESOURCEHINT_SLI: types of SLI hints
//
//  NVAPI_D3D_SRH_SLI_APP_CONTROLLED_INTERFRAME_CONTENT_SYNC: 
//    valid values : 0 or 1
//    default value: 0
//    Explanation  : if the value is 1 the driver will not track any rendering operations that would mark this resource as dirty, 
//      avoiding any form of synchronization across frames rendered in parallel in multiple GPUs in AFR mode

typedef enum _NVAPI_D3D_SETRESOURCEHINT_SLI
{
    NVAPI_D3D_SRH_SLI_APP_CONTROLLED_INTERFRAME_CONTENT_SYNC = 1
}  NVAPI_D3D_SETRESOURCEHINT_SLI;

NVAPI_INTERFACE NvAPI_D3D_SetResourceHint(IUnknown *pDev, NVDX_ObjectHandle obj,
                                          NVAPI_D3D_SETRESOURCEHINT_CATEGORY dwHintCategory, 
                                          NvU32 dwHintName, 
                                          NvU32 *pdwHintValue);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D_BeginResourceRendering
//
//   DESCRIPTION: This function is used to tell the driver that the resource will begin to receive updates. Must be used in combination with NvAPI_D3D_EndResourceRendering. 
//                The primary use of this function is allow the driver to initiate early inter-frame syncs of resources while running in AFR SLI. 
//
//  SUPPORTED OS: Windows XP and higher
//
//         INPUT:  pDev         The ID3D10Device or IDirect3DDevice9 that is a using the resource
//                 obj          Previously obtained HV resource handle
//                 Flags        The flags for functionality applied to resource while being used.
//
// RETURN STATUS: NVAPI_OK      If used properely and driver can initiate proper syncing of the resources.
//                NVAPI_OK               - function succeed
//                NVAPI_INVALID_ARGUMENT - bad argument(s) or invalid flag values
//                NVAPI_INVALID_CALL     - miss-matched begin/end calls
//
///////////////////////////////////////////////////////////////////////////////
typedef enum  _NVAPI_D3D_RESOURCERENDERING_FLAG
{
    NVAPI_D3D_RR_FLAG_DEFAULTS                 = 0x00000000,  // All bits set to 0 are defaults.
    NVAPI_D3D_RR_FLAG_FORCE_DISCARD_CONTENT    = 0x00000001,  // (bit 0) The flag forces to discard previous content of the resource regardless of the NvApiHints_Sli_Disable_InterframeSync hint
    NVAPI_D3D_RR_FLAG_FORCE_KEEP_CONTENT       = 0x00000002   // (bit 1) The flag forces to respect previous content of the resource regardless of the NvApiHints_Sli_Disable_InterframeSync hint
} NVAPI_D3D_RESOURCERENDERING_FLAG;

NVAPI_INTERFACE NvAPI_D3D_BeginResourceRendering(IUnknown *pDev, NVDX_ObjectHandle obj, NvU32 Flags);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D_EndResourceRendering
//
//   DESCRIPTION: This function is used to tell the driver that the resource is done receiving updates. Must be used in combination with NvAPI_D3D_BeginResourceRendering. 
//                The primary use of this function is allow the driver to initiate early inter-frame syncs of resources while running in AFR SLI. 
//
//  SUPPORTED OS: Windows XP and higher
//
//         INPUT:  pDev         The ID3D10Device or IDirect3DDevice9 that is a using the resource
//                 obj          Previously obtained HV resource handle
//                 Flags        Reserved, must be zero.
//
// RETURN STATUS: NVAPI_OK      If used properely and driver can initiate proper syncing of the resources.
//                NVAPI_OK               - function succeed
//                NVAPI_INVALID_ARGUMENT - bad argument(s) or invalid flag values
//                NVAPI_INVALID_CALL     - miss-matched begin/end calls
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_EndResourceRendering(IUnknown *pDev, NVDX_ObjectHandle obj, NvU32 Flags);

#endif //if defined(_D3D9_H_) || defined(__d3d10_h__)


#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D_SetDriverDebugState (for DX9/DX10)
//
// DESCRIPTION:     This function sets internal driver state that affects debugging code
//
//  SUPPORTED OS: Windows XP and higher
// INPUT:           stateEnum    internal state to change (usually encoded as 'fourcc' name)
//                  stateValue   new state value
//
// RETURN STATUS:   NVAPI_OK     if the state changed was committed
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_SetDriverDebugState(IUnknown *pDev,
                                              NvU32     stateEnum,
                                              NvU32     stateValue);

#endif //if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)


#if defined(_D3D9_H_) || defined(__d3d10_h__)

///////////////////////////////////////////////////////////////////////////////
// NVAPI Query Types
///////////////////////////////////////////////////////////////////////////////

typedef enum _NVAPI_D3D_QUERY_TYPE
{
    NVAPI_D3D_QUERY_TYPE_RESERVED0       = 0,
    NVAPI_D3D_QUERY_TYPE_RESERVED1       = 1,
    NVAPI_D3D_QUERY_TYPE_PMTRIGGER       = 0,
    NVAPI_D3D_QUERY_TYPE_ZCULL_STATS     = 1,
}NVAPI_D3D_QUERY_TYPE;

typedef enum _NVAPI_D3D_QUERY_GETDATA_FLAGS
{
    NVAPI_D3D_QUERY_GETDATA_FLUSH      = 0,
    NVAPI_D3D_QUERY_GETDATA_DONOTFLUSH = 1
}NVAPI_D3D_QUERY_GETDATA_FLAGS;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D_CreateQuery
//
// DESCRIPTION:     Creates NVIDIA-specific D3D Query Objects.
//
// INPUT:           pDevice             The device to create this query object on
//
//                  type                Type of the query to be created (see NVAPI_D3D_QUERY_TYPE)
//
// OUTPUT:          pHandle             The handle to the Query object
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_INVALID_POINTER - pDevice was NULL
//                  NVAPI_INVALID_ARGUMENT - one of the arguments was not valid
//                  NVAPI_OUT_OF_MEMORY - unable to allocate sufficient memory to complete the call
//                  NVAPI_ERROR - error occurred
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_CreateQuery(IUnknown *pDevice, NVAPI_D3D_QUERY_TYPE type, NVDX_ObjectHandle *pHandle);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D_DestroyQuery
//
// DESCRIPTION:     Destroys NVIDIA-specific D3D Query Objects
//
// INPUT:           queryHandle         The handle to the Query object
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_INVALID_HANDLE - the Query object handle is invalid
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_DestroyQuery(NVDX_ObjectHandle queryHandle);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D_Query_Begin
//
// DESCRIPTION:     Mark the beginning of a series of commands
//
// INPUT:           queryHandle         The handle to the Query object
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_INVALID_HANDLE - the Query object handle is invalid
//                  NVAPI_INVALID_CALL - the call could not be completed
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_Query_Begin(NVDX_ObjectHandle queryHandle);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D_Query_End
//
// DESCRIPTION:     Mark the end of a series of commands
//
// INPUT:           queryHandle         The handle to the Query object
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_INVALID_HANDLE - the Query object handle is invalid
//                  NVAPI_INVALID_CALL - the call could not be completed
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_Query_End(NVDX_ObjectHandle queryHandle);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D_Query_GetData
//
// DESCRIPTION:     Polls a queried resource to get the query state or a query result.
//                  Allows getting data from the GPU or the driver asynchronously.
//
// INPUT:           queryHandle         The handle to the Query object.
//                  dwSize              Size of the data to retrieve or 0.
//                                      This value can be obtained with NvAPI_D3D_Query_GetDataSize.
//                  dwGetDataFlags      Optional flags. Can be 0 or any combination of NVAPI_D3D_QUERY_GETDATA_FLAGS
//
// OUTPUT:          pData               Address of memory that will receive the data. 
//                                      If NULL, GetData will be used only to check status
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_INVALID_HANDLE - the Query object handle is invalid
//                  NVAPI_INVALID_CALL - the call could not be completed
//                  NVAPI_DATA_NOT_FOUND - the Queried data was not yet available
//                  NVAPI_ERROR - error occurred
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_Query_GetData(NVDX_ObjectHandle queryHandle, void* pData, UINT dwSize, UINT dwGetDataFlags);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D_Query_GetDataSize
//
// DESCRIPTION:     Get the size of the data (in bytes) that is output when calling
//                  NvAPI_D3D_Query_GetData
//
// INPUT:           queryHandle         The handle to the Query object
//
// OUTPUT:          pDwSize             The requested size value
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_INVALID_HANDLE - the Query object handle is invalid
//                  NVAPI_INVALID_POINTER - pDwSize is NULL
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_Query_GetDataSize(NVDX_ObjectHandle queryHandle, UINT *pDwSize);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D_Query_GetType
//
// DESCRIPTION:     Get the NVAPI_D3D_QUERY_TYPE of the given query object
//
// INPUT:           queryHandle         The handle to the Query object
//
// OUTPUT:          pType               The requested NVAPI_D3D_QUERY_TYPE value
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_INVALID_HANDLE - the Query object handle is invalid
//                  NVAPI_INVALID_POINTER - pType is NULL
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_Query_GetType(NVDX_ObjectHandle queryHandle, NVAPI_D3D_QUERY_TYPE *pType);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D_GetDeviceKmtHandle
//
//   DESCRIPTION: This function retrieves the KMT handle for the device
//
//         INPUT:  pDev         The device whose handle we want
//
//        OUTPUT:  phDevice     The device's KMT handle
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_OK if and only if phDevice was populated with a valid
//                KMT handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_GetDeviceKmtHandle(IUnknown *pDev,
                                             NvU64* phDevice);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D_CudaInteropFunction
//
//   DESCRIPTION: Container for a handful of Cuda interop functions, including
//                open/close interop, register/unregister resource, map/unmap
//                resource, and sync.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_OK if the call succeeded
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_CudaInteropFunction(IUnknown *pDev,
                                              UINT dwFunction,
                                              void *pData);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D_CudaInteropGetObjectHandle
//
//   DESCRIPTION: Get a handle to a resource for use by cuda
//
//         INPUT:  pDev      The ID3D10Device or IDirect3DDevice9 to use
//
//                 pResource The IDirect3DResource9 or ID3D10Resource of which
//                           we want the NvAPI handle
//
//        OUTPUT:  pHandle   A handle to the resource
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_OK if the handle was populated.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_CudaInteropGetObjectHandle(
    IUnknown *pDevice,
    IUnknown *pResource,
    NVDX_ObjectHandle *pHandle);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D_RegisterApp
//
// DESCRIPTION:     Allow known dx10/dx9 app to register itself to enable specific driver modes
//
//  SUPPORTED OS: Windows Vista and higher
// INPUT: userAppId  - a predetermined number (from nvidia) so that the driver would
//                     turn on app specific features.
//                     If the code is not recognized, it would return NVAPI_NOT_SUPPORTED.
//                     Otherwise, it would return NVAPI_OK.
//
// RETURN STATUS: 
//  NVAPI_ERROR             - Registration failed
//  NVAPI_OK                - the app is supported
//  NVAPI_INVALID_ARGUMENT  - if bad parameters are given
//
// NOTE: 
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_RegisterApp(IUnknown *pDev, NvU32 userAppId);

#endif // defined(_D3D9_H_) || defined(__d3d10_h__)

//-----------------------------------------------------------------------------
// Direct3D9 APIs
//-----------------------------------------------------------------------------

#if defined(_D3D9_H_) && defined(__cplusplus)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_CreatePathContextNV
//
//	 DESCRIPTION:   This API call is part of the DX implementation of the 
//                  NV Path Library.
//                  Creates a new NVPL context.
//
//  SUPPORTED OS: Windows XP and higher
//
//	       INPUT:	pDevice - Direct3D 9 device
//
//		  OUTPUT:	context - NVPL context
//
// RETURN STATUS: a NvAPI status code or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
// NV Path Library data types
//--------------------------------------------------------------------------------------

typedef enum _NV_PATH_DATATYPE
{
	NV_BYTE						= 0,
    NV_UNSIGNED_BYTE,
    NV_SHORT,
    NV_UNSIGNED_SHORT,
    NV_INT,
    NV_UNSIGNED_INT,
    NV_FLOAT,
    NV_FIXED
} NvPathDataType;

typedef enum _NV_PATH_PARAMTYPE
{
    PATH_QUALITY_NV             = 0x8ED8,
    FILL_RULE_NV                = 0x8ED9,
    STROKE_CAP0_STYLE_NV        = 0x8EE0,
    STROKE_CAP1_STYLE_NV        = 0x8EE1,
    STROKE_CAP2_STYLE_NV        = 0x8EE2,
    STROKE_CAP3_STYLE_NV        = 0x8EE3,
    STROKE_JOIN_STYLE_NV        = 0x8EE8,
    STROKE_MITER_LIMIT_NV       = 0x8EE9
} NVPathParamType;

typedef enum _NV_PATH_FILLRULE
{
    EVEN_ODD_NV                 = 0x8EF0,
    NON_ZERO_NV                 = 0x8EF1
} NVPathFillRule;

typedef enum _NV_PATH_CAPSTYLE
{
    CAP_BUTT_NV                 = 0x8EF4,
    CAP_ROUND_NV                = 0x8EF5,
    CAP_SQUARE_NV               = 0x8EF6,
    CAP_TRIANGLE_NV             = 0x8EF7
} NVPathCapStyle;

typedef enum _NV_PATH_JOINSTYLE
{
    JOIN_MITER_NV               = 0x8EFC,
    JOIN_ROUND_NV               = 0x8EFD,
    JOIN_BEVEL_NV               = 0x8EFE,
    JOIN_CLIPPED_MITER_NV       = 0x8EFF
} NVPathJoinStyle;

typedef enum _NV_PATH_TARGETTYPE
{
    MATRIX_PATH_TO_CLIP_NV      = 0x8F04,
    MATRIX_STROKE_TO_PATH_NV    = 0x8F05,
    MATRIX_PATH_COORD0_NV       = 0x8F08,
    MATRIX_PATH_COORD1_NV       = 0x8F09,
    MATRIX_PATH_COORD2_NV       = 0x8F0A,
    MATRIX_PATH_COORD3_NV       = 0x8F0B
} NVPathTargetType;

typedef enum _NV_PATH_MODE
{
    FILL_PATH_NV                = 0x8F18,
    STROKE_PATH_NV              = 0x8F19
} NVPathMode;

typedef enum _NV_PATH_CMD
{
    MOVE_TO_NV                  = 0x00,
    LINE_TO_NV                  = 0x01,
    QUADRATIC_BEZIER_TO_NV      = 0x02,
    CUBIC_BEZIER_TO_NV          = 0x03,
    START_MARKER_NV             = 0x20,
    CLOSE_NV                    = 0x21,
    STROKE_CAP0_NV              = 0x40,
    STROKE_CAP1_NV              = 0x41,
    STROKE_CAP2_NV              = 0x42,
    STROKE_CAP3_NV              = 0x43,
} NVPathCmd;


NVAPI_INTERFACE NvAPI_D3D9_CreatePathContextNV(IDirect3DDevice9* pDevice, NvU32* context);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_DestroyPathContextNV
//
//	 DESCRIPTION:   This API call is part of the DX implementation of the 
//                  NV Path Library.
//                  Destroys a NVPL context. This function *MUST* be called
//					on all created path contexts or else memory leaks will
//					occur.
//
//  SUPPORTED OS: Windows XP and higher
//
//	       INPUT:	context - NVPL context
//
// RETURN STATUS: NVAPI_OK or NVAPI_INVALID_ARGUMENT
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_D3D9_DestroyPathContextNV(NvU32 context);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_CreatePathNV
//
//	 DESCRIPTION:   This API call is part of the DX implementation of the 
//                  NV Path Library.
//                  Creates a NVPL path. 
//
//  SUPPORTED OS: Windows XP and higher
//
//	       INPUT:	context		- NVPL context
//		   INPUT:	datatype	- Type of path vertex data
//		   INPUT:	numCommands	- Number of commands in path
//		   INPUT:	commands	- Path command buffer
//
//		  OUTPUT:	path		- Path handle
//
// RETURN STATUS: a NvAPI status code or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_D3D9_CreatePathNV(NvU32 context, NvPathDataType datatype, NvU32 numCommands, const NvU8* commands, NvU32* path);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_DeletePathNV
//
//	 DESCRIPTION:   This API call is part of the DX implementation of the 
//                  NV Path Library.
//                  Destroys a NVPL path. This function *MUST* be called
//					on all created paths or else memory leaks will occur.
//
//  SUPPORTED OS: Windows XP and higher
//
//	       INPUT:	path - NVPL path handle
//
// RETURN STATUS: NVAPI_OK or NVAPI_INVALID_ARGUMENT
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_D3D9_DeletePathNV(NvU32 path);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_PathVerticesNV
//
//	 DESCRIPTION:   This API call is part of the DX implementation of the 
//                  NV Path Library.
//                  Sets vertex data for a path.
//
//  SUPPORTED OS: Windows XP and higher
//
//	       INPUT:	path - NVPL path handle
//		   INPUT:	vertices - vertex data
//
// RETURN STATUS: a NvAPI status code or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_D3D9_PathVerticesNV(NvU32 path, const void* vertices);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_PathParameterfNV
//
//	 DESCRIPTION:   This API call is part of the DX implementation of the 
//                  NV Path Library.
//                  Sets a path rendering parameter of type float
//
//  SUPPORTED OS: Windows XP and higher
//
//	       INPUT:	path - NVPL path handle
//		   INPUT:	paramType - parameter name
//		   INPUT:	param - parameter value
//
// RETURN STATUS: a NvAPI status code or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_D3D9_PathParameterfNV(NvU32 path, NVPathParamType paramType, float param);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_PathParameteriNV
//
//	 DESCRIPTION:   This API call is part of the DX implementation of the 
//                  NV Path Library.
//                  Sets a path rendering parameter of type int
//
//  SUPPORTED OS: Windows XP and higher
//
//	       INPUT:	path - NVPL path handle
//		   INPUT:	paramType - parameter name
//		   INPUT:	param - parameter value
//
// RETURN STATUS: a NvAPI status code or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_D3D9_PathParameteriNV(NvU32 path, NVPathParamType paramType, int param);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_PathMatrixNV
//
//	 DESCRIPTION:   This API call is part of the DX implementation of the 
//                  NV Path Library.
//                  Sets a transformation matrix
//
//  SUPPORTED OS: Windows XP and higher
//
//	       INPUT:	context - NVPL context handle
//		   INPUT:	target - type of transformation
//		   INPUT:	value - matrix values
//
// RETURN STATUS: a NvAPI status code or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_D3D9_PathMatrixNV(NvU32 context, NVPathTargetType paramType, const float* value);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_PathDepthNV
//
//	 DESCRIPTION:   This API call is part of the DX implementation of the 
//                  NV Path Library.
//                  Sets the current path depth
//
//  SUPPORTED OS: Windows XP and higher
//
//	       INPUT:	context - NVPL context handle
//		   INPUT:	value - depth value
//
// RETURN STATUS: a NvAPI status code or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_D3D9_PathDepthNV(NvU32 context, float value);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_PathClearDepthNV
//
//	 DESCRIPTION:   This API call is part of the DX implementation of the 
//                  NV Path Library.
//                  Clears the depth buffer
//
//  SUPPORTED OS: Windows XP and higher
//
//	       INPUT:	context - NVPL context handle
//		   INPUT:	value - depth value
//
// RETURN STATUS: a NvAPI status code or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_D3D9_PathClearDepthNV(NvU32 context, float value);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_PathEnableDepthTestNV
//
//	 DESCRIPTION:   This API call is part of the DX implementation of the 
//                  NV Path Library.
//                  Enables / Disables depth testing
//
//  SUPPORTED OS: Windows XP and higher
//
//	       INPUT:	context - NVPL context handle
//		   INPUT:	enable - enable depth test if true, else disable
//
// RETURN STATUS: a NvAPI status code or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_D3D9_PathEnableDepthTestNV(NvU32 context, bool enable);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_PathEnableColorWriteNV
//
//	 DESCRIPTION:   This API call is part of the DX implementation of the 
//                  NV Path Library.
//                  Enables / Disables color write
//
//  SUPPORTED OS: Windows XP and higher
//
//	       INPUT:	context - NVPL context handle
//		   INPUT:	enable - enable color write if true, else disable
//
// RETURN STATUS: a NvAPI status code or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_D3D9_PathEnableColorWriteNV(NvU32 context, bool enable);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_DrawPathNV
//
//	 DESCRIPTION:   This API call is part of the DX implementation of the 
//                  NV Path Library.
//                  Draws the path.
//
//  SUPPORTED OS: Windows XP and higher
//
//	       INPUT:	path - NVPL path handle
//		   INPUT:	mode - path rendering mode
//
// RETURN STATUS: a NvAPI status code or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_D3D9_DrawPathNV(NvU32 path, NVPathMode mode);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_GetSurfaceHandle
//
//   DESCRIPTION: Get the handle of a given surface. This handle uniquely
//                identify the surface through all NvAPI entries.
//
//  SUPPORTED OS: Windows XP and higher
//
//         INPUT: pSurface - Surface to be identified
//
//        OUTPUT: pHandle - Will be filled by the return handle
//
//          DEMO: PrimTexture
//
// RETURN STATUS: an int which could be an NvAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_GetSurfaceHandle(IDirect3DSurface9 *pSurface,
                                        NVDX_ObjectHandle *pHandle);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_GetSurfaceHandle
//
//   DESCRIPTION: Get the surface handles for the YUY2 overlay surfaces created.
//
//  SUPPORTED OS: Windows XP and higher
//
//         INPUT: pDev - Device whose YUY2 surface handles need to be retrieved.
//
//        OUTPUT: NVDX_ObjectHandle - Array of surface handles that will be filled by
//                the driver. The array has to initialzed before it is passed on to
//                the funtion. The handles are populated in the order in which the
//                they are created. e.g The handle of first surface created will be
//                store in pHandle[0], second surface will be stored in pHandle[1] and so on.
//
//          DEMO: PrimTexture
//
// RETURN STATUS: an int which could be an NvAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////
#define MAX_OVLY_SURFS     6

typedef struct _NV_OVLY_SURFS_INFO
{
    NVDX_ObjectHandle  handle[MAX_OVLY_SURFS];
    unsigned int       numSurfs;
}NV_OVLY_SURFS_INFO;

NVAPI_INTERFACE NvAPI_D3D9_GetOverlaySurfaceHandles(IDirect3DDevice9 *pDev, NV_OVLY_SURFS_INFO *pInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_GetTextureHandle
//
//   DESCRIPTION: Get the handle of a given DX9 texture.
//
//  SUPPORTED OS: Windows XP and higher
//
//         INPUT: pTexture - Surface to be identified
//
//        OUTPUT: pHandle - Will be filled by the return handle
//
// RETURN STATUS: an int which could be an NvAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_GetTextureHandle(IDirect3DTexture9 *pTexture,
                                        NVDX_ObjectHandle *pHandle);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_GpuSyncGetHandleSize
//
//   DESCRIPTION: returns size of the init and copy sync handles. These handles are
//                then allocated and initialized to zero by the application
//
//  SUPPORTED OS: Windows XP and higher
//
//        OUTPUT: pInitHandleSize - size of GpuSync init handle
//                pMapHandleSize - size of GpuSync copy handle
//
// RETURN STATUS: an int which could be an NvAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_GpuSyncGetHandleSize(IDirect3DDevice9 *pDev,
                                            unsigned int *pInitHandleSize,
                                            unsigned int *pMapHandleSize);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_GpuSyncInit
//
//   DESCRIPTION: setup sync functionality
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: an int which could be an NvAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_GpuSyncInit(IDirect3DDevice9 *pDev,
                                            void * syncInitData);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_GpuSyncEnd
//
//   DESCRIPTION: tear down sync structures
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: an int which could be an NvAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_GpuSyncEnd(IDirect3DDevice9 *pDev,
                                            void * syncData);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_GpuSyncMapTexBuffer
//
//   DESCRIPTION: map a texture to receive ogl data
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: an int which could be an NvAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_GpuSyncMapTexBuffer(IDirect3DDevice9 *pDev,
                                            IDirect3DTexture9 *pTexture,
                                            void * syncData);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_GpuSyncMapSurfaceBuffer
//
//   DESCRIPTION: map a texture to receive ogl data
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: an int which could be an NvAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_GpuSyncMapSurfaceBuffer(IDirect3DDevice9 *pDev,
                                                   IDirect3DSurface9 *pSurface,
                                                   void * syncData);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_GpuSyncMapVertexBuffer
//
//   DESCRIPTION: map a vertex buffer to recieve ogl data
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: an int which could be an NvAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_GpuSyncMapVertexBuffer(IDirect3DDevice9 *pDev,
                                            IDirect3DVertexBuffer9 *pVertexBuffer,
                                            void * syncData);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_GpuSyncMapIndexBuffer
//
//   DESCRIPTION: map a index buffer to recieve ogl data
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: an int which could be an NvAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_GpuSyncMapIndexBuffer(IDirect3DDevice9 *pDev,
                                            IDirect3DIndexBuffer9 *pIndexBuffer,
                                            void * syncData);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_SetPitchLinearSurfaceCreation
//
//   DESCRIPTION: Force the next CreateTexture/CreateRenderTarget call to use pitch surface
//                Applied only once for the next surface. Set Signature==0 to make sure this disabled.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: an int which could be an NvAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_SetPitchSurfaceCreation(IDirect3DDevice9 *pDev,
                                                   NvU32 Signature);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_GpuSyncAcquire
//
//   DESCRIPTION: semaphore acquire for synchronization control of mapped buffer
//
//  SUPPORTED OS: Windows XP and higher
//
//         INPUT: accessMode - acquire mapped buffer read/write access
//
// RETURN STATUS: an int which could be an NvAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_GpuSyncAcquire(IDirect3DDevice9 *pDev,
                                            void * syncData);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_GpuSyncRelease
//
//   DESCRIPTION: semaphore release for synchronization control of mapped buffer
//
//  SUPPORTED OS: Windows XP and higher
//
//         INPUT: accessMode - release mapped buffer read/write access
//
// RETURN STATUS: an int which could be an NvAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_GpuSyncRelease(IDirect3DDevice9 *pDev,
                                            void * syncData);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_GetCurrentRenderTargetHandle
//
//   DESCRIPTION: Get the handle of current RT/ZB.
//
//  SUPPORTED OS: Windows XP and higher
//
//         INPUT: pDev - Device whose current ZB to be identified
//
//        OUTPUT: pHandle - Will be filled by the return handle
//
// RETURN STATUS: an int which could be an NvAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_GetCurrentRenderTargetHandle(IDirect3DDevice9 *pDev,
                                            NVDX_ObjectHandle *pHandle);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_GetCurrentZBufferHandle
//
//   DESCRIPTION:
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: an int which could be an NvAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_GetCurrentZBufferHandle(IDirect3DDevice9 *pDev,
                                               NVDX_ObjectHandle *pHandle);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_GetIndexBufferHandle
//
//   DESCRIPTION: Get the handle of a given DX9 index buffer.
//
//  SUPPORTED OS: Windows XP and higher
//
//         INPUT: pIndexBuffer - Index Buffer to be identified
//
//        OUTPUT: pHandle - Will be filled by the return handle
//
// RETURN STATUS: an int which could be an NvAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_GetIndexBufferHandle(IDirect3DIndexBuffer9 *pIndexBuffer,
                                        NVDX_ObjectHandle *pHandle);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_GetVertexBufferHandle
//
//   DESCRIPTION: Get the handle of a given DX9 vertex buffer.
//
//  SUPPORTED OS: Windows XP and higher
//
//         INPUT: pVertexBuffer - Vertex Buffer to be identified
//
//        OUTPUT: pHandle - Will be filled by the return handle
//
// RETURN STATUS: an int which could be an NvAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_GetVertexBufferHandle(IDirect3DVertexBuffer9 *pVertexBuffer,
                                        NVDX_ObjectHandle *pHandle);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_CreateTexture
//
//   DESCRIPTION: Create a texture with special properties. NOTE: The texture
//                is always created in "POOL_DEFAULT", not managed.
//
//  SUPPORTED OS: Windows XP and higher
//
//         INPUT:  pDev       The device to get primary surface from
//                 Width,Height,Levels,Format
//                            Same as IDirect3D9Device::CreateTexture
//                 Flags      The flags for special texture creation
//
//                 FORCEVIDMEM  This will force the texture into video memory,
//                              if that can not be done, the texture creation will fail.
//                 FORCELINEAR  Ensure the texture is stored in pitched linear layout.
//                 NOTMOVABLE   Indicates the texture should not be moved once allocated.
//                              This is usually used to accomodate 3rd party DMA engine.
//                              NOTE: This is only a hint, OS may still move the texture
//                                    under memory constrained circumstances.
//
//        OUTPUT:  ppTexture  Fill with the texture created
//                 pHandle    If non-NULL, fill with the NVDX handle of the created texture
//
//          DEMO:  TextureLock
//
///////////////////////////////////////////////////////////////////////////////

#define NV_SURFACEFLAG_FORCEVIDMEM      0x00000001
#define NV_SURFACEFLAG_FORCELINEAR      0x00000010
#define NV_SURFACEFLAG_NOTMOVABLE       0x00000100

NVAPI_INTERFACE NvAPI_D3D9_CreateTexture(IDirect3DDevice9 *pDev,
                                         NvU32 Width, NvU32 Height, NvU32 Level,
                                         NvU32 Flags, D3DFORMAT Format,
                                         IDirect3DTexture9 **ppTexture,
                                         NVDX_ObjectHandle *pHandle = 0);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_AliasPrimaryAsTexture
//
//   DESCRIPTION: Create an texture that is an alias of current device's primary surface
//
//  SUPPORTED OS: Windows XP and higher
//
//         INPUT:  pDev       The device to get primary surface from
//                 dwIndex    The index to the primary flipchain of device (usually 0)
//
//        OUTPUT:  ppTexture  Fill with the texture created
//                 pHandle    If non-NULL, fill with the NVDX handle of the created texture
//
//          DEMO:  PrimTexture
//
// RETURN STATUS: an int which could be an NvAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_AliasPrimaryAsTexture(IDirect3DDevice9 *pDev,
                                            NvU32 dwIndex,
                                            IDirect3DTexture9 **ppTexture,
                                            NVDX_ObjectHandle *pHandle = 0);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_PresentSurfaceToDesktop
//
//   DESCRIPTION: Present a given surface to the desktop. This interface can be
//                used to start a fullscreen flipping mode even within windowed D3D app.
//
//  SUPPORTED OS: Windows XP and higher
//
//         INPUT: pDev              The device (display) to present to surfaceHandle   The surface
//                                  handle obtained from NVD3D9_GetSurfaceHandle
//                                  NOTE: NVDX_OBJECT_NONE means restore
//                dwFlipFlags       Flags to indicate SYNC mode (other bits reserved and must be 0)
//                dwExcludeDevices  This is a bitmask (usually 0) to indicate which device
//                                  will be EXCLUDED from this present. This is only
//                                  effective when used in a clone mode configuration where
//                                  the application wants one monitor to show the specially
//                                  rendered screen and the other normal desktop.
//
//          NOTE: It is applications responsibility to determine which devices are
//                available on the current clone config, through nvcpl interfaces.
//
//          DEMO: PrimTexture
//
// RETURN STATUS: an int which could be an NvAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////

// Parameter used for dwFlipFlags (All other bits reserved)
#define NV_FLIPFLAG_VSYNC               0x00000001  // SYNCMODE         (bit 0:1) - 0:NOSYNC, 1:VSYNC, 2:HSYNC
#define NV_FLIPFLAG_HSYNC               0x00000002
#define NV_FLIPFLAG_TRIPLEBUFFERING     0x00000004  // TRIPLEBUFFERING  (bit 2)   - 0: DoubleBuffer, 1:TripleBuffer or more

NVAPI_INTERFACE NvAPI_D3D9_PresentSurfaceToDesktop(IDirect3DDevice9 *pDev,
                                               NVDX_ObjectHandle surfaceHandle,
                                               NvU32 dwFlipFlags,
                                               NvU32 dwExcludeDevices = 0);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION_NAME: NvAPI_D3D9_CreateVideoBegin
//
//   DESCRIPTION: Signals the driver that the application next will create a set of
//                D3DFMT_X8R8G8B8 render targets for overlay use. The call will fail
//                if the driver/hardware doesn't support this mode, in which case the
//                application should fall back to the traditional overlay (with driver
//                internal overlay buffers). If this call returns successfully, then
//                before the driver sees _CreateVideoEnd, all D3DFMT_A8R8G8B8 render
//                targets will be allocated as overlay surfaces.
//                See _CreateVideo, NV_CVFLAG_EXTERNAL_OVERLAY flag for more details.
//                This interface is only available on Windows Vista.
//
//  SUPPORTED OS: Windows Vista and higher
//
//         INPUT: pDev              The device (display) to present to
//
// RETURN STATUS: an int which could be an NvAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_D3D9_CreateVideoBegin(IDirect3DDevice9 *pDev);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION_NAME: NvAPI_D3D9_CreateVideoEnd
//
//   DESCRIPTION: Signals the driver that the application has finished creating
//                D3DFMT_X8R8G8B8 render targets for overlay.
//                See _CreateVideo, NV_CVFLAG_EXTERNAL_OVERLAY flag for more details.
//                This interface is only available on Windows Vista.
//
//  SUPPORTED OS: Windows Vista and higher
//
//         INPUT: pDev              The device (display) to present to
//
// RETURN STATUS: an int which could be an NvAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_D3D9_CreateVideoEnd(IDirect3DDevice9 *pDev);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION_NAME: NvAPI_D3D9_CreateVideo
//
//   DESCRIPTION: Allocates and initializes video resources for playback within a D3D9 context
//
//  SUPPORTED OS: Windows XP and higher
//
//         INPUT: pDev              The device (display) to present to
//                dwVersion         Version of the CreateVideoParams structure
//                dwCVFlags         Initialization flags (see defines for description)
//                dwFlipQueueHint   If overlay is allocated, indication of the desired number of flips
//                                  to be queued (minimum of 1).  A larger number is better for performance,
//                                  but also consumes more frame buffer resources.  This number should be
//                                  set according to the number of fields/frames that can be decoded in
//                                  advance of presentation.  Eg., if the decoder cannot decode ahead and
//                                  must display immediately after decoding a frame, then set this to 1.
//                                  If the decoder is decoding field content one frame at a time, then it
//                                  is decoding one field ahead and should set this to 2.  If the decoder
//                                  can decode n flips ahead, then set this to n+1.  If the GPU has
//                                  constrained frame buffer resources, then set this number lower, and also
//                                  reduce the decode-ahead pipeline resources accordingly.
//                dwMaxSrcWidth     Maximum video source width
//                dwMaxSrcHeight    Maximum video source height
//                dwNumOvlSurfs     (VER2 only) Number of surfaces that the application intends to use for
//                                  overlay (also refer to the NV_CVFLAG_EXTERNAL_OVERLAY flag)
//                hOvlSurfs         (VER2 only) Handles to the surfaces that the application intends to use
//                                  for overlay (also refer to the NV_CVFLAG_EXTERNAL_OVERLAY flag)
//
// RETURN STATUS: an int which could be an NvAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////

#define NV_CVFLAG_OVERLAY                   0x00000001      // Overlay will be used
#define NV_CVFLAG_OVERLAY_REINIT            0x00000002      // Change source size or flip queue hint once overlay
                                                            // resources have already been allocated.  Be wary
                                                            // of upward allocating new resources, if there is
                                                            // a failure, be prepared to deallocate everything
                                                            // and start from scratch.
#define NV_CVFLAG_EXTERNAL_OVERLAY          0x00000004      // Use overlay surfaces allocated by the application. This flag
                                                            // is supported only in NV_DX_CREATE_VIDEO_PARAMS_VER2 and above
                                                            // on Windows Vista.
                                                            //
                                                            // The application sets this flag to indicate that the driver should
                                                            // not allocate any internal overlay buffers, and the first
                                                            // dwNumOvlSurfs surfaces in pCVParams->hOvlSurfs[] will be used for
                                                            // overlay scan-out directly. The driver will validate these surfaces
                                                            // against the following conditions, and fail the call otherwise:
                                                            //
                                                            // 1. No less than NV_CV_MIN_OVERLAY_SURFACE_NUMBER and no more than
                                                            //    NV_CV_MAX_OVERLAY_SURFACE_NUMBER should be passed in
                                                            // 2. Only surface handles of D3DFMT_A8R8G8B8 render targets created
                                                            //    inside a pair of _CreateVideoBegin ()/_CreateVideoEnd() should be
                                                            //    used
                                                            // 3. The size of the surfaces must be identical to the target display
                                                            //
                                                            // If all of the above condictions are met for each of the surfaces,
                                                            // then the driver will not allocate any internal overlay buffers. Upon
                                                            // _PresentVideo(), the source surface will be used for overlay scan-
                                                            // out directly without the driver copying the content to an overlay
                                                            // buffer first.
#define NV_CVFLAG_2ND_FORCE_DISABLE         0x00010000      // Forces full screen video on secondary device to be
                                                            // disabled in multihead modes, regardless of user setting
#define NV_CVFLAG_2ND_FORCE_ENABLE          0x00020000      // Forces full screen video on secondary device to be
                                                            // enabled on the default device in multihead modes,
                                                            // regardless of user setting
#define NV_CVFLAG_2ND_FORCE_ENABLE1         0x00040000      // Forces full screen video on secondary device to be
                                                            // enabled on the primary device in clone mode,
                                                            // regardless of user setting
#define NV_CVFLAG_2ND_COMMANDEER            0x00100000      // If another application owns the secondary full screen
                                                            // device, forcibly take possession of it.
#define NV_CVFLAG_SECONDARY_DISPLAY         0x01000000      // Is the target display secondary display when in Dual-view mode

typedef struct
{
    NvU32 version;
    NvU32 cvFlags;
    NvU32 flipQueueHint;
    NvU32 maxSrcWidth;
    NvU32 maxSrcHeight;
} NV_DX_CREATE_VIDEO_PARAMS1;

#define NV_CV_MIN_OVERLAY_SURFACE_NUMBER    2
#define NV_CV_MAX_OVERLAY_SURFACE_NUMBER    6
typedef struct
{
    NvU32 version;
    NvU32 cvFlags;
    NvU32 flipQueueHint;
    NvU32 maxSrcWidth;
    NvU32 maxSrcHeight;
    NvU32 dwNumOvlSurfs;
    NVDX_ObjectHandle hOvlSurfs[NV_CV_MAX_OVERLAY_SURFACE_NUMBER];
} NV_DX_CREATE_VIDEO_PARAMS2;

typedef NV_DX_CREATE_VIDEO_PARAMS2  NV_DX_CREATE_VIDEO_PARAMS;

#define NV_DX_CREATE_VIDEO_PARAMS_VER1  MAKE_NVAPI_VERSION(NV_DX_CREATE_VIDEO_PARAMS1,1)

#define NV_DX_CREATE_VIDEO_PARAMS_VER2  MAKE_NVAPI_VERSION(NV_DX_CREATE_VIDEO_PARAMS2,2)

#define NV_DX_CREATE_VIDEO_PARAMS_VER   NV_DX_CREATE_VIDEO_PARAMS_VER2

NVAPI_INTERFACE NvAPI_D3D9_CreateVideo(IDirect3DDevice9 *pDev,
                                       NV_DX_CREATE_VIDEO_PARAMS *pCVParams);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION_NAME: NvAPI_D3D9_FreeVideo
//
//   DESCRIPTION: Releases all video resources
//
//  SUPPORTED OS: Windows XP and higher
//
//         INPUT: pDev              The device (display) to present to
//
// RETURN STATUS: an int which could be an NvAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_D3D9_FreeVideo(IDirect3DDevice9 *pDev);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_PresentVideo
//
//   DESCRIPTION: Signals a final and complete frame ready for presentation.
//                Can optionally render to the overlay, but should be called
//                regardless of whether any actual rendering occurs.  If the
//                user has enabled full screen video in a multihead mode,
//                this frame will also be rendered on the secondary device.
//
//  SUPPORTED OS: Windows XP and higher
//
//          NOTE: Use NV_DX_PRESENT_VIDEO_PARAMS_VER in the "version" method for both 32 bit and 64 bit
//                callers.  For older drivers that do not support 64 bit callers, 32 bit callers
//                should use the evaluation of MAKE_NVAPI_VERSION(NV_DX_PRESENT_VIDEO_PARAMS1,1)
//                in that field.
//
//         INPUT: pDev              The device (display) to present to
//                dwVersion         Version of the PresentVideoParams structure
//                surfaceHandle     The surface handle obtained from NvAPI_D3D9_GetSurfaceHandle
//                                  or NvAPI_D3D9_GetCurrentRenderTargetHandle
//                dwPVFlags         Presentation flags (see defines for description)
//                dwColourKey       Colour key to use if NV_PVFLAG_DST_KEY is set
//                qwTimeStamp*      If NV_PVFLAG_USE_STAMP is set, time in ns when the frame is to be presented
//                                  If NV_PVFLAG_SET_STAMP is set, set the current time to this, and present on next vblank
//                dwFlipRate        Set to the current flip rate
//                                  Set to zero if the frame to be presented is a still frame
//                srcUnclipped      Unclipped source rectangle of the entire frame of data
//                srcClipped        Cropped source rectangle.  It is the caller's responsibility to crop
//                                  the source if the desktop crops the destination.
//                dst               Destination rectangle (in desktop coordinates) of the overlay.  It is the
//                                  caller's responsibility to crop the destination against the desktop.
//
// RETURN STATUS: an int which could be an NvAPI status or DX HRESULT code.
//
//                NVAPI_DEVICE_BUSY - This return value indicates the flip request was dropped
//                because the hardware flip queue was too deep, thus no more present requests can be
//                accepted at the moment.
//
//                When external overlay is used (for "external overlay" please refer to NvAPI_D3D9_CreateVideoBegin,
//                NvAPI_D3D9_CreateVideoEnd, and VER2-only descriptions of NvAPI_D3D9_CreateVideo),
//                a failure in _PresentVideo means the current front (on-screen) buffer will remain the
//                unchanged. In this case the application should be careful not to render to the current
//                front buffer, as it will cause video tearing. The application could re-try presenting
//                the same frame during the next vsync, or continue with rendering the next frame to a
//                back buffer.
//
///////////////////////////////////////////////////////////////////////////////

// PresentVideo flags
#define NV_PVFLAG_ODD           0x00000001      // Field is odd
#define NV_PVFLAG_EVEN          0x00000002      // Field is even
#define NV_PVFLAG_PROTECTED     0x00000004      // Indicates that this frame is protected and guarantees full
                                                // screen video will not display this frame on any secondary device.
                                                // Conversely, not setting this indicates an unprotected frame
#define NV_PVFLAG_PROGRESSIVE   0x00000008      // Indicates progressive frame.  If the odd or even flags are set
                                                // in conjunction with this, it indicates the original field that
                                                // generated this deinterlaced frame, and attempts to synchronize
                                                // this presentation to the corresponding display field of an
                                                // interlaced display
#define NV_PVFLAG_SHOW          0x00000010      // Show the overlay
                                                // If the app is minimized or obscured, continue to call NvAPI_D3D9_PresentVideo
                                                // for every complete frame without this flag set.
                                                // If enabled, unprotected video will continue to play full screen
                                                // on the secondary device, using the pixel aspect cached from
                                                // the last time a frame was shown.  To change the pixel aspect while hidden,
                                                // the caller must "show" a frame at least once with a new clipped source and
                                                // destination rectangle.  This shown frame can be rendered invisible with
                                                // appropriate selection of colour key.
#define NV_PVFLAG_FAST_MOVE     0x00000020      // Move overlay position without waiting for vblank.
                                                // The only parameters used are dwDstX, dwDstY, and NV_PVFLAG_SHOW.
#define NV_PVFLAG_WAIT          0x00000040      // If set, blocking flip, wait until flip queue can accept another flip.
                                                // A non-blocking flip will return an error if flip cannot be queued yet.
#define NV_PVFLAG_REPEAT        0x00000080      // Video data is completely unchanged from the previous flip (used for telecine)
#define NV_PVFLAG_DST_KEY       0x00000100      // Use destination colour key.
#define NV_PVFLAG_FULLSCREEN    0x00000200      // Indicates that the overlay is playing fullscreen on the desktop.
                                                // This bit is used to automatically overscan the image on TV's.
#define NV_PVFLAG_SET_STAMP     0x00001000      // Set the current time.
#define NV_PVFLAG_USE_STAMP     0x00002000      // If set, use timestamps.
                                                // If not set, flip on the next vblank.

typedef struct
{
    NvU32 version;
    NVDX_ObjectHandle surfaceHandle;
    NvU32 pvFlags;
    NvU32 colourKey;
    NvU32 timeStampLow;
    NvU32 timeStampHigh;
    NvU32 flipRate;
    NvSBox srcUnclipped;
    NvSBox srcClipped;
    NvSBox dst;
} NV_DX_PRESENT_VIDEO_PARAMS1;

typedef NV_DX_PRESENT_VIDEO_PARAMS1 NV_DX_PRESENT_VIDEO_PARAMS;

#ifdef _WIN32
#define NV_DX_PRESENT_VIDEO_PARAMS_VER1  MAKE_NVAPI_VERSION(NV_DX_PRESENT_VIDEO_PARAMS1,1)
#endif //_WIN32

#define NV_DX_PRESENT_VIDEO_PARAMS_VER  MAKE_NVAPI_VERSION(NV_DX_PRESENT_VIDEO_PARAMS1,2)

NVAPI_INTERFACE NvAPI_D3D9_PresentVideo(IDirect3DDevice9 *pDev,
                                        NV_DX_PRESENT_VIDEO_PARAMS *pPVParams);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_D3D9_SetGamutData
//
// DESCRIPTION:     This API sets the Gamut Boundary Description (GBD) data.
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:      pDev(IN)       - The device (display) to present to.
//                  outputId(IN)   - The display output id, which can be found using NvAPI_GetAssociatedDisplayOutputId() 
//                                   for an intended display.
//                  format(IN)     - The format of GBD data structure.
//                  pGamutData(IN) - The GBD data.
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT: Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////

typedef enum _NV_GAMUT_FORMAT
{
    NV_GAMUT_FORMAT_VERTICES   = 0,
    NV_GAMUT_FORMAT_RANGE,
} NV_GAMUT_FORMAT;

typedef struct _NV_GAMUT_METADATA_RANGE
{
    // Header
    NvU32    GBD_Color_Space:3;
    NvU32    GBD_Color_Precision:2;
    NvU32    Rsvd:2;                    // Must be set to 0
    NvU32    Format_Flag:1;             // Must be set to 1

    // Packaged data
    NvU32    Min_Red_Data:12;
    NvU32    Max_Red_Data:12;
    NvU32    Min_Green_Data:12;
    NvU32    Max_Green_Data:12;
    NvU32    Min_Blue_Data:12;
    NvU32    Max_Blue_Data:12;
} NV_GAMUT_METADATA_RANGE;

typedef struct _NV_GAMUT_METADATA_VERTICES
{
    // Header
    NvU32    GBD_Color_Space:3;
    NvU32    GBD_Color_Precision:2;
    NvU32    Rsvd:1;
    NvU32    Facet_Mode:1;              // Must be set to 0
    NvU32    Format_Flag:1;             // Must be set to 0
    NvU32    Number_Vertices_H:8;       // Must be set to 0
    NvU32    Number_Vertices_L:8;       // Must be set to 4

    // Packaged data
    NvU32    Black_Y_R:12;
    NvU32    Black_Cb_G:12;
    NvU32    Black_Cr_B:12;
    NvU32    Red_Y_R:12;
    NvU32    Red_Cb_G:12;
    NvU32    Red_Cr_B:12;
    NvU32    Green_Y_R:12;
    NvU32    Green_Cb_G:12;
    NvU32    Green_Cr_B:12;
    NvU32    Blue_Y_R:12;
    NvU32    Blue_Cb_G:12;
    NvU32    Blue_Cr_B:12;
} NV_GAMUT_METADATA_VERTICES;

typedef struct _NV_GAMUT_METADATA
{
   union
   {
        NV_GAMUT_METADATA_RANGE     rangeData;
        NV_GAMUT_METADATA_VERTICES  verticesData;
   }data;
}NV_GAMUT_METADATA;

NVAPI_INTERFACE NvAPI_D3D9_SetGamutData(IDirect3DDevice9 *pDev, NvU32 outputId, NV_GAMUT_FORMAT format, NV_GAMUT_METADATA *pGamutData);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_SetSurfaceCreationLayout
//
//   DESCRIPTION: This call will be used primarily for testing VIC for MCP89.
//                This will set up the layout of surfaces that are created through CreateSurface calls
//
//  SUPPORTED OS: Windows Vista and higher
//
//         INPUT: pDev                          The device (display) to present to
//                pSurfaceLayout                The pointer to the surface layout
//                Surface layouts supported right now include Block-Linear (BL), 
//                Pitch-Linear (PL) and Tiled (16x16)
// RETURN STATUS: an int which could be an NvAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////
typedef enum _NVAPI_SURFACE_LAYOUT
{
    NVAPI_SURFACE_LAYOUT_BL    = 0,
    NVAPI_SURFACE_LAYOUT_PL    = 1,
    NVAPI_SURFACE_LAYOUT_TILED = 2,
} NVAPI_SURFACE_LAYOUT;

typedef struct _NVAPI_SURFACE_LAYOUT_STRUCT
{
    BOOL                 bEnableLayoutOverride;
    NVAPI_SURFACE_LAYOUT slLayout;
    DWORD                reserved[4];
    
} NVAPI_SURFACE_LAYOUT_STRUCT;


NVAPI_INTERFACE NvAPI_D3D9_SetSurfaceCreationLayout(IDirect3DDevice9            *pDev,
                                                    NVAPI_SURFACE_LAYOUT_STRUCT *pSurfaceLayout);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_Video_GetVideoCapabilities
//
//   DESCRIPTION: Get the GPU's video processing capabilities. The caller is responsible for furnishing
//                the inputs within the NVAPI_VIDEO_CAPS_PACKET. This packet shall contain the output
//                consisting of the supported video features for the current configuration. The number of
//                NVAPI_VIDEO_CAPS will match the number of input video streams for which the capabilites
//                have been requested. Multiple supported video profiles may be returned that would include
//                a combination of various video features.
//
//  SUPPORTED OS: Windows XP and higher
//
//         INPUT: pDev                          The device (display) to present to
//                version                       version of the NV_DX_VIDEO_CAPS structure
//                videoCapsPacket               NVAPI_VIDEO_CAPS_PACKET containing both the
//                                              input Video Source information for which the capabilities
//                                              are requested, as well as the output available
//                                              supported video features for the current configuration.
//
// RETURN STATUS: an int which could be an NvAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////

typedef enum _NV_CODEC
{
    NV_CODEC_TYPE_NONE,
    NV_CODEC_TYPE_MPEG2,
    NV_CODEC_TYPE_H264,
    NV_CODEC_TYPE_VC1,
} NV_CODEC;

// current video surface to be played back
typedef struct _NVAPI_VIDEO_SRC_INFO
{
    NvU32       srcWidth;   // Input video width
    NvU32       srcHeight;  // Input video height
    NV_CODEC    codecType;  // One of the available NV_CODEC's
    NvU32       avgBitrate; // Average bit rate for each stream in Kbps
    NvU64       reserved1;  // reserved for future expansion
    NvU64       reserved2;
} NVAPI_VIDEO_SRC_INFO;

// current desktop resolution
typedef struct _NVAPI_DESKTOP_RES
{
    NvU32 width;            // current resolution width
    NvU32 height;           // current resolution height
    NvU32 bitsPerPixel;     // current resolution depth
    NvU32 refreshRate;      // current display refresh rate
    NvU64 reserved1;        // reserved for future expansion
    NvU64 reserved2;
} NVAPI_DESKTOP_RES;

#define NV_DEINTERLACE_PIXADAPTIVE_BIT      0   // HW Pixel adaptive deinterlacing available
#define NV_VID_ENHANCE_EDGE_ENHANCE_BIT     0   // Edge enhancement present
#define NV_VID_ENHANCE_NOISE_REDUCTION_BIT  1   // Noise reduction present
#define NV_COLOR_CTRL_PROCAMP_BIT           0   // ProCamp is supported
#define NV_COLOR_CTRL_COLOR_TEMP_BIT        1   // Color temp control supported
#define NV_GAMMA_Y_BIT                      0   // Y-Gamma controls present
#define NV_GAMMA_RGB_BIT                    1   // RGB-Gamma controls present
#define NV_MISC_CAPS_INV_TELECINE_BIT       0   // Inverse telecine is available

// available video post-process features
typedef struct _NVAPI_VIDEO_PROCESSING_CAPS
{
    NvU64               deinterlaceMode;    // Possible deinterlace modes supported, "check NV_DEINTERLACE_xxx bits"
    NvU64               videoEnhance;       // Possible HW postproc enhancements e.g. NR, EE, "check NV_VID_ENHANCE_xxx bits"
    NvU64               colorControl;       // Color control is supported, "check NV_COLOR_xxx bits"
    NvU64               gamma;              // Available gamma conversions, "check NV_GAMMA_xxx bits"
    NvU64               miscCaps;           // Miscellaneous post processing caps supported, "check NV_MISC_CAPS_xxx bits"
    NvU64               reserved1;          // reserved for future use
    NvU64               reserved2;
    NvU64               reserved3;
} NVAPI_VIDEO_PROCESSING_CAPS;

#define NV_VID_FEATURE_NO_SYNC_FLIPS_BIT            0   // when this bit is set, APP needs to Lock the RGB render target
                                                        // before calling RGB overlay to present video.
                                                        // In general this bit is set for G7x, and not set for G8x and later chips
#define NV_VID_FEATURE_HALF_RES_ON_INTERLACED_BIT   1   // When this bit is set, it means that GPU can only show half resolution
                                                        // video on interlaced display, which is true for G7x. Needs special
                                                        // workaround by app to show full-resolution video.
#define NV_VID_FEATURE_DX_PROTECTION_VERSION_2      2   // when this bit it set, it means the driver supports version 2 of
                                                        // DX video protection.
#define NV_PERF_LEVEL_RED_BIT                       0   // when this bit is set, it means the GPU can NOT support HD/BD playback
#define NV_PERF_LEVEL_YELLOW_BIT                    1   // when this bit is set, it means the GPU meets the minimum requirement for HD/BD playback
#define NV_PERF_LEVEL_GREEN_BIT                     2   // when this bit is set, it means the GPU can support HD/BD playback without problem
#define NV_PERF_LEVEL_AERO_BIT                      3   // when this bit is set, it means the GPU can support HD/BD playback with Aero enabled
#define NV_PERF_LEVEL_FRUC_BIT                      4   // when this bit is set, it means the GPU can support FRUC

// available video decode and post-process features
typedef struct _NVAPI_VIDEO_CAPS
{
    NvU32                       maxFlipRate;    // Maximum flipping rate supported
    NV_CODEC                    hwDecode;       // Supported codec for HW decoding
    NvU64                       vidFeature;     // Indicates presence of special video processing features
    NvU32                       perfLevel;      // GPU dependent level; can be red, yellow, or green
    NvU32                       numVidProfiles; // Number of returned video profiles
    NvU32                       maxResPixels;   // Number of pixels in the max screen resolution supported at maxFlipRate for the input codecType
                                                // (refer to codecType field of the NVAPI_VIDEO_SRC_INFO structure)
    NvU32                       reserved1;
    NVAPI_VIDEO_PROCESSING_CAPS vidProcCaps[NV_MAX_VID_PROFILES];
} NVAPI_VIDEO_CAPS;

#define NVAPI_VIDEO_CAPS_PACKET_VER 1
#define RENDER_MODE_DWM_BIT         0
#define RENDER_MODE_OVERLAY_BIT     1

typedef struct _NVAPI_VIDEO_CAPS_PACKET
{
    NvU32                   packetVer;                      // (IN) Packet version that needs to match NVAPI_VIDEO_CAPS_PACKET_VER
    NvU32                   numVidStreams;                  // (IN) Number of streams for which the video caps are requested
    NVAPI_VIDEO_SRC_INFO    vidSrcInfo[NV_MAX_VID_STREAMS]; // (IN) Video source info
    NVAPI_DESKTOP_RES       res[NV_MAX_HEADS];              // (IN) Current desktop resolution(s)
    NvU64                   renderMode;                     // (IN) Requested rendering mode for the video source
    NvU64                   totalFB;                        // (OUT) total FB supported
    NvU16                   NumExtOvlBufNeeded;             // (OUT) recommanded number of external overlay buffers
    NvU16                   reserved1;                      // (IN/OUT) reserved for future expansion
    NvU32                   reserved2;                      // (IN/OUT)

    NVAPI_VIDEO_CAPS        videoCaps[NV_MAX_VID_STREAMS];  // (OUT) Available video features for requested video streams
} NVAPI_VIDEO_CAPS_PACKET;

typedef struct _NV_DX_VIDEO_CAPS
{
    NvU32                   version;                        // (IN) NVAPI version that matched NV_DX_VIDEO_CAPS_VER
    NVAPI_VIDEO_CAPS_PACKET videoCapsPacket;                // (IN/OUT)
} NV_DX_VIDEO_CAPS;

#define NV_DX_VIDEO_CAPS_VER  MAKE_NVAPI_VERSION(NV_DX_VIDEO_CAPS,1)

NVAPI_INTERFACE NvAPI_D3D9_GetVideoCapabilities(IDirect3DDevice9 *pDev,
                                                NV_DX_VIDEO_CAPS *pVideoCaps);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_RestoreDesktop
//
//   DESCRIPTION:
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
// NOTE: This is not an interface, this is just a short-hand helper
//
///////////////////////////////////////////////////////////////////////////////
inline int NvAPI_D3D9_RestoreDesktop(IDirect3DDevice9 *pDev)
{
    return NvAPI_D3D9_PresentSurfaceToDesktop(pDev,NVDX_OBJECT_NONE,0);
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_AliasPrimaryFromDevice
//
//   DESCRIPTION: Create an alias surface from the given pDevFrom's primary swap chain.
//
//  SUPPORTED OS: Windows XP and higher
//
// INPUT:   pDevTo      Where new surfaces created in
//          pDevFrom    Where the surfaces aliased from
//          dwIndex     Index to the primary flipchain of pDevFrom
//
// OUTPUT:  ppSurf      Filled with new surface pointer (to be released by caller)
//          pHandle     (optional) If non-NULL, filled with SurfaceHandle of the surface
//                      Same can be achieved by calling NVD3D9_GetSurfaceHandle afterwards
//
// DEMO:    Multihead
//
// RETURN STATUS: an int which could be an NvAPI status or DX HRESULT code
//
NVAPI_INTERFACE NvAPI_D3D9_AliasPrimaryFromDevice(IDirect3DDevice9 *pDevTo,
                                              IDirect3DDevice9 *pDevFrom,
                                              NvU32 dwIndex,
                                              IDirect3DSurface9 **ppSurf,
                                              NVDX_ObjectHandle *pHandle = 0);
 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_SetResourceHint
//
//   DESCRIPTION: Deprecated
//
//  SUPPORTED OS: Windows XP and higher
//
//  INPUT: pDev - valid device context
//         obj  - previously obtained HV resource handle
//         dwHintCategory - category of the hints
//         dwHintType     - a hint within this category
//         *pdwHintValue  - pointer to location containing hint value
//
//  OUTPUT:
//         *dwHintValue   - receives previous value of this hint.
//
//
// Avaliable hint categories / hint names:
//     Sli:
typedef enum _NVAPI_SETRESOURCEHINT_CATEGORY
{
    NvApiHints_Sli = 1,

}  NVAPI_SETRESOURCEHINT_CATEGORY;
//
//
// types of Sli hints
  // NvApiHints_Sli_InterframeAwareForTexturing - deprecated
  // default value: zero
//
typedef enum _NVAPI_SETRESOURCEHINT_SLI_HINTS
{
    NvApiHints_Sli_InterframeAwareForTexturing = 1,
}  NVAPI_SETRESOURCEHINT_SLI_HINTS;
//
// end of hint categories
//
// RETURN STATUS: an int which could be an NvAPI status or DX HRESULT code
NVAPI_INTERFACE NvAPI_D3D9_SetResourceHint(IDirect3DDevice9 *pDev, NVDX_ObjectHandle obj,
                            NVAPI_SETRESOURCEHINT_CATEGORY dwHintCategory, NvU32 dwHintName, NvU32 *pdwHintValue);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_Lock
//
//   DESCRIPTION: Lock and Unlock a given surface identified by handle. This
//                function can provide CPU access to all object including
//                RTs, ZBs, textures, VBs and IBs.
//
//  SUPPORTED OS: Windows XP and higher
//
// NOTE:
// (a) If an object can be accessed with normal DX9 means, please do not use this
// (b) Lock should be called right before CPU access, and Unlock called right after
//     the access is done. Any 3D rendering or state change may cause the locked
//     surface to be lost. When that happens, trying to access the cached CPU
//     address may causing app to crash.
//
// RETURN STATUS: an int which could be an NvAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
#define NV_ACCESSFLAG_READONLY  0x00000001 // TBD: do these go with dwLockFlags?
#define NV_ACCESSFLAG_DISCARD   0x00000002
NVAPI_INTERFACE NvAPI_D3D9_Lock(IDirect3DDevice9 *pDev, NVDX_ObjectHandle obj, NvU32 dwLockFlags,
                            void **ppAddress, NvU32 *pPitch);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_Unlock
//
//   DESCRIPTION:
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: an int which could be an NvAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_Unlock(IDirect3DDevice9 *pDev, NVDX_ObjectHandle obj);

#ifndef NV_VIDEO_COMPONENTS_DEFINE
#define NV_VIDEO_COMPONENTS_DEFINE

///////////////////////////////////////////////////////////////////////////////
// Structs and enums related to Video state
///////////////////////////////////////////////////////////////////////////////

// Components related to video state
typedef enum _NVAPI_VIDEO_STATE_COMPONENT_ID
{
    NVAPI_VIDEO_STATE_COMPONENT_ID_NONE     = -1,   // Placeholder for invalid component ID
    NVAPI_VIDEO_STATE_COMPONENT_BRIGHTNESS      ,   // Permits control of video's brightness value
    NVAPI_VIDEO_STATE_COMPONENT_CONTRAST        ,   // Allows control of video's contrast value
    NVAPI_VIDEO_STATE_COMPONENT_HUE             ,   // To control the hue value
    NVAPI_VIDEO_STATE_COMPONENT_SATURATION      ,   // Allows control of video's saturation value
    NVAPI_VIDEO_STATE_COMPONENT_COLORTEMP       ,   // Allows control of the color temperature value
    NVAPI_VIDEO_STATE_COMPONENT_Y_GAMMA         ,   // To set the Y-gamma values
    NVAPI_VIDEO_STATE_COMPONENT_RGB_GAMMA_R     ,   // To set the R value of RGB gamma
    NVAPI_VIDEO_STATE_COMPONENT_RGB_GAMMA_G     ,   // To set the G value of RGB gamma
    NVAPI_VIDEO_STATE_COMPONENT_RGB_GAMMA_B     ,   // To set the B value of RGB gamma
    NVAPI_VIDEO_STATE_COMPONENT_COLOR_SPACE     ,   // Permits choice of various color spaces using VIDEO_COMP_ALGO_COLOR_SPACE_xxx
    NVAPI_VIDEO_STATE_COMPONENT_COLOR_RANGE     ,   // Allows setting between a limited/full color range using VIDEO_COMP_ALGO_COLOR_RANGE_xxx
    NVAPI_VIDEO_STATE_COMPONENT_PLAYBACK_PROFILE,   // Permits using special postprocessing for Adobe Flash 9 Content
    NVAPI_VIDEO_STATE_COMPONENT_DEINTERLACE     ,   // To set various types of deinterlacing algorithms
    NVAPI_VIDEO_STATE_COMPONENT_SCALING         ,   // Allows setting video scaling algorithms
    NVAPI_VIDEO_STATE_COMPONENT_CADENCE         ,   // Allows control of the cadence algorithms
    NVAPI_VIDEO_STATE_COMPONENT_NOISE_REDUCE    ,   // Allows setting post-processing noise reduction values
    NVAPI_VIDEO_STATE_COMPONENT_EDGE_ENHANCE    ,   // Permits post-processing edge enhancement value adjustment
    NVAPI_VIDEO_STATE_COMPONENT_OVERDRIVE       ,   // To control the overdrive feature
    NVAPI_VIDEO_STATE_COMPONENT_SPLITSCREEN     ,   // To permit setting a splitscreen using one of VIDEO_COMP_ALGO_SPLITSCREEN_xxx
    NVAPI_VIDEO_STATE_COMPONENT_DEBLOCKING      ,   // Allows out-of-loop deblocking
    NVAPI_VIDEO_STATE_COMPONENT_DYNAMIC_CONTRAST,  // Permits control of video's dynamic contrast value
    NVAPI_VIDEO_STATE_COMPONENT_GREEN_STRETCH   ,   // Permits control of green stretch
    NVAPI_VIDEO_STATE_COMPONENT_BLUE_STRETCH    ,   // Allows control of blue enhancement
    NVAPI_VIDEO_STATE_COMPONENT_SKIN_TONE_CORRECTION, // Allows skin-tone correction for video
    NVAPI_VIDEO_STATE_COMPONENT_GAMUT_REMAPPING ,   // Applies gamut remapping on video
    NVAPI_VIDEO_STATE_COMPONENT_ID_LAST         ,   // All valid components defined before this one
} NVAPI_VIDEO_STATE_COMPONENT_ID;

#define NVAPI_VIDEO_STATE_COMPONENT_DYNAMIC_CONSTRAST  NVAPI_VIDEO_STATE_COMPONENT_DYNAMIC_CONTRAST  // dynamic contrast value. Kept this for backward compatibility

// Algorithms controlling various video components

#define VIDEO_COMP_ALGO_CUSTOM_BASE 64

typedef enum _NVAPI_VIDEO_COMPONENT_ALGORITHM
{
    VIDEO_COMP_ALGO_COLOR_SPACE_601                  = 0,  // Use the ITU-R BT.601 standard in color-space conversion for xxx_COLOR_SPACE component
    VIDEO_COMP_ALGO_COLOR_SPACE_709                  = 1,  // Use the ITU-R BT.709 standard in color-space conversion for xxx_COLOR_SPACE component
    VIDEO_COMP_ALGO_COLOR_RANGE_STD                  = 0,  // Full range of (0-255) for xxx_COLOR_RANGE component, equivalent to Microsoft's DXVADDI_NOMINALRANGE::DXVADDI_NominalRange_0_255
    VIDEO_COMP_ALGO_COLOR_RANGE_EXT                  = 1,  // Limited range of (16-235) for xxx_COLOR_RANGE component, equivalent to Microsoft's DXVADDI_NOMINALRANGE::DXVADDI_NominalRange_16_235
    VIDEO_COMP_ALGO_PLAYBACK_PROFILE_NONE            = 0,  // Use no playback profile
    VIDEO_COMP_ALGO_PLAYBACK_PROFILE_ADOBE_FLASH_9   = 1,  // Use the internet video enhancement postprocessing for Adobe Flash 9 
    VIDEO_COMP_ALGO_DEINTERLACE_NONE                 = 0,  // No deinterlacing is done
    VIDEO_COMP_ALGO_DEINTERLACE_BOB                  = 1,  // Perform Bob deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_WEAVE                = 2,  // Use weave deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_SIMPLE_ADAPTIVE      = 3,  // Perform a simple motion adaptive deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_GRADIENT_SIMPLE      = 4,  // Use a simple gradient deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_GRADIENT_FULL        = 5,  // Use advanced gradient deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_ADAPTIVE_FOUR_FIELD  = 6,  // Perform four field motion adaptive deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_DIR_SPATIAL          = 7,  // User directional spatial deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_ADVANCED             = 8,  // Perform proprietary advanced deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_GPU_CAPABLE          = 9,  // Best available but GPU dependent. (video driver decides dynamically)
    VIDEO_COMP_ALGO_DEINTERLACE_MEDIAN               = 10,  // Best available but GPU dependent. (video driver decides dynamically)
    VIDEO_COMP_ALGO_DEINTERLACE_DIR_SPATIAL_LIGHT    = 11,  // Best available but GPU dependent. (video driver decides dynamically)
    VIDEO_COMP_ALGO_DEINTERLACE_DIR_SPATIAL_SD       = 12,  // Best available but GPU dependent. (video driver decides dynamically)
    VIDEO_COMP_ALGO_DEINTERLACE_DIR_SPATIAL_HD       = 13,  // Best available but GPU dependent. (video driver decides dynamically)
    VIDEO_COMP_ALGO_DEINTERLACE_ONE_PASS             = 14,  // Best available but GPU dependent. (video driver decides dynamically)
    VIDEO_COMP_ALGO_DEINTERLACE_COMPUTE              = 15,  // Best available but GPU dependent. (video driver decides dynamically)
    VIDEO_COMP_ALGO_DEINTERLACE_CUSTOM_00            = VIDEO_COMP_ALGO_CUSTOM_BASE+0,    // Use custom Deinterlacing algorithm
    VIDEO_COMP_ALGO_DEINTERLACE_CUSTOM_01            = VIDEO_COMP_ALGO_CUSTOM_BASE+1,    // Use custom Deinterlacing algorithm
    VIDEO_COMP_ALGO_SCALING_ALG_SIMPLE               = 0,  // Do scaling using a simple algorithm
    VIDEO_COMP_ALGO_SCALING_ALG_4x4FILTER            = 1,  // Perform scaling using a 4x4 filter
    VIDEO_COMP_ALGO_SCALING_ALG_8x8FILTER            = 2,  // Perform scaling using a 8x8 filter
    VIDEO_COMP_ALGO_SCALING_ALG_CUSTOM_00            = VIDEO_COMP_ALGO_CUSTOM_BASE+0,    // Use custom scaling component
    VIDEO_COMP_ALGO_SCALING_ALG_CUSTOM_01            = VIDEO_COMP_ALGO_CUSTOM_BASE+1,    // Use custom scaling component
    VIDEO_COMP_ALGO_CADENCE_NONE                     = 0,  // Turn cadence OFF
    VIDEO_COMP_ALGO_CADENCE_SIMPLE                   = 1,  // Use simple cadence detection
    VIDEO_COMP_ALGO_CADENCE_VOF                      = 2,  // Use video on film cadence detection
    VIDEO_COMP_ALGO_CADENCE_COMPUTE                  = 3,  // Use compute cadence detection
    VIDEO_COMP_ALGO_CADENCE_GPU_CAPABLE              = 4,  // Best available but GPU dependent. (video driver decides dynamically)
    VIDEO_COMP_ALGO_NOISE_REDUCE_PUREVIDEO           = 0,  // Use PureVideo noise reduction
    VIDEO_COMP_ALGO_NOISE_REDUCE_CUSTOM_00           = VIDEO_COMP_ALGO_CUSTOM_BASE+0,  // Use custom noise reduction
    VIDEO_COMP_ALGO_NOISE_REDUCE_CUSTOM_01           = VIDEO_COMP_ALGO_CUSTOM_BASE+1,  // Use custom noise reduction
    VIDEO_COMP_ALGO_EDGE_ENHANCE_PUREVIDEO           = 0,  // Use PureVideo Sharpening Filter
    VIDEO_COMP_ALGO_EDGE_ENHANCE_CUSTOM_00           = VIDEO_COMP_ALGO_CUSTOM_BASE+0,  // Use custom Sharpening Filter
    VIDEO_COMP_ALGO_EDGE_ENHANCE_CUSTOM_01           = VIDEO_COMP_ALGO_CUSTOM_BASE+1,  // Use custom Sharpening Filter
    VIDEO_COMP_ALGO_OVERDRIVE_SIMPLE                 = 0,  // Use simple overdrive algorithm
    VIDEO_COMP_ALGO_SPLITSCREEN_TYPE_NORMAL          = 0,  // Set the splitscreen in normal mode
    VIDEO_COMP_ALGO_SPLITSCREEN_TYPE_REPEATED        = 1,  // Set the splitscreen to be repeated
    VIDEO_COMP_ALGO_SPLITSCREEN_TYPE_ON_MIRROR       = 2,  // Set the splitscreen as a mirror
    VIDEO_COMP_ALGO_DYNAMIC_CONTRAST_PRESET_NONE     = 0,  // Use the value setting for dynamic contrast instead of a preset
    VIDEO_COMP_ALGO_DYNAMIC_CONTRAST_PRESET_LOW      = 1,  // Turn the dynamic contrast to a low setting
    VIDEO_COMP_ALGO_DYNAMIC_CONTRAST_PRESET_MEDIUM   = 2,  // Turn the dynamic contrast to a medium setting
    VIDEO_COMP_ALGO_DYNAMIC_CONTRAST_PRESET_HIGH     = 3,  // Turn the dynamic contrast to a high setting
    VIDEO_COMP_ALGO_GREEN_STRETCH_PRESET_NONE        = 0,  // Use the value setting for green stretch instead of a preset
    VIDEO_COMP_ALGO_GREEN_STRETCH_PRESET_LOW         = 1,  // Set the green strech to a low setting
    VIDEO_COMP_ALGO_GREEN_STRETCH_PRESET_MEDIUM      = 2,  // Set the green strech to a medium setting
    VIDEO_COMP_ALGO_GREEN_STRETCH_PRESET_HIGH        = 3,  // Set the green strech to a high setting
    VIDEO_COMP_ALGO_BLUE_STRETCH_PRESET_NONE         = 0,  // Use the value setting for blue stretch instead of a preset
    VIDEO_COMP_ALGO_BLUE_STRETCH_PRESET_LOW          = 1,  // Set the blue strech to a low setting
    VIDEO_COMP_ALGO_BLUE_STRETCH_PRESET_MEDIUM       = 2,  // Set the blue strech to a medium setting
    VIDEO_COMP_ALGO_BLUE_STRETCH_PRESET_HIGH         = 3,  // Set the blue strech to a high setting
    VIDEO_COMP_ALGO_SKIN_TONE_CORRECTION_PRESET_NONE = 0,  // Use the value setting for skin tone correction instead of a preset
    VIDEO_COMP_ALGO_SKIN_TONE_CORRECTION_PRESET_SQUEEZE = 1,  // Turn the skin tone correction to a low setting
    VIDEO_COMP_ALGO_SKIN_TONE_CORRECTION_PRESET_RED     = 2,  // Turn the skin tone correction to a medium setting
    VIDEO_COMP_ALGO_SKIN_TONE_CORRECTION_PRESET_YELLOW  = 3,  // Turn the skin tone correction to a high setting
    VIDEO_COMP_ALGO_GAMUT_REMAPPING_CUSTOM_00        = VIDEO_COMP_ALGO_CUSTOM_BASE+0, // Use custom 3x3 gamut remapping matrix
    VIDEO_COMP_ALGO_GAMUT_REMAPPING_CUSTOM_01        = VIDEO_COMP_ALGO_CUSTOM_BASE+1, // Use custom 3x3 gamut remapping matrix
} NVAPI_VIDEO_COMPONENT_ALGORITHM;

// bitmasks for video components' enable at various resolutions
typedef enum _NVAPI_VIDEO_COMPONENT_ENABLE
{
    VIDEO_COMP_ENA_480i     = 0x00000001, // component is enabled at 480i video resolution
    VIDEO_COMP_ENA_480p     = 0x00000002, // component is enabled at 480p video resolution
    VIDEO_COMP_ENA_576i     = 0x00000004, // component is enabled at 576i video resolution
    VIDEO_COMP_ENA_576p     = 0x00000008, // component is enabled at 576p video resolution
    VIDEO_COMP_ENA_720p     = 0x00000010, // component is enabled at 720p video resolution
    VIDEO_COMP_ENA_1080i    = 0x00000020, // component is enabled at 1080i video resolution
    VIDEO_COMP_ENA_1080p    = 0x00000040, // component is enabled at 1080p video resolution
} NVAPI_VIDEO_COMPONENT_ENABLE;

// Packet that facilitates retrieving information about a video component
typedef struct _NVAPI_GET_VIDEO_STATE_COMPONENT
{
    NvU32   version;                    // (IN)  NVAPI version that matches NVAPI_GET_VIDEO_STATE_COMPONENT_VER
    NvU32   componentID;                // (IN)  identify the individual component, one of NVAPI_VIDEO_STATE_COMPONENT_xxx enums
    NvU32   bIsSupported        : 1;    // (OUT) set if this component feature is supported
    NvU32   bIsOverridenByUser  : 1;    // (OUT) set if component is overriden by user's choice
    NvU32   reserved1           : 30;   // (OUT) reserved for future expansion
    NvU32   isEnabled;                  // (OUT) set if component is enabled, one or more of NVAPI_VIDEO_COMPONENT_ENABLE bitmasks
    NvU32   minValue;                   // (OUT) min valid value
    NvU32   maxValue;                   // (OUT) max valid value
    NvU32   totalSteps;                 // (OUT) number of steps between min and max
    NvU32   defaultValue;               // (OUT) pre-defined NVIDIA default
    NvU32   unityValue;                 // (OUT) unity is the disable value for a component
    NvU32   currentValueActive;         // (OUT) value in use
    NvU64   defaultAlgo;                // (OUT) default algo, one or more of NVAPI_VIDEO_COMPONENT_ALGORITHM enums
    NvU64   currentAlgoActive;          // (OUT) algo in use, one or more of NVAPI_VIDEO_COMPONENT_ALGORITHM enums
    union
    {
        NvU64 qwReserved[9];
        struct
        {
            NvU32   dwAppKey;           // (IN) Secret key to authenticate the caller, ONLY used in NvAPI_SetVideoState
            NvU32   bTopPriority   : 1; // (OUT)indicates that these settings have precedence over D3D NvAPI settings, ONLY valid in NvAPI_GetVideoState
            NvU32   bHasCustomAlgo : 1; // (OUT)indicates whether Out-of-process app has custom algorithm data
            NvU32   bReserved      : 30;// (OUT) reserved for expansion
            struct
            {
                NvU64   pData;          // (IN) Buffer to hold the retreived custom algo data
                NvU32   dwSize;         // (IN) Size in Bytes of the above buffer, must be <= NVAPI_VIDEO_STATE_MAX_CUSTOM_ALGO_SIZE.
            } customAlgo;
        } appInfo;
    };
} NVAPI_GET_VIDEO_STATE_COMPONENT;

#define NVAPI_GET_VIDEO_STATE_COMPONENT_VER  MAKE_NVAPI_VERSION(NVAPI_GET_VIDEO_STATE_COMPONENT,1)

// Return status after attempting to set a video component
typedef enum _NVAPI_VIDEO_COMP_RETURN_STATUS
{
    VIDEO_COMP_STATUS_SUCCESS                   = 0x00000000, // Video component is set successfully
    VIDEO_COMP_STATUS_UNSUCCESSFUL              = 0x00000001, // Failed to set video component
    VIDEO_COMP_STATUS_COMPONENT_NOT_SUPPORTED   = 0x00000002, // Video component is not supported
    VIDEO_COMP_STATUS_VALUE_OUT_OF_RANGE        = 0x00000004, // Video component's value is invalid and does not fall into range
    VIDEO_COMP_STATUS_ALGO_NOT_RECOGNIZED       = 0x00000008, // Video component's algorithm is invalid
    VIDEO_COMP_STATUS_OVERRIDDEN_BY_USER        = 0x00000010, // Request not completed because of user-mandated override
    VIDEO_COMP_STATUS_Y_GAMMA_ENABLED           = 0x00000020, // Cannot set RGB-gamma because Y-Gamma is already enabled
    VIDEO_COMP_STATUS_RGB_GAMMA_ENABLED         = 0x00000040, // Cannot set Y-gamma because RGB-Gamma is already enabled
} NVAPI_VIDEO_COMP_RETURN_STATUS;

// Packet containing information to allow setting the video component

#define NVAPI_VIDEO_STATE_MAX_CUSTOM_ALGO_SIZE 128

typedef struct _NVAPI_SET_VIDEO_STATE_COMPONENT
{
    NvU32   version;                        // (IN) NVAPI version that matches NVAPI_SET_VIDEO_STATE_COMPONENT_VER
    NvU32   componentID;                    // (IN) identify the individual component, one of NVAPI_VIDEO_STATE_COMPONENT_xxx enums
    NvU32   enable;                         // (IN) flag to enable setting of component, one or more of NVAPI_VIDEO_COMPONENT_ENABLE bitmasks
    NvU32   setToValue;                     // (IN) value to use
    NvU64   setToAlgo;                      // (IN) algorithm to use
    NvU32   retStatus;                      // (OUT) result of video-component-set operation; a combination of VIDEO_COMP_STATUS_xxx bitmasks
    NvU32   reserved;
    union
    {
        NvU64 qwReserved[4];
        struct
        {
            NvU32   dwAppKey;               // (IN) Secret key to authenticate the caller, ONLY used in NvAPI_SetVideoState
            NvU32   bTopPriority       : 1; // (IN) Force these settings to have priority over D3D NvAPI settings, ONLY valid in NvAPI_GetVideoState
            NvU32   bHasCustomAlgo     : 1; // (IN) Out-of-process app has custom algorithm data
            NvU32   bReserved          : 30;// (IN) reserved for expansion
            struct
            {
                NvU64   pData;              // (IN) (Used only when bHasCustomAlgo == 1) Pointer to the custom algo data.
                NvU32   dwSize;             // (IN) (Used only when bHasCustomAlgo == 1) Size in Bytes of the custom algo data, must be <= NVAPI_VIDEO_STATE_MAX_CUSTOM_ALGO_SIZE.
            } customAlgo;
        } appInfo;
    };
} NVAPI_SET_VIDEO_STATE_COMPONENT;

#define NVAPI_SET_VIDEO_STATE_COMPONENT_VER  MAKE_NVAPI_VERSION(NVAPI_SET_VIDEO_STATE_COMPONENT,1)

#endif // NV_VIDEO_COMPONENTS_DEFINE

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_GetVideoState
//
//   DESCRIPTION: Return the video state component for the component ID passed in.
//
//  SUPPORTED OS: Windows Vista and higher
//
//         INPUT: pDev             (IN)         The D3D device for which the component is requested
//                pGetVidStateComp (IN/OUT)     NVAPI_GET_VIDEO_STATE_COMPONENT packet containing
//                                              a valid component ID
//
// RETURN STATUS: an int which could be an NvAPI status (NVAPI_OK, NVAPI_INVALID_ARGUMENT,
//                NVAPI_INCOMPATIBLE_STRUCT_VERSION, NVAPI_ERROR) or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_GetVideoState(IDirect3DDevice9 *pDev,
                                         NVAPI_GET_VIDEO_STATE_COMPONENT *pGetVidStateComp);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_SetVideoState
//
//   DESCRIPTION: API that allows callers to set a particular video state component
//
//  SUPPORTED OS: Windows Vista and higher
//
//         INPUT: pDev             (IN)         The D3D device for which the component-set is requested
//                pSetVidStateComp (IN/OUT)     NVAPI_SET_VIDEO_STATE_COMPONENT packet containing
//                                              the video component info to be applied
//
// RETURN STATUS: an int which could be an NvAPI status (NVAPI_OK, NVAPI_INVALID_ARGUMENT,
//                NVAPI_INCOMPATIBLE_STRUCT_VERSION, NVAPI_ERROR) or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_SetVideoState(IDirect3DDevice9 *pDev,
                                         NVAPI_SET_VIDEO_STATE_COMPONENT *pSetVidStateComp);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_EnumVideoFeatures
//
//   DESCRIPTION:   Enumerates all video featuew supported on current config 
//                  First, the client should call the function with VF_GET_COUNT flag set. This will return the total 
//                  feature count. 
//                  Then client will call this function again iteratively, with the VF_GET_DETAILS flag until all of 
//                  the features get enumerated.
//  SUPPORTED OS: Windows XP and higher
//
//
// RETURN STATUS: an int which could be an NvAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////
// enums and structs related to Video Features
#define NVAPI_MAX_FEATURES_PER_PACKET   3 // max number of structs that can fit into dwArgs[20] of nvdxExtensionData struct

// Video feature IDs. Update the nvVidFeatureNames[] array in nvd3d.cpp when adding a new Feature ID.
typedef enum _NVAPI_VIDEO_FEATURE
{
    NVAPI_VF_UNKNOWN = 0,
    NVAPI_VF_MPEG2SDDecodeAcceleration,
    NVAPI_VF_MPEG2HDDecodeAcceleration,
    NVAPI_VF_VC1SDDecodeAcceleration,
    NVAPI_VF_VC1HDDecodeAcceleration,
    NVAPI_VF_H264SDDecodeAcceleration,
    NVAPI_VF_H264HDDecodeAcceleration,
    NVAPI_VF_WMV9SDDecodeAcceleration,
    NVAPI_VF_WMV9HDDecodeAcceleration,
    NVAPI_VF_ProcAmp,
    NVAPI_VF_ColorTemperatureCorrection,
    NVAPI_VF_ColorSpaceConversion,
    NVAPI_VF_GammaCorrection,
    NVAPI_VF_OverDrive,
    NVAPI_VF_DynamicContrastEnhancement,
    NVAPI_VF_StretchBlueGreenSkin,
    NVAPI_VF_AdaptiveDeInterlacing,
    NVAPI_VF_NoiseReduction,
    NVAPI_VF_EdgeEnhancement,
    NVAPI_VF_InverseTelecine,
    NVAPI_VF_Scaling,
    NVAPI_VF_VideoMirror,
    NVAPI_VF_Blend,
    NVAPI_VF_DxvaHDTest,
    NVAPI_VF_GamutRemap,
    NVAPI_VF_MftXcode,
    NVAPI_VF_SkinToneCorrection,

    NVAPI_VF_ID_LAST,
} NVAPI_VIDEO_FEATURE;

// Update the nvVidEngineNames[] array in nvd3d.cpp when adding a new Engine name.
typedef enum _NVAPI_VIDEO_ENGINES
{
    NVAPI_VE_UNKNOWN = 0,
    NVAPI_VE_PixelShader,
    NVAPI_VE_MPEG2Decoder,
    NVAPI_VE_VideoProcessor1,
    NVAPI_VE_VideoProcessor2,
    NVAPI_VE_MSDEC,
} NVAPI_VIDEO_ENGINES;

// Update the nvVidEntryPointNames[] array in nvd3d.cpp when adding a new Entry point in this enum.
typedef enum _NVAPI_VIDEO_DRIVER_ENTRY_POINT
{
    NVAPI_EP_UNKNOWN = 0,
    NVAPI_EP_DecodeEndFrame,
    NVAPI_EP_OverlayTransfer,
    NVAPI_EP_DIBlitEx,
    NVAPI_EP_VideoProcessBlt,
    NVAPI_EP_D3DBlt,
    NVAPI_EP_Blit32,
    NVAPI_EP_VPBltHD,
} NVAPI_VIDEO_DRIVER_ENTRY_POINT;

typedef enum _NVAPI_VIDEO_FEATURE_GET_FLAG
{
    NVAPI_VF_GET_COUNT = 0,
    NVAPI_VF_GET_DETAILS,
} NVAPI_VIDEO_FEATURE_GET_FLAG;

typedef struct _NVAPI_VIDEO_FEATURE_DETAILS
{
    NVAPI_VIDEO_FEATURE            eFeature;
    NVAPI_VIDEO_ENGINES            eEngine;
    NVAPI_VIDEO_DRIVER_ENTRY_POINT eEntryPoint;
    NvU32                          dwReserved;
} NVAPI_VIDEO_FEATURE_DETAILS;

// returns the strings for each feature to the client 
typedef struct _NVAPI_VID_FEATURE_STRINGS
{
    NVAPI_VIDEO_FEATURE eFeature;
    NvAPI_ShortString   szFeature; // feature name
    NvAPI_ShortString   szEngine; // video engine name
    NvAPI_ShortString   szDrvEntryPoint; // drv Entry Point name
    NvAPI_ShortString   szReserved1; // reserved for future expansion
} NVAPI_VID_FEATURE_STRINGS;

#define NVAPI_VIDEO_FEATURE_DESCRIPTOR_VER  1

typedef struct _NVAPI_VIDEO_FEATURE_DESCRIPTOR
{
    NvU32                          version;                     // (IN) version that matches NVAPI_VIDEO_FEATURE_DETAILS_PACKET_VER
    NVAPI_VIDEO_FEATURE_GET_FLAG   eVideoFeatureGetID;          // (IN) get total feature count or feature details
    NvU32                          dwVFCount;                   // (OUT) feature count returned
    NvU32                          dwStartVFCount;              // (IN) starting surface count when reading the data
    NVAPI_VIDEO_FEATURE_DETAILS    astFeatureDetails[NVAPI_MAX_FEATURES_PER_PACKET]; // (OUT) array of video feature details
    NvU32                          adwReserved[4];              // (IN/OUT) reserved for future expansion
} NVAPI_VIDEO_FEATURE_DESCRIPTOR;

typedef struct _NVAPI_DX_VIDEO_FEATURE_DETAILS
{
    NvU32                           version;              // (IN) NVAPI version that matched NVAPI_DX_VIDEO_FEATURE_DETAILS_VER
    NVAPI_VIDEO_FEATURE_DESCRIPTOR  videoFeaturesPacket;  // (IN/OUT)
    NVAPI_VID_FEATURE_STRINGS       astFeatureDescNames[NVAPI_MAX_FEATURES_PER_PACKET]; // (OUT) descriptor strings 
} NVAPI_DX_VIDEO_FEATURE_DETAILS;


#define NVAPI_DX_VIDEO_FEATURE_DETAILS_VER MAKE_NVAPI_VERSION(NVAPI_DX_VIDEO_FEATURE_DETAILS,1)


NVAPI_INTERFACE NvAPI_D3D9_EnumVideoFeatures(IDirect3DDevice9 *pDev, 
                                                NVAPI_DX_VIDEO_FEATURE_DETAILS *pVideoFeatureDetails);

                                         
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_GetSLIInfo
//
// DESCRIPTION:     This API is obsolete, please use NvAPI_D3D_GetCurrentSLIState
//
//  SUPPORTED OS: Windows XP
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_NO_ACTIVE_SLI_TOPOLOGY - SLI is not active on this device
//                  NVAPI_ERROR - error occurred
//
///////////////////////////////////////////////////////////////////////////////
typedef enum _NV_SLI_MODE
{
    NV_SLI_RENDERING_MODE_AUTOSELECT  = 0,     // AutoSelect
    NV_SLI_RENDERING_MODE_AFR         = 1,     // Alternate Frames
    NV_SLI_RENDERING_MODE_SFR         = 2,     // Split Frame
    NV_SLI_RENDERING_MODE_SINGLE      = 3      // Single GPU
} NV_SLI_MODE;

typedef struct
{
    NvU32 version;                       // Structure version

    NV_SLI_MODE         mode;            // [OUT] Current SLI mode
    NvU32               gpus;            // [OUT] Number of GPUs
} NV_SLI_INFO;
#define NV_SLI_INFO_VER  MAKE_NVAPI_VERSION(NV_SLI_INFO,1)

NVAPI_INTERFACE NvAPI_D3D9_GetSLIInfo(IDirect3DDevice9 *pDev, NV_SLI_INFO *pSliInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_SetSLIMode
//
// DESCRIPTION:     Sets the SLI rendering mode for D3D device. The NVAPI_SLI_RENDERING_MODE_NOTALLOWED
//                  return status occurs when SLI mode is set in the middle of a rendering. An app may try
//                  to recreate/reset device and perform the call again. The normal way to setup the SLI mode
//                  is immediately after CreateDevice() or Reset(). The NVAPI_NO_ACTIVE_SLI_TOPOLOGY value is
//                  returned when SLI is not active on this device.
//
//  SUPPORTED OS: Windows XP
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_NO_ACTIVE_SLI_TOPOLOGY - SLI is not active on this device
//                  NVAPI_SLI_RENDERING_MODE_NOTALLOWED - setup of SLI mode is not possible right now
//                  NVAPI_INVALID_ARGUMENT - invalid rendering mode
//                  NVAPI_ERROR - error occurred
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_SetSLIMode(IDirect3DDevice9 *pDev, NV_SLI_MODE SliMode);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_QueryAAOverrideMode
//
// DESCRIPTION:     Returns the AA mode selected through NVCPL,
//                  the corresponding buffer requirement and the equivalent multisample quality
//
//  SUPPORTED OS: Windows XP and higher
//
// INPUT:           pDev                  (IN)     The D3D device for which the component is requested
//                  pRenderingSampleCount (OUT)    The number of equivalent sample counts for this AA method, 0 indicates no CPLAA
//                  pBufferSampleCount    (OUT)    The number of buffer samples required for every pixel, 0 indicates no CPLAA
//                  pAAMode               (OUT)    The AA mode that is currently selected
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - error occurred
//
///////////////////////////////////////////////////////////////////////////////

enum
{
    NVAPI_AAMODE_VCAA             = 0x00000001,    // The current AA method is one of the VCAA methods
    NVAPI_AAMODE_SLIAA            = 0x00000002,    // The current AA method is one of the SLIAA methods
    NVAPI_AAMODE_VCAA_HIGHQUALITY = 0x00000004     // The current AA method is a VCAA high quality method
};

NVAPI_INTERFACE NvAPI_D3D9_QueryAAOverrideMode(IDirect3DDevice9 *pDev, NvU32* pRenderingSampleCount, NvU32* pBufferSampleCount, NvU32* pAAMode);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_D3D9_VideoSurfaceEncryptionControl
//
// DESCRIPTION:     This API is deprecated.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS:   NVAPI_NOT_SUPPORTED - deprecated
//
///////////////////////////////////////////////////////////////////////////////

// Video Surface Encryption Control Commands
typedef enum
{
    NVAPI_VIDSURF_ENCRYPT_CMD_NULL              = 0x00, // Null command
    NVAPI_VIDSURF_ENCRYPT_CMD_GET_GUID_COUNT    = 0x01, // Get GUID count
    NVAPI_VIDSURF_ENCRYPT_CMD_GET_GUIDS         = 0x02, // Get GUIDs
    NVAPI_VIDSURF_ENCRYPT_CMD_SET_GUID          = 0x03, // Set GUID
    NVAPI_VIDSURF_ENCRYPT_CMD_ENABLE            = 0x04, // Enable encryption
    NVAPI_VIDSURF_ENCRYPT_CMD_SET_KEY           = 0x05, // Set key
    NVAPI_VIDSURF_ENCRYPT_CMD_SET_IV            = 0x06  // Set IV
} NVAPI_VIDSURF_ENCRYPT_COMMANDS;

#define NVAPI_VIDSURF_ENCRYPT_MAX_GUIDS        (4)

typedef struct
{
    NvU32   dwGuidCount;                                // (OUT)
} NVAPI_VIDSURF_ENCRYPT_CTRL_GET_GUID_COUNT;

typedef struct
{
    GUID    guids[NVAPI_VIDSURF_ENCRYPT_MAX_GUIDS];     // (OUT)
} NVAPI_VIDSURF_ENCRYPT_CTRL_GET_GUIDS;

typedef struct
{
    GUID    guid;                                       // (IN)
} NVAPI_VIDSURF_ENCRYPT_CTRL_SET_GUID;

typedef struct
{
    IDirect3DSurface9  *pSurface;                       // D3D9 surface ptr (IN)
    NvU32               bEnable;                        // (IN)
} NVAPI_VIDSURF_ENCRYPT_CTRL_ENABLE;

typedef struct
{
    NvU32   dwEncryptKeyProtectionMode;
    NvU32   dwEncryptKeyProtectionIdentifier;
    NvU32   dwKey[4];                                   // (IN)
} NVAPI_VIDSURF_ENCRYPT_CTRL_SET_KEY;

typedef struct
{
    NvU32   dwEncryptKeyProtectionMode;
    NvU32   dwEncryptKeyProtectionIdentifier;
    NvU32   dwIV[4];                                    // (IN)
} NVAPI_VIDSURF_ENCRYPT_CTRL_SET_IV;

typedef struct
{
    NvU32               version;                        // structure version (IN)
    NvU32               dwCommand;                      // command (IN)
    union
    {
        NVAPI_VIDSURF_ENCRYPT_CTRL_GET_GUID_COUNT       GetGuidCount;
        NVAPI_VIDSURF_ENCRYPT_CTRL_GET_GUIDS            GetGuids;
        NVAPI_VIDSURF_ENCRYPT_CTRL_SET_GUID             SetGuid;
        NVAPI_VIDSURF_ENCRYPT_CTRL_ENABLE               Enable;
        NVAPI_VIDSURF_ENCRYPT_CTRL_SET_KEY              SetKey;
        NVAPI_VIDSURF_ENCRYPT_CTRL_SET_IV               SetIV;
    };
} NVAPI_VIDSURF_ENCRYPT_CTRL_PARAMS;

#define NVAPI_VIDSURF_ENCRYPT_CTRL_PARAMS_VER \
    MAKE_NVAPI_VERSION(NVAPI_VIDSURF_ENCRYPT_CTRL_PARAMS,1)

NVAPI_INTERFACE NvAPI_D3D9_VideoSurfaceEncryptionControl(IDirect3DDevice9 *pDev,
    NVAPI_VIDSURF_ENCRYPT_CTRL_PARAMS *pVidSurfEncrCtrlParams);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_D3D9_DMA
//
// DESCRIPTION:     This API lets caller to perform a number of functions related to
//                  the efficient DMA transfer of data between a D3D9 surface and
//                  user-allocated system memory.
//
//  SUPPORTED OS: Windows Vista and higher
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT: Invalid input parameter.
//                  NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of
//                      NVAPI_D3D9_DMA_PARAMS struct not supported
//
///////////////////////////////////////////////////////////////////////////////

// D3D9 DMA Commands
typedef enum _NVAPI_D3D9_DMA_COMMANDS
{
    NVAPI_D3D9_DMA_CMD_NULL         = 0x00,             // Null command
    NVAPI_D3D9_DMA_CMD_DESCRIBE     = 0x01,             // Describe allocation requirements
    NVAPI_D3D9_DMA_CMD_MAP          = 0x02,             // Map user-allocated system memory
    NVAPI_D3D9_DMA_CMD_UNMAP        = 0x03,             // Unmap user-allocated system memory
    NVAPI_D3D9_DMA_CMD_REG_EVENT    = 0x04,             // Register user-mode event handle
    NVAPI_D3D9_DMA_CMD_UNREG_EVENT  = 0x05,             // Unregister user-mode event handle
    NVAPI_D3D9_DMA_CMD_TRANSFER     = 0x06,             // Transfer between user system memory and D3D9 surface
} NVAPI_D3D9_DMA_COMMANDS;

// specifies the direction of the DMA transfer
// see NVAPI_D3D9_DMA_TRANSFER_PARAMS for more details
typedef enum _NVAPI_D3D9_DMA_TRANSFER_DIR
{
    NVAPI_D3D9_DMA_TRANSFER_DIR_UPLOAD     = 0x00,      // transfer from user system memory to D3D9 surface
    NVAPI_D3D9_DMA_TRANSFER_DIR_DOWNLOAD   = 0x01,      // transfer from D3D9 surface to user system memory
} NVAPI_D3D9_DMA_TRANSFER_DIR;

// specifies the type of the DMA transfer
// see NVAPI_D3D9_DMA_TRANSFER_PARAMS for more details
typedef enum _NVAPI_D3D9_DMA_TRANSFER_TYPE
{
    NVAPI_D3D9_DMA_TRANSFER_TYPE_PROGRESSIVE    = 0x00, // transfer progressive frame
    NVAPI_D3D9_DMA_TRANSFER_TYPE_INTERLACED     = 0x01, // transfer both fields and keep the result interleaved
    NVAPI_D3D9_DMA_TRANSFER_TYPE_BOB_TOP_FIELD  = 0x02, // perform bob deinterlacing on the top field
    NVAPI_D3D9_DMA_TRANSFER_TYPE_BOB_BTM_FIELD  = 0x03, // perform bob deinterlacing on the bottom field
} NVAPI_D3D9_DMA_TRANSFER_TYPE;

// parameter data structure for the NVAPI_D3D9_DMA_CMD_DESCRIBE command
// given the surface dimension and format as input, this command
// describes the driver requirements (such as alignment) for memory allocation
typedef struct _NVAPI_D3D9_DMA_DESCRIBE_PARAMS
{
    NvU32                       dwWidth;                // width (IN)
    NvU32                       dwHeight;               // height (IN)
    NvU32                       dwFormat;               // FOURCC format (IN)
    NvU32                       dwPitch;                // pitch (OUT)
    NvU32                       dwSize;                 // size (OUT)
    NvU32                       dwAlignment;            // alignment (OUT)
} NVAPI_D3D9_DMA_DESCRIBE_PARAMS;

// parameter data structure for the NVAPI_D3D9_DMA_CMD_MAP command
// maps user-allocated system memory buffer to NV DX object handle
// the pMemory buffer must satisfy the driver requirements
// supported FOURCC formats are: NV12, YV12, YUY2
typedef struct _NVAPI_D3D9_DMA_MAP_PARAMS
{
    NvU32                       dwWidth;                // width (IN)
    NvU32                       dwHeight;               // height (IN)
    NvU32                       dwFormat;               // FOURCC format (IN)
    void                       *pMemory;                // memory pointer (IN)
    NVDX_ObjectHandle           hSysmemSurface;         // sysmem surface handle (OUT)
} NVAPI_D3D9_DMA_MAP_PARAMS;

// parameter data structure for the NVAPI_D3D9_DMA_CMD_UNMAP command
// unmaps user-allocated system memory buffer
typedef struct _NVAPI_D3D9_DMA_UNMAP_PARAMS
{
    NVDX_ObjectHandle           hSysmemSurface;         // sysmem surface handle (IN)
} NVAPI_D3D9_DMA_UNMAP_PARAMS;

// parameter data structure for the NVAPI_D3D9_DMA_CMD_REG_EVENT
// command and the NVAPI_D3D9_DMA_CMD_UNREG_EVENT command
// registers or unregisters a user-mode event handle with the D3D9 device
typedef struct _NVAPI_D3D9_DMA_EVENT_PARAMS
{
    HANDLE                      hCompletionEvent;       // user-mode event handle (IN)
} NVAPI_D3D9_DMA_EVENT_PARAMS;

// parameter data structure for the NVAPI_D3D9_DMA_CMD_TRANSFER command
// performs DMA transfer between system memory buffer and D3D9 surface
// supports both upload and download directions
// supports scaling, color space and pixel format conversion
// a NULL rectangle indicates that the entire surface is used
typedef struct _NVAPI_D3D9_DMA_TRANSFER_PARAMS
{
    NVAPI_D3D9_DMA_TRANSFER_DIR     direction;          // direction of the transfer (IN)
    NVDX_ObjectHandle               hSysmemSurface;     // sysmem surface handle (IN)
    RECT*                           pSysmemSurfaceRect; // sysmem surface rectangle (IN)
    NVDX_ObjectHandle               hD3D9Surface;       // D3D9 surface handle (IN)
    RECT*                           pD3D9SurfaceRect;   // D3D9 surface rectangle (IN)
    HANDLE                          hCompletionEvent;   // completion event handle (IN)
    NVAPI_D3D9_DMA_TRANSFER_TYPE    transferType;       // type of the transfer (IN)
    NvU32                           reserved;           // reserved for future expansion (IN / OUT)
} NVAPI_D3D9_DMA_TRANSFER_PARAMS;

typedef struct _NVAPI_D3D9_DMA_PARAMS
{
    NvU32               version;                        // structure version (IN)
    NvU32               dwCommand;                      // command (IN)
    union
    {
        NVAPI_D3D9_DMA_DESCRIBE_PARAMS     DescribeParams;
        NVAPI_D3D9_DMA_MAP_PARAMS          MapParams;
        NVAPI_D3D9_DMA_UNMAP_PARAMS        UnmapParams;
        NVAPI_D3D9_DMA_EVENT_PARAMS        EventParams;
        NVAPI_D3D9_DMA_TRANSFER_PARAMS     TransferParams;
    };
} NVAPI_D3D9_DMA_PARAMS;

#define NVAPI_D3D9_DMA_PARAMS_VER \
    MAKE_NVAPI_VERSION(NVAPI_D3D9_DMA_PARAMS, 1)

NVAPI_INTERFACE NvAPI_D3D9_DMA(IDirect3DDevice9 *pDev,
    NVAPI_D3D9_DMA_PARAMS *pVideoDMAParams);
        
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_StretchRect
//
// DESCRIPTION:     Copy the contents of the source rectangle to the
//                  destination rectangle.  This function can convert
//                  between a wider range of surfaces than
//                  IDirect3DDevice9::StretchRect.  For example, it can copy
//                  from a depth/stencil surface to a texture.
//
//  SUPPORTED OS: Windows XP and higher
//
// INPUT:           pDev          (IN)     The D3D device that owns the objects.
//                  hSrcObj       (IN)     Handle to the source object.
//                  pSrcRect      (IN)     Defines the rectangle on the source to copy from.  If null, copy from the entire object.
//                  hDstObj       (IN)     Handle to the destination object.
//                  pDstRect      (IN)     Defines the rectangle on the destination to copy to.  If null, copy to the entire object.
//                  Filter        (IN)     Choose a filtering method: D3DTEXF_NONE, D3DTEXF_POINT, D3DTEXF_LINEAR.
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - error occurred
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_StretchRect(IDirect3DDevice9 *pDev,
                                       NVDX_ObjectHandle hSrcObj,
                                       CONST RECT * pSourceRect,
                                       NVDX_ObjectHandle hDstObj,
                                       CONST RECT * pDestRect,
                                       D3DTEXTUREFILTERTYPE Filter);

                                       
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_RegisterResource
//
// DESCRIPTION:     To bind a resource (surface/texture) so that it can be retrieved
//                  internally by nvapi.
//
//  SUPPORTED OS: Windows XP and higher
// INPUT:           pUnknown    (IN)    surface/texture
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - error occurred
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_RegisterResource(IUnknown* pUnknown);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_UnregisterResource
//
// DESCRIPTION:     To unbind a resource (surface/texture) after usage.
//
//  SUPPORTED OS: Windows XP and higher
// INPUT:           pUnknown    (IN)    surface/texture
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - error occurred
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_UnregisterResource(IUnknown* pUnknown);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_SetTexture
//
// DESCRIPTION:     The format/usage is similar to IDirect3DDevice9::SetTexture, 
//                  but it would allow you to bind a msaa depthbuffer and 
//                  use as a texture by the pshaders
//
//  SUPPORTED OS: Windows XP and higher
// INPUT:           pDev          (IN)     The D3D device that owns the objects.
//                  uStage        (IN)     The stage/sampler number
//                  pSurface      (IN/OUT) Pointer to a depth stencil surface to bind (cannot be MSAA RenderTarget)
//                  ppTex         (IN/OUT) Pointer to a texture pointer, so that it can return a linked texture
//                  pState        (IN/OUT) pState to describe how to deal with the linked texture and the depth stencil
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - error occurred
//
///////////////////////////////////////////////////////////////////////////////
typedef enum {
    NVAPI_SET_DEPTH_TEX_DEFAULT    = 0,
    NVAPI_SET_DEPTH_TEX_DISCONNECT = 1,
    NVAPI_SET_DEPTH_TEX_RECONNECT  = 2
} NVAPI_SET_DEPTH_TEX_STATE;

NVAPI_INTERFACE NvAPI_D3D9_SetTexture(IDirect3DDevice9 *pDev, NvU32 uStage, IDirect3DSurface9 *pSurface, IDirect3DTexture9 **ppTex, NVAPI_SET_DEPTH_TEX_STATE *pState);

#endif //defined(_D3D9_H_) && defined(__cplusplus)



#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Video_Bringup
//
//   DESCRIPTION: Run video engine bringup test
//                Replaces the NVDIAG_CMD_ENGINE_BRINGUP
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////

// Video engine bringup action type
typedef enum _NVAPI_VIDEO_BRINGUP_ACTION
{
    NVAPI_VIDEO_BRINGUP_ACTION_RUN_TEST     = 0x01,     // Run test
    NVAPI_VIDEO_BRINGUP_ACTION_CHECK_RESULT = 0x02,     // Check test result
} NVAPI_VIDEO_BRINGUP_ACTION;

// Video engine bringup test type
typedef enum _NVAPI_VIDEO_BRINGUP_TEST
{
    NVAPI_VIDEO_BRINGUP_TEST_TCIPHER_BASIC  = 0x01,     // Turbo cipher basic test
    NVAPI_VIDEO_BRINGUP_TEST_COMPUTE_MULTI  = 0x02,     // Compute multi test
    NVAPI_VIDEO_BRINGUP_TEST_SEC_BASIC      = 0x03,     // SEC basic test
    NVAPI_VIDEO_BRINGUP_TEST_SEC_EXECUTE    = 0x04,     // SEC execute test
} NVAPI_VIDEO_BRINGUP_TEST;

typedef struct _NVAPI_VIDEO_BRINGUP_PARAMS
{
    NvU32                       version;                // structure version (IN)
    NVAPI_VIDEO_BRINGUP_ACTION  action;                 // action type (IN)
    NVAPI_VIDEO_BRINGUP_TEST    test;                   // test type (IN)
    NvU32                       params[4];              // input parameters (IN)
    void                       *pOutput;                // output (OUT)
    NvU32                       dwOutputSize;           // output size (IN)
} NVAPI_VIDEO_BRINGUP_PARAMS;

#define NVAPI_VIDEO_BRINGUP_PARAMS_VER \
    MAKE_NVAPI_VERSION(NVAPI_VIDEO_BRINGUP_PARAMS, 1)

NVAPI_INTERFACE NvAPI_Video_Bringup(IDirect3DDevice9 *pDev,
    NVAPI_VIDEO_BRINGUP_PARAMS *pVideoBringupParams);

#endif // defined(_D3D9_H_) && defined(__cplusplus)

//-----------------------------------------------------------------------------
// DirectX + BDVMA private API
//-----------------------------------------------------------------------------


#if defined(_D3D9_H_) && defined(__cplusplus)


// FUNCTION NAME: NvAPI_D3D9_BDVMA_Alloc
//
//  SUPPORTED OS: Windows Vista and higher
//
// RETURN STATUS: NVAPI_OK if the call succeeded
//
///////////////////////////////////////////////////////////////////////////////

typedef struct 
{
    NvU32               version;                // structure version (IN)

    NvU32               dwFunction;             // [OUT] 1 is Alloc, 2 is Free, 3 is Map, 4 is UnMap
    NvU32               dwSize;                 // [IN] Size of the allocation
    NvU32               hAllocHandle;           // [OUT/IN] RM handle of the alloc
    NvU64               qwPhysVidOffset;        // [OUT/IN] Physical offset of the memory allocated in the frame buffer
    void *              pCPUPtr;                // [OUT/IN] CPU mapping
    void *              pMemAllocPtr;           // [OUT/IN] pointer to MEMALLOCATION
} NV_BDVMA_INFO;
 
NVAPI_INTERFACE NvAPI_D3D9_BDVMA(IDirect3DDevice9 *pDev, NV_BDVMA_INFO *pBDVMAInfo);


///////////////////////////////////////////////////////////////////////////////
//
#endif // defined(_D3D9_H_) && defined(__cplusplus)


//-----------------------------------------------------------------------------
// Direct3D10 APIs
//-----------------------------------------------------------------------------

#if defined(__cplusplus) && defined(__d3d10_h__)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_AliasPrimaryAsTexture
//
//   DESCRIPTION: Create an texture that is an alias of current device's
//                primary surface
//
//  SUPPORTED OS: Windows XP and higher
//
//         INPUT:  pDev        The device to get primary surface on
//                 dwHeadIndex The index to the head to alias.
//
//        OUTPUT:  ppTexture  Fill with the texture created
//
// RETURN STATUS: NVAPI_OK if the texture was successfully created
//                NVAPI_ERROR if the texture could not be created
//
// NOTE: The texture returned is created without any CPU access flags. Locking
//       to read from the texture should be done by creating an second
//       application. Otherwise, this texture can be used as any normal
//       Direct3D texture (it can be blitted from, used as a texture in a
//       pixel shader, etc.)
//
//       This texture is not a render target and cannot be rendered to.
//
//       Before this texture is used, the application must call
//       NvAPI_D3D10_ProcessFlipChainCallbacks to properly update any internal
//       driver state.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_AliasPrimaryAsTexture(ID3D10Device *pDev,
                                             NvU32 headIndex,
                                             ID3D10Texture2D **ppTexture);

typedef void (*NVAPI_PRIMARY_FLIP_CHAIN_CALLBACK)(NvU32);

typedef struct
{
    NvU32                     version;              // structure version (IN)

    NVAPI_PRIMARY_FLIP_CHAIN_CALLBACK pPrimaryFlipped; // a callback function to be notified
                                                       // when the primary flip occured.

    NVAPI_PRIMARY_FLIP_CHAIN_CALLBACK pPrimaryFlipChainModified; // a callback function to be notified
                                                                 // when the primary flip chain has
                                                                 // been modified, either due to a new
                                                                 // surface being added, an existing
                                                                 // surface being removed, or the resolution
                                                                 // was changed. In response to this
                                                                 // an application MUST recreate any
                                                                 // aliased primary surfaces with
                                                                 // NvAPI_D3D10_AliasPrimaryAsTexture
                                                                 // as the existing texture will be invalid

    NVAPI_PRIMARY_FLIP_CHAIN_CALLBACK pPrimaryAliasInvalid; // an error occured while using a texture
                                                            // created with NvAPI_D3D10_AliasPrimaryAsTexture
                                                            // The texture needs to be re-created

    NVAPI_PRIMARY_FLIP_CHAIN_CALLBACK pPrimaryAliasOperationDropped; // an operation using the primary alias
                                                                     // was not completed because a flip
                                                                     // happened while the the operation
                                                                     // was in progress. The last operation
                                                                     // may have operated on an incomplete
                                                                     // primary, and should be retried.

    NVAPI_PRIMARY_FLIP_CHAIN_CALLBACK pCursorVisibleUpdated;  // a callback function to be notified
                                                              // when the cursor visibility has been toggled

    NVAPI_PRIMARY_FLIP_CHAIN_CALLBACK pCursorShapeUpdated; // a callback function to be notified
                                                           // when the cursor shape has been updated

} NVAPI_FLIP_CHAIN_CALLBACK_PARAMS;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_SetPrimaryFlipChainCallbacks
//
//   DESCRIPTION: Defines callback functions to receive notification about
//                certain events relating to the primary flip chain.
//
//  SUPPORTED OS: Windows XP and higher
//
//         INPUT:  pDev            The device to receive events on
//                 pCallbackParams A structure containing function
//                                 pointers that will receive the events.
//                                 A pointer may be set to NULL if
//                                 an application does not wish to receive
//                                 the notification.
//
// RETURN STATUS: NVAPI_OK if the events were registered successfully
//
// NOTE: The events will only be registered at this time. To receive the events
//       an application must call NvAPI_D3D10_ProcessFlipChainCallbacks.
//
//       An application may change it's callback functions at any time, and may
//       unregister from any function by passing NULL in as a function pointer.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_SetPrimaryFlipChainCallbacks(ID3D10Device *pDev,
                                             const NVAPI_FLIP_CHAIN_CALLBACK_PARAMS* pCallbackParams);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_ProcessCallbacks
//
//   DESCRIPTION: Processes pending events
//
//  SUPPORTED OS: Windows XP and higher
//
//         INPUT:  pDev            The device to process events on
//                 dwMilliseconds  The number of milliseconds to sleep while
//                                 waiting for events before returning. This
//                                 may be zero to only process any outstanding
//                                 events, or INFINITE if the application
//                                 wishes to wait forever.
//
// RETURN STATUS: NVAPI_OK if events were properly processed
//
// NOTE: All callback functions are passed the head index for the event.
//
//       This will call the registered callbacks for any events pending. With
//       the exeception of the primary flipped callback, an application cannot
//       "miss" an event if the event were to be notified while the
//       application was not calling ProcessCallbacks. The application
//       will receive this event the first time it calls ProcessCallbacks
//       after the event happened.
//
//       The flipped event is an exception to this rule. This callback will
//       only be fired for flips that occur after the application calls
//       ProcessCallbacks.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_ProcessCallbacks(ID3D10Device *pDev,
                                             NvU32 dwMilliseconds);


typedef enum
{
    NV_HW_CURSOR_COLOR_FORMAT_MONOCHROME     = 0,
    NV_HW_CURSOR_COLOR_FORMAT_COLOR          = 1,
    NV_HW_CURSOR_COLOR_FORMAT_MASKED_COLOR   = 2
} NV_HW_CURSOR_COLOR_FORMAT_FLAGS;

typedef struct _NVAPI_RENDERED_CURSOR_BITMAP_DATA
{
    NvU32 version;     // (in) version info
    NvU32 headIndex;   // (in) head index to get cursor on
    NvU32 bufferSize;  // (in) size of raw bitmap data buffer
    PBITMAP pBitmap;   // (in/out) bitmap data for rendered cursor
    NvU32 xHot;        // (out) x value for Hotspot
    NvU32 yHot;        // (out) y value for Hotspot
    NV_HW_CURSOR_COLOR_FORMAT_FLAGS formatFlag; // (out) cursor color format
    NvU32 bVisible;    // (out) cursor visibility (0 = not visible)
} NVAPI_RENDERED_CURSOR_BITMAP_DATA;

#define NVAPI_RENDERED_CURSOR_BITMAP_DATA_VER  MAKE_NVAPI_VERSION(NVAPI_RENDERED_CURSOR_BITMAP_DATA,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_GetRenderedCursorAsBitmap
//
//   DESCRIPTION:  Provide a bitmap of the hardware cursor and the visible
//                 state of the cursor at the time the bitmap is captured.
//
//  SUPPORTED OS: Windows XP and higher
//
//  INPUT:         pDev                       The device to get rendered cursor
//                                            on
//  INPUT/OUTPUT:  pRenderedCursorBitmapData  Structure for input/output with
//                                            fields as follows:
//                 INPUT:
//                 headIndex  The head to get the cursor on
//                 bufferSize The size of the buffer for storing
//                              raw bitmap data
//                 OUTPUT:
//                 pBitmap      Bitmap data for the rendered cursor.  Note
//                              that this result data is undefined in the
//                              case where NVAPI_OK is not the return status
//                 xHot         Location of the X hot spot in the bitmap
//                 yHot         Location of the Y hot spot in the bitmap
//                 formatFlag   Format of cursor (monochrome, color, or
//                              masked color).  For monochrome or masked
//                              color formats, the corresponding bitmap
//                              format is ROP1R5G5B5.  For color format,
//                              the bitmap format is A8R8G8B8.
//                 bVisible     Boolean:  zero=not visible, one=visible
//
//
// RETURN STATUS: NVAPI_OK if the cursor bitmap is successfully returned
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_D3D10_GetRenderedCursorAsBitmap(ID3D10Device *pDev,
                                                      NVAPI_RENDERED_CURSOR_BITMAP_DATA *pRenderedCursorBitmapData);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_SetDepthBoundsTest
//
//   DESCRIPTION: This function enables/disables the depth bounds test
//
//  SUPPORTED OS: Windows XP and higher
//
//         INPUT:  pDev         The device to set depth bounds test
//                 bEnable      Enable(non-zero)/disable(zero) the depth bounds test
//                 fMinDepth    The minimum depth for depth bounds test
//                 fMaxDepth    The maximum depth for depth bounds test
//                              The valid values for fMinDepth and fMaxDepth
//                              are such that 0 <= fMinDepth <= fMaxDepth <= 1
//
// RETURN STATUS: NVAPI_OK if the depth bounds test was correcly enabled or
//                disabled
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_SetDepthBoundsTest(ID3D10Device *pDev,
                                               NvU32 bEnable,
                                               float fMinDepth,
                                               float fMaxDepth);

// Forward declaration. See <wgf2um/inc/ShaderDebuggerStruct.h> for more details.
struct sdResourceAttributes;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_GetResourceHandle
//
//   DESCRIPTION: This function retrieves a driver handle to a DX10 resource
//
//         INPUT:  pDev         The device on which the resource was created
//                 pResource    The resource for which we want to retrieve a
//                              driver handle.
//
//  SUPPORTED OS: Windows XP and higher
//
//        OUTPUT:  phObject     Pointer to an NvAPI handle to be populated
//                              on success
//
// RETURN STATUS: NVAPI_OK if and only if phObject was populated with a valid
//                driver handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_GetResourceHandle(ID3D10Device *pDev,
                                              ID3D10Resource* pResource,
                                              NVDX_ObjectHandle* phObject);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_GetVertexShaderHandle
//
//   DESCRIPTION:  Note: call NvAPI_D3D10_RegisterDevice once before using with this function!!!
//                 This function returns a shader's handle as used inside of the UMD
//
//         INPUT:  pD3D10VertexShader  The runtime pixel shader handle
//
//  SUPPORTED OS: Windows Vista and higher
//
//        OUTPUT:  phShader     The UMD's shader handle
//
// RETURN STATUS: NVAPI_OK if pD3D10VertexShader is valid and the OUT pointers are non-null
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_GetVertexShaderHandle(ID3D10Device *pDev,
                                                  ID3D10VertexShader *pD3D10VertexShader,
                                                  NVDX_ObjectHandle* phShader);
                                                 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_GetGeometryShaderHandle
//
//   DESCRIPTION:  Note: call NvAPI_D3D10_RegisterDevice once before using with this function!!!
//                 This function returns a shader's handle as used inside of the UMD
//
//         INPUT:  pD3D10GeometryShader  The runtime pixel shader handle
//
//  SUPPORTED OS: Windows Vista and higher
//
//        OUTPUT:  phShader     The UMD's shader handle
//
// RETURN STATUS: NVAPI_OK if pD3D10GeometryShader is valid and the OUT pointers are non-null
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_GetGeometryShaderHandle(ID3D10Device *pDev,
                                                    ID3D10GeometryShader *pD3D10GeometryShader,
                                                    NVDX_ObjectHandle* phShader);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_GetPixelShaderHandle
//
//   DESCRIPTION:  Note: call NvAPI_D3D10_RegisterDevice once before using with this function!!!
//                 This function returns a shader's handle as used inside of the UMD
//
//         INPUT:  pD3D10PixelShader  The runtime pixel shader handle
//
//  SUPPORTED OS: Windows Vista and higher
//
//        OUTPUT:  phShader     The UMD's shader handle
//
// RETURN STATUS: NVAPI_OK if pD3D10PixelShader is valid and the OUT pointers are non-null
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_GetPixelShaderHandle(ID3D10Device *pDev,
                                                 ID3D10PixelShader *pD3D10PixelShader,
                                                 NVDX_ObjectHandle* phShader);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_GetShaderUCodeAllocationInfo
//
//   DESCRIPTION:  Note: call NvAPI_D3D10_RegisterDevice once before using with this function!!!
//                 This function returns a shader's address in video memory, and
//                 its memory allocation handle.
//
//         INPUT:  pDev         The device on which the resource was created
//                 hShader      Handle to the internal shader data struction of the UMD
//
//  SUPPORTED OS: Windows Vista and higher
//
//        OUTPUT:  phAllocation   The shader's allocation handle
//                 pBlockOffset   The shader's offset into its allocation
//                 pProgramOffset The offset to shader's debug instance (w.r.t. pBlockOffset)
//                 pLength        The shader block's length.
//
// RETURN STATUS: NVAPI_OK if the OUT pointers are non-null, and there exists
//                at least (index+1) shaders of the given type in memory.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_GetShaderUCodeAllocationInfo(ID3D10Device *pDev,
                                                         NVDX_ObjectHandle hShader,
                                                         NvU32* phAllocation,
                                                         NvU32* pBlockOffset,
                                                         NvU32* pProgramOffset,
                                                         NvU32* pLength);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_GetShaderLocalMemoryAllocationInfo
//
//   DESCRIPTION: Note: call NvAPI_D3D10_RegisterDevice once before using with this function!!!
//                This function returns the device's local memory allocation info.
//                It does not take a shader handle because the local memory allocation
//                is made per device and not per-shader
//
//         INPUT:  pDev         The device on which the resource was created
//
//  SUPPORTED OS: Windows Vista and higher
//
//        OUTPUT:  phAllocation      The D3DKMT local memory allocation handle
//                 pBlockOffset      The offset into the local memory allocation
//                 pLength           The length of the allocation
//                 pMaxWarpsPerSm;   The number of warps per Sm that is currently throttled
//                 pLmemBytesPerThread   The amount of lmem bytes requested for each thread
//
// RETURN STATUS: NVAPI_OK if the OUT pointers are non-null.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_GetShaderLocalMemoryAllocationInfo(ID3D10Device *pDev,
                                                               NvU32* phAllocation,
                                                               NvU32* pBlockOffset,
                                                               NvU32* pLength,
                                                               NvU32* pMaxWarpsPerSm,
                                                               NvU32* pLmemBytesPerThread);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_GetResourceAllocationInfo
//
//   DESCRIPTION: Note: call NvAPI_D3D10_RegisterDevice once before using with this function!!!
//                This function returns the allocation info of a resource.
//
//         INPUT:  pDev           The device on which the resource was created
//                 hResource      Handle to the internal resource data struction of the UMD
//
//  SUPPORTED OS: Windows Vista and higher
//
//        OUTPUT:  phAllocation          The D3DKMT local memory allocation handle
//                 pBlockOffset          The offset into the local memory allocation
//                 pLength               The length of the allocation
//.................ppResourceAttributes  The attributes of the resource (eg. width, bits per pixel, etc.)
//
// RETURN STATUS: NVAPI_OK if the OUT pointers are non-null.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_GetResourceAllocationInfo(ID3D10Device *pDev,
                                                      NVDX_ObjectHandle hResource,
                                                      NvU32* phAllocation,
                                                      NvU32* pBlockOffset,
                                                      NvU32* pLength,
                                                      sdResourceAttributes** ppResourceAttributes);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_BuildDebugShaderInstance
//
//   DESCRIPTION: Note: call NvAPI_D3D10_RegisterDevice once before using with this function!!!
//                This function creates and builds a debug instance of a shader.
//                If the shader already has a debug instance then it returns
//                immediately with the instructions unless the rebuild param is true.
//
//         INPUT:  pDev                        The device to which the shader belongs to
//                 hShader                     Handle to the internal shader data struction of the UMD
//                 rebuild                     If true then rebuild the debug instance if it already exists
//                 pD3dByteCode                D3d byte code to use for creating the debug instance. If NULL then the default D3D byte of the shader is used
//                 d3dByteCodeSize             Size of pD3dByteCode
//                 patchUCodeSize              Describes how many extra bytes need to be allocated for the ucode of the debug shader instance
//                 additionalThreadLMemBytes   Specifies how many extra bytes of per thread local memory need to be reserved for debugging
//                 additionalThreadStackBytes  Specifies how many extra bytes of stack memory need to be reserved for debugging
//
//  SUPPORTED OS: Windows Vista and higher
//
//        OUTPUT:  ppInstructions               Pointer to the SASS instructions of the shader.
//                                              This argument is valid even if the rebuild param is false.
//                 pInstructionsSize            The byte size of the instruction buffer
//                 ppDebugSymbols               Shader debug info
//                 pDebugThreadLMemBaseAddress  The offset in per thread local mem to the start of the additionaly reserved space
//
// RETURN STATUS: NVAPI_OK if hShader is valid and the OUT pointers are non-null
//
///////////////////////////////////////////////////////////////////////////////

// These structures are copied from ShaderDebugger.h. Copied here for reference.
// Forward declaring the required ones below the comments.
// enum sdRegisterClass
// {
//     SDC_CC    = 0,
//     SDC_ADDR  = 1,
//     SDC_HALF  = 2,
//     SDC_FULL  = 3,
// };
// 
// enum sdRegisterType
// {
//     SDT_NULL            = 0, // default
//     SDT_RESULT          = 1, // o0
//     SDT_TEMP            = 2, // r0
//     SDT_INDEXABLE_TEMP  = 3, // x0
//     SDT_CC              = 4, // co
// };
// 
// // Structures to return Debug Shader Symbol info to Shader-Debugger
// struct ShaderDebugLineTableEntry
// {
//     NvU16 fileNo;           // this would be zero for nvInst path 
//     NvU32 lineNo;           // line number in the passed in bytecode
//     NvU32 uCodeOffset;
// 
//     ShaderDebugLineTableEntry *next;
// };
// struct ShaderDebugLineTable
// {
//     NvU32* pSdMicrocode;    // pointer to NVUC_SECTION_UCODE
//     NvU32  sdMicrocodeSize;
//     ShaderDebugLineTableEntry* pLineTableEntries;
// };
// 
// struct ShaderDebugRegMapEntry
// {
//     NvU32 resultReg;        // input result register
//     NvU32 regBaseOffset;    // register base in indexableRanges & relative index offset
//     NvU32 location;         // encoded hw location 8bit type (see below enum for description), 24 value
//     NvU32 startUcodeOff;    // starting offset
//     NvU32 endUcodeOff;      // ending offset
// 
//     ShaderDebugRegMapEntry *next;
// };
// struct ShaderDebugRegMap
// {
//     ShaderDebugRegMapEntry* pRegMapEntries;
// };
//  
// struct ShaderDebugSymbols
// {
//     ShaderDebugRegMap*      pRegMap;
//     ShaderDebugLineTable*   pLineTable;
//     NvU8                    regToHWIOMapping[SD_ATTR_TYPE_COUNT][SD_MAX_D3D_IO_SCALARS];
// };
//
// enum {
//     DEBUG_LOC_INVALID,
//     DEBUG_LOC_REG_CC,
//     DEBUG_LOC_REG_PRED,
//     DEBUG_LOC_REG_ADDR,
//     DEBUG_LOC_REG_HALF,
//     DEBUG_LOC_REG_FULL,
//     DEBUG_LOC_MEM_LOCAL,
// };

// resultReg(32bit) layout:
//     component      : bits 0..3    // x=0, y=1, z=2, w=3
//     register class : bits 4..6    // cc=0, addr=1, half=2, full=3, higher numbers reserved for future
//     register number: bits 7...23  // reg number
//     register type  : bits 24...31 // SDT_NULL=0, SDT_RESULT= 1... see sdRegisterType
//
// regBaseOffset(32bit) layout:
//     register base   : bits 0..15    // base address obtained from indexableArrays. eg. baseAddr for x0 in x0[r0.y+ offset]
//     register offset : bits 16...31  // AddressRegister offset eg. x0[r0.y + offset]

struct ShaderDebugSymbols;

NVAPI_INTERFACE NvAPI_D3D10_BuildDebugShaderInstance(ID3D10Device *pDev,
                                                     NVDX_ObjectHandle hShader,
                                                     bool rebuild,
                                                     NvU32* pD3dByteCode,
                                                     NvU32 d3dByteCodeSize,
                                                     NvU32 patchUCodeSize,
                                                     NvU32 additionalThreadLMemBytes,
                                                     NvU32 additionalThreadStackBytes,
                                                     NvU32 **ppInstructions,
                                                     NvU32 *pInstructionsSize,
                                                     ShaderDebugSymbols** ppDebugSymbols,
                                                     NvU32* pDebugThreadLMemBaseAddress);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_SetShaderDebugMode
//
//   DESCRIPTION:  Note: call NvAPI_D3D10_RegisterDevice once before using with this function!!!
//                 This function set a shader to debug or release mode
//
//         INPUT:  pDev         The device to which the shader belongs to
//                 hShader      Handle to the internal shader data struction of the UMD
//                 debugMode    If true then set the shader to debug mode
//
//  SUPPORTED OS: Windows Vista and higher
//
// RETURN STATUS: NVAPI_OK if pD3D10PixelShader is valid and the OUT pointers are non-null
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_SetShaderDebugMode(ID3D10Device *pDev,
                                               NVDX_ObjectHandle hShader,
                                               bool debugMode);

///////////////////////////////////////////////////////////////////////////////
//
// NOTE: Deprecated!!!!!
//
// FUNCTION TYPE: NvAPI_D3D10_SetDebugShaderRelocationCallback
//
//   DESCRIPTION: Note: call NvAPI_D3D10_RegisterDevice once before using with this function!!!
//                This is a simple callback function to notify the user that the residency state
//                of a given shader has changed.  Used in conjuction with
//                NvAPI_D3D10_GetShaderUCodeAllocationInfo, the user can determine whether or
//                not the shader memory can be mapped.
//
// PARAMETERS:    IN NVAPI_DEBUGSHADER_RELOCATION_CALLBACK Callback - Pointer to function to call
//                                                                    on new events, or NULL if disabling
//                                                                    the callback.
//                IN void* CallbackParam                            - void* Parameter to be passed
//                                                                    to the callback function
//
///////////////////////////////////////////////////////////////////////////////
typedef HRESULT (__cdecl *NVAPI_DEBUGSHADER_RELOCATION_CALLBACK) (void* pShader, void* pParam);

//  SUPPORTED OS: Windows Vista and higher
NVAPI_INTERFACE NvAPI_D3D10_SetDebugShaderRelocationCallback(ID3D10Device *pDev,
                                                             NVAPI_DEBUGSHADER_RELOCATION_CALLBACK shaderRelocationCallback,
                                                             void* pParam);

///////////////////////////////////////////////////////////////////////////////
// Forward declare the Shader Debugger callback structures
///////////////////////////////////////////////////////////////////////////////
typedef HRESULT (__cdecl *SHADERDEBUGGER_CALLBACK) (void* pCallbackData, void* pParam);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION TYPE: NvAPI_D3D10_SetShaderDebuggerCallback
//
//   DESCRIPTION: This function is used to register callbacks for various debug
//                events.
//
//         INPUT:  pDev              The device on which the callback is valid.
//                 cbType            The SHADERDEBUGGER_CALLBACK_TYPE.
//                 pCallbackFunction Pointer to the callback function.
//                 pParam            Application data that will be passed back to this callback.
//
//
// RETURN STATUS: NVAPI_OK if the callback was successfully set.
//
//          NOTE: An application may change it's callback functions at any time, and may
//                unregister from any function by passing NULL in as a function pointer.
//
///////////////////////////////////////////////////////////////////////////////

//  SUPPORTED OS: Windows Vista and higher
NVAPI_INTERFACE NvAPI_D3D10_SetShaderDebuggerCallback(ID3D10Device *pDev,
                                                      NvU32 cbType,
                                                      SHADERDEBUGGER_CALLBACK pCallbackFunction,
                                                      void* pParam);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D1x_MoveShaderCacheBetweenVidAndSys
//
//   DESCRIPTION:  Note: call NvAPI_D3D10_RegisterDevice once before using with this function!!!
//                 This function will be used mainly by ShaderDebugger and will move shader cache 
//                 from Video memory to System memory or the other way round. When the app starts up,
//                 we usually store shader cache in Video memory. To facilitate shader debugger (to 
//                 set breakpoints + replace shaders at a breakpoint), we need this cache in system memory.
//                 Usual way of running things: When the user sets his first breakpoint in the shader, we
//                 get this call to move shader cache from VID to SYS. From then on, the driver maintains 
//                 the cache in SYS memory. Once the user removes his last breakpoint, we will get this call
//                 to move cache from SYS to VID memory & continue normal operations after that.
//                 SHADER_TYPE_FLAGS below, allow us to move a single shaderType cache or multiple caches at 
//                 the same time.
//                 Note: Compute Shader Manager is created, only when we have a compute channel. Hence this call would
//                       return NVAPI_INVALID_ARGUMENT, If you use this call to move compute shader cache, without 
//                       a compute channel.
//
//         INPUT:  pDev            The device for which we need to move shader cache. pDev can be either 
//                                 ID3D10Device or ID3D10Device1 or ID3D11Device ptr
//                 cacheLocation   Specifies location to move ShaderCache (STORAGE_VID/STORAGE_SYS). 
//                                 Check SHADER_HEAP_STORAGE for valid values. Don't use STORAGE_COUNT.
//                 shaderTypeFlags Specifies what all shader caches need to be moved.
//                                 Check SHADER_TYPE_FLAGS for valid values. You can use multiple of these, depending
//                                 on the types of ShaderCaches you want to move.
//
//  SUPPORTED OS: Windows Vista and higher
//
// RETURN STATUS: This will be a synchronous call i.e. would be executed immediately. Hence will return NVAPI_OK if the call was successfull.
//                This call will return NVAPI_OK, without doing anything, if shaderCache already exists in the requested location
//
///////////////////////////////////////////////////////////////////////////////
// These enums are copied from the driver. Copied here for reference.
// enum SHADER_HEAP_STORAGE
// {
//     STORAGE_VID = 0,
//     STORAGE_SYS = 1,
//     STORAGE_COUNT = 2
// };
// enum SHADER_TYPE_FLAGS {
//     SHADER_TYPE_VERTEX   = 0x00000001,
//     SHADER_TYPE_GEOMETRY = 0x00000002,
//     SHADER_TYPE_PIXEL    = 0x00000004,
//     SHADER_TYPE_COMPUTE  = 0x00000008,
//     SHADER_TYPE_ALL      = 0x0000000f,
// };

NVAPI_INTERFACE NvAPI_D3D1x_MoveShaderCacheBetweenVidAndSys(IUnknown *pDev,
                                                            NvU32 cacheLocation,
                                                            NvU32 shaderTypeFlags);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_LockCb
//
//   DESCRIPTION: This function is an accessor for the UMD's surface locking function.
//
//         INPUT:  pDev         The device on which the resource was created
//                 hMemory      The memory handle to use.
//
//  SUPPORTED OS: Windows Vista and higher
//
//        OUTPUT:  ppBuffer     The mapped buffer.
//
// RETURN STATUS: NVAPI_OK if the buffer is non_null, and the lock succeeds.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_LockCb(ID3D10Device *pDev,
                                   NvU32 hMemory,
                                   NvU32** ppBuffer);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_UnlockCb
//
//   DESCRIPTION: This function is an accessor for the UMD's surface unlocking function.
//
//         INPUT:  pDev         The device on which the resource was created
//                 hMemory      The memory handle to use.
//
//  SUPPORTED OS: Windows Vista and higher
//
// RETURN STATUS: NVAPI_OK if the buffer is non_null, and the lock succeeds.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_UnlockCb(ID3D10Device *pDev,
                                     NvU32 hMemory);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_GetRmHandles
//
//   DESCRIPTION:  Note: call NvAPI_D3D10_RegisterDevice once before using with this function!!!
//                 This function retrieves the RM handle for the device
//
//         INPUT:  pDev         The device whose handle we want
//
//        OUTPUT:  phClient     The device's RM client
//                 phDevice     The device's RM device
//                 phSubDevices The device's RM subdevices.  
//                              MC_MAX_SUBDEVICES array elements required.
//
//  SUPPORTED OS: Windows Vista and higher
//
// RETURN STATUS: NVAPI_OK if and only if phClient and phDevice were populated 
//                with valid RM handles
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_GetRmHandles(ID3D10Device *pDev,
                                         NvU32* phClient,
                                         NvU32* phDevice,
                                         NvU32* phSubDevices);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_GetAllocDebugInfo
//
//   DESCRIPTION: Note: call NvAPI_D3D10_RegisterDevice once before using with this function!!!
//                Internal function used by shader debugger, used for getting
//                addressing info about resident shaders
//
//         INPUT:  pDev                    D3D handle of client
//                 hKmtAlloc               KMT allocation object handle
//                 hAllocType              1 for resource, 2 for primary surface
//                 hAllocIsDeviceSpecific  Flag for allocation
//
//        OUTPUT:  phClient                Matching RM client
//                 phDevice                Matching RM device
//                 pAllocPAddr             Allocation offset from FB
//                 pAllocSize              Size of allocation
//
//  SUPPORTED OS: Windows Vista and higher
//
// RETURN STATUS: NVAPI_OK if and only if the hKmtAlloc was known by the KMD 
//
///////////////////////////////////////////////////////////////////////////////                                         
NVAPI_INTERFACE NvAPI_D3D10_GetAllocDebugInfo(ID3D10Device *pDev, 
                                              NvU32 hKmtAlloc,
                                              NvU32 hAllocType,
                                              NvU32 hAllocIsDeviceSpecific,
                                              NvU32* phClient,
                                              NvU32* phDevice,
                                              NvU64* pAllocPAddr,
                                              NvU32* pAllocSize);
                                              
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_GetPixelShaderInstructions
//
//   DESCRIPTION: This function retrieves the SASS instructions of a DX10 pixel shader
//
//         INPUT:  pDev         The device on which the resource was created
//                 pShader      The pixel shader for which we want to retrieve the
//                              instructions
//
//  SUPPORTED OS: Windows Vista and higher
//
//        OUTPUT:  ppInstructions    Pointer to the SASS instructions of the shader
//                 pBufferSize        The byte size of the instruction buffer
//
// RETURN STATUS: NVAPI_OK if and only if pInstructions was populated with a valid
//                set of instruction
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_GetPixelShaderInstructions(ID3D10Device *pDev,
                                              ID3D10PixelShader* pShader,
                                              NvU32** ppInstructions,
                                              NvU32* pBufferSize);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_SetPixelShaderInstructions
//
//   DESCRIPTION: This function sets the SASS instructions of a DX10 pixel shader
//
//         INPUT:  pDev         The device on which the resource was created
//                 pShader      The pixel shader for which we want to set the
//                              instructions
//
//  SUPPORTED OS: Windows Vista and higher
//
//        OUTPUT:  pInstructions     Pointer to the SASS instructions of the shader
//                 bufferSize        The byte size of the instruction buffer
//
// RETURN STATUS: NVAPI_OK if and only if pInstructions was populated with a valid
//                set of instruction
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_SetPixelShaderInstructions(ID3D10Device *pDev,
                                              ID3D10PixelShader* pShader,
                                              NvU32* pInstructions,
                                              NvU32 bufferSize);

#ifdef __d3d10_1_h__

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_CreateDevice
//
//   DESCRIPTION: This function creates a d3d10 device. The function call is the
//                same as D3D10CreateDevice1, but with an extra argument
//                (D3D10_FEATURE_LEVEL supported by the device) that the function fills in.
//
//  SUPPORTED OS: Windows XP and higher
//
//         INPUT:  IDXGIAdapter* pAdapter,
//                 D3D10_DRIVER_TYPE DriverType,
//                 HMODULE Software,
//                 UINT32 Flags,
//                 D3D10_FEATURE_LEVEL1 HardwareLevel,
//                 UINT SDKVersion,
//                 ID3D10Device1** ppDevice,
//                 NVAPI_DEVICE_FEATURE_LEVEL *pLevel  //D3D10_FEATURE_LEVEL supported
//
// RETURN STATUS: NVAPI_OK if the createDevice call succeeded.
//
///////////////////////////////////////////////////////////////////////////////
typedef enum
{
    NVAPI_DEVICE_FEATURE_LEVEL_NULL       = -1,
    NVAPI_DEVICE_FEATURE_LEVEL_10_0       = 0,
    NVAPI_DEVICE_FEATURE_LEVEL_10_0_PLUS  = 1,
    NVAPI_DEVICE_FEATURE_LEVEL_10_1       = 2,
    NVAPI_DEVICE_FEATURE_LEVEL_11_0       = 3,
} NVAPI_DEVICE_FEATURE_LEVEL;

NVAPI_INTERFACE NvAPI_D3D10_CreateDevice(IDXGIAdapter* pAdapter,
                                         D3D10_DRIVER_TYPE DriverType,
                                         HMODULE Software,
                                         UINT32 Flags,
                                         D3D10_FEATURE_LEVEL1 HardwareLevel,
                                         UINT SDKVersion,
                                         ID3D10Device1** ppDevice,
                                         NVAPI_DEVICE_FEATURE_LEVEL *pLevel);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_CreateDeviceAndSwapChain
//
//   DESCRIPTION: This function creates a d3d10 device and swap chain. The function call is the
//                same as D3D10CreateDeviceAndSwapChain1, but with an extra argument
//                (D3D10_FEATURE_LEVEL supported by the device) that the function fills in .
//
//  SUPPORTED OS: Windows XP and higher
//
//         INPUT:  IDXGIAdapter* pAdapter,
//                 D3D10_DRIVER_TYPE DriverType,
//                 HMODULE Software,
//                 UINT32 Flags,
//                 D3D10_FEATURE_LEVEL1 HardwareLevel,
//                 UINT SDKVersion,
//                 DXGI_SWAP_CHAIN_DESC* pSwapChainDesc,
//                 IDXGISwapChain** ppSwapChain,
//                 ID3D10Device1** ppDevice,
//                 NVAPI_DEVICE_FEATURE_LEVEL *pLevel  //D3D10_FEATURE_LEVEL supported
//
// RETURN STATUS: NVAPI_OK if the createDevice with swap chain call succeeded.
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_D3D10_CreateDeviceAndSwapChain(IDXGIAdapter* pAdapter,
                                                     D3D10_DRIVER_TYPE DriverType,
                                                     HMODULE Software,
                                                     UINT32 Flags,
                                                     D3D10_FEATURE_LEVEL1 HardwareLevel,
                                                     UINT SDKVersion,
                                                     DXGI_SWAP_CHAIN_DESC* pSwapChainDesc,
                                                     IDXGISwapChain** ppSwapChain,
                                                     ID3D10Device1** ppDevice,
                                                     NVAPI_DEVICE_FEATURE_LEVEL *pLevel);

#endif //defined(__d3d10_1_h__)

//-----------------------------------------------------------------------------
// Private Direct3D10 APIs
//-----------------------------------------------------------------------------

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_GetBufferStreamOutBytesWritten
//
//   DESCRIPTION: Gets the number of bytes written during stream out for the
//                specified buffer.
//
//  SUPPORTED OS: Windows Vista and higher
//
//         INPUT:  ID3D10Device*
//                 ID3D10Buffer*
//                 NvU32*
//
// RETURN STATUS: NVAPI_OK if the operation succeeded
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_D3D10_GetBufferStreamOutBytesWritten(ID3D10Device* pDev, ID3D10Buffer* pBuffer, NvU32* pCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_SetBufferStreamOutBytesWritten
//
//   DESCRIPTION: Sets the number of bytes written during stream out for the
//                specified buffer.
//
//  SUPPORTED OS: Windows Vista and higher
//
//         INPUT:  ID3D10Device*
//                 ID3D10Buffer*
//                 NvU32
//
// RETURN STATUS: NVAPI_OK if the operation succeeded
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_D3D10_SetBufferStreamOutBytesWritten(ID3D10Device* pDev, ID3D10Buffer* pBuffer, NvU32 Count);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_CreateDevice_McCompat
//
//   DESCRIPTION: This function creates a d3d10 device. The function call is the
//                same as D3D10CreateDevice1, but 3 extra arguments:
//                (D3D10_FEATURE_LEVEL supported by the device), mccompat bits to
//                control SLI optimizations and mccompatHybrid bits to control
//                Hybrid SLI.  The bits are the same ones exported by d3dreg.
//
//  SUPPORTED OS: Windows Vista and higher
//
//         INPUT:  IDXGIAdapter* pAdapter,
//                 D3D10_DRIVER_TYPE DriverType,
//                 HMODULE Software,
//                 UINT32 Flags,
//                 D3D10_FEATURE_LEVEL1 HardwareLevel,
//                 UINT SDKVersion,
//                 ID3D10Device1** ppDevice,
//                 NVAPI_DEVICE_FEATURE_LEVEL *pLevel,  // D3D10_FEATURE_LEVEL supported
//                 UINT32 mccompat,                     // SLI mccompat bits, default to 0
//                 UINT32 mccompatHybrid,               // Hybrid SLI mccompat bits, default to 0
//
// RETURN STATUS: NVAPI_OK if the createDevice call succeeded.
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_D3D10_CreateDevice_McCompat(  IDXGIAdapter* pAdapter,
                                                    D3D10_DRIVER_TYPE DriverType,
                                                    HMODULE Software,
                                                    UINT32 Flags,
                                                    D3D10_FEATURE_LEVEL1 HardwareLevel,
                                                    UINT SDKVersion,
                                                    ID3D10Device1** ppDevice,
                                                    NVAPI_DEVICE_FEATURE_LEVEL *pLevel,
                                                    UINT32 mccompat,
                                                    UINT32 mccompatHybrid);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_RegisterDevice
//
//   DESCRIPTION: Register device with NvAPI before using it in specified funtions  This allows for
//                more efficient high-frequency nvapi calls, as setting up the device for NvAPI use
//                is an expensive operation.  When finished with the handle, clients should call 
//                NvAPI_D3D10_ReleaseDeviceHandle.
//
//  SUPPORTED OS: Windows Vista and higher
//
//         INPUT:  ID3D10Device* pDev
//
// RETURN STATUS: NVAPI_OK if the call succeeded.
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_D3D10_RegisterDevice(ID3D10Device *pDev);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_UnregisterDevice
//
//   DESCRIPTION: Unregister a device after NvAPI_D3D10_RegisterDevice
//                
//  SUPPORTED OS: Windows Vista and higher
//
//         INPUT: ID3D10Device* pDev
//
// RETURN STATUS: NVAPI_OK if the call succeeded.
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_D3D10_UnregisterDevice(ID3D10Device* pDev);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_SetPrivateConstData
//
//   DESCRIPTION: Note: Call NvAPI_D3D10_RegisterDevice on the device before using it
//                in this function!!!
//                Sets data in the private UMD constant buffer.
//                Slots are defined by the NvAPIPrivateConstDataSlot enumeration.
//                Consumers of this constant buffer data must take care to call
//                NvAPI_D3D10_GetPrivateConstDataSlotAndOffset for the same instance
//                of the shader which will consume the data.  Producers of this data
//                should call NvAPI_D3D10_SetPrivateConstData any time before drawing.
//
//  SUPPORTED OS: Windows Vista and higher
//
//         INPUT:  ID3D10Device* pDev,
//                 NvAPIPrivateConstDataSlot dataslot,
//                 NvU32 data
//
// RETURN STATUS: NVAPI_OK if the call succeeded.
//
///////////////////////////////////////////////////////////////////////////////

typedef enum
{
    PCD_NEXUS_FRAME_AND_DC_INDEX,  // [31:24] FrameID [23:0] DrawCallID
    PCD_NEXUS_DC_EXTRA_INFO,
    
    PCD_COUNT
} NvAPIPrivateConstDataSlot;

NVAPI_INTERFACE NvAPI_D3D10_SetPrivateConstData(ID3D10Device* pDev, NvAPIPrivateConstDataSlot dataslot, NvU32 data);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_GetPrivateConstDataSlotAndOffset
//
//   DESCRIPTION: Note: Call NvAPI_D3D10_RegisterDevice on the device before using it
//                in this function!!!
//                This function retrieves the constant slot and offset corresponding
//                to the private UMD constant buffer for the specified shader.  See
//                comments for NvAPI_D3D10_SetPrivateConstData.  hShader should be
//                acquired using one of the NvAPI_D3D10_GetXXXShaderHandle functions.
//
//  SUPPORTED OS: Windows Vista and higher
//
//         INPUT:  ID3D10Device* pDev,
//                 NVDX_ObjectHandle* hShader,
//                 NvAPIPrivateConstDataSlot dataslot,
//
//         OUTPUT: NvU32 *pOutConstSlot, 
//                 NvU32 *pOutScalarOffset
//
// RETURN STATUS: NVAPI_OK if the call succeeded.
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_D3D10_GetPrivateConstDataSlotAndOffset(ID3D10Device* pDev, NVDX_ObjectHandle* phShader, NvAPIPrivateConstDataSlot dataslot, NvU32 *pOutConstSlot, NvU32 *pOutScalarOffset);


#endif // defined(__cplusplus) && defined(__d3d10_h__)

//-----------------------------------------------------------------------------
// Direct3D11 APIs
//-----------------------------------------------------------------------------


#if defined(__cplusplus) && defined(__d3d11_h__)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_CreateDevice
//
//   DESCRIPTION: This function tries to create a d3d11 device. If the call fails (if we are running
//                on pre DX11 HW), depending on the type of HW, it will try to create a DX10.1 OR DX10.0+
//                OR DX10.0 device. The function call is the same as D3D11CreateDevice, but with an extra 
//                argument (D3D_FEATURE_LEVEL supported by the device) that the function fills in. This argument
//                can contain -1 (NVAPI_DEVICE_FEATURE_LEVEL_NULL), if the requested featureLevel is less than dx10.0
//
//  SUPPORTED OS: Windows XP and higher
//
//         INPUT:  IDXGIAdapter* pAdapter,
//                 D3D_DRIVER_TYPE DriverType,
//                 HMODULE Software,
//                 UINT Flags,
//                 CONST D3D_FEATURE_LEVEL *pFeatureLevels,
//                 UINT FeatureLevels,
//                 UINT SDKVersion,
//                 ID3D11Device** ppDevice,
//                 D3D_FEATURE_LEVEL *pFeatureLevel,
//                 ID3D11DeviceContext **ppImmediateContext,
//                 NVAPI_DEVICE_FEATURE_LEVEL *pSupportedLevel  //D3D_FEATURE_LEVEL supported
//
// RETURN STATUS: NVAPI_OK if the createDevice call succeeded.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_CreateDevice(IDXGIAdapter* pAdapter,
                                         D3D_DRIVER_TYPE DriverType,
                                         HMODULE Software,
                                         UINT Flags,
                                         CONST D3D_FEATURE_LEVEL *pFeatureLevels,
                                         UINT FeatureLevels,
                                         UINT SDKVersion,
                                         ID3D11Device **ppDevice,
                                         D3D_FEATURE_LEVEL *pFeatureLevel,
                                         ID3D11DeviceContext **ppImmediateContext,
                                         NVAPI_DEVICE_FEATURE_LEVEL *pSupportedLevel);
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_CreateDeviceAndSwapChain
//
//   DESCRIPTION: This function tries to create a d3d11 device and swap chain. If the call fails (if we are 
//                running on pre DX11 HW), depending on the type of HW, it will try to create a DX10.1 OR 
//                DX10.0+ OR DX10.0 device. The function call is the same as D3D11CreateDeviceAndSwapChain,  
//                but with an extra argument (D3D_FEATURE_LEVEL supported by the device) that the function fills
//                in.  This argument can contain -1 (NVAPI_DEVICE_FEATURE_LEVEL_NULL), if the requested featureLevel
//                is less than dx10.0
//
//  SUPPORTED OS: Windows XP and higher
//
//         INPUT:  IDXGIAdapter* pAdapter,
//                 D3D_DRIVER_TYPE DriverType,
//                 HMODULE Software,
//                 UINT Flags,
//                 CONST D3D_FEATURE_LEVEL *pFeatureLevels,
//                 UINT FeatureLevels,
//                 UINT SDKVersion,
//                 CONST DXGI_SWAP_CHAIN_DESC *pSwapChainDesc,
//                 IDXGISwapChain **ppSwapChain,
//                 ID3D11Device** ppDevice,
//                 D3D_FEATURE_LEVEL *pFeatureLevel,
//                 ID3D11DeviceContext **ppImmediateContext,
//                 NVAPI_DEVICE_FEATURE_LEVEL *pSupportedLevel  //D3D_FEATURE_LEVEL supported
//
// RETURN STATUS: NVAPI_OK if the createDevice with swap chain call succeeded.
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_D3D11_CreateDeviceAndSwapChain(IDXGIAdapter* pAdapter,
                                         D3D_DRIVER_TYPE DriverType,
                                         HMODULE Software,
                                         UINT Flags,
                                         CONST D3D_FEATURE_LEVEL *pFeatureLevels,
                                         UINT FeatureLevels,
                                         UINT SDKVersion,
                                         CONST DXGI_SWAP_CHAIN_DESC *pSwapChainDesc,
                                         IDXGISwapChain **ppSwapChain,
                                         ID3D11Device **ppDevice,
                                         D3D_FEATURE_LEVEL *pFeatureLevel,
                                         ID3D11DeviceContext **ppImmediateContext,
                                         NVAPI_DEVICE_FEATURE_LEVEL *pSupportedLevel);

#endif //defined(__cplusplus) && defined(__d3d11_h__)

//-----------------------------------------------------------------------------
// Private Direct3D11 APIs
//-----------------------------------------------------------------------------

#if defined(__cplusplus) && defined(__d3d11_h__)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_GetBufferStreamOutBytesWritten
//
//   DESCRIPTION: Gets the number of bytes written during stream out for the
//                specified buffer.
//
//  SUPPORTED OS: Windows Vista and higher
//
//         INPUT:  ID3D11Device*
//                 ID3D11Buffer*
//                 NvU32*
//
// RETURN STATUS: NVAPI_OK if the operation succeeded
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_D3D11_GetBufferStreamOutBytesWritten(ID3D11Device* pDev, ID3D11Buffer* pBuffer, NvU32* pCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_SetBufferStreamOutBytesWritten
//
//   DESCRIPTION: Sets the number of bytes written during stream out for the
//                specified buffer.
//
//  SUPPORTED OS: Windows Vista and higher
//
//         INPUT:  ID3D11Device*
//                 ID3D11Buffer*
//                 NvU32
//
// RETURN STATUS: NVAPI_OK if the operation succeeded
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_D3D11_SetBufferStreamOutBytesWritten(ID3D11Device* pDev, ID3D11Buffer* pBuffer, NvU32 Count);

#endif // defined(__cplusplus) && defined(__d3d11_h__)


//-----------------------------------------------------------------------------
// Video Microcode Loading routines and data structures
//-----------------------------------------------------------------------------

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_LoadMicrocode
//
//   DESCRIPTION: Loads the microcode provided in the pMicrocodeInfo.
//
//  SUPPORTED OS: Windows XP
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////
typedef struct
{
    NvU32 version;          // structure version
    NvU32 ucID;             // microcode ID for VP2 its the subclass this microcode belongs to
    NvU32 ucVersion;        // version of the microcode -- depends upon the author
    char szMicrocodeDescription[40]; // short description of the microcode -- depends upon the author
    NvU32 ucCRC;            // CRC value for the uncompressed microcode data
    NvU32 unCompressedSize; // uncompressed size of the microcode
    NvU32 flags;            // 0x00000001 means compressesd
    NvU32 microcodeFormat;  // type of compression/layout for microcode
    NvU32 compSize;         // size of the compressed microcode
    union {                 // anonymous union
    NvU8 *pImg;             // ptr to microcode - USED only in the API call
    NvU64 pImgpad;          // pad up to 64 bit on 32 bit systems
    };
} NV_MICROCODE_INFO;
#define NV_MICROCODE_INFO_VER MAKE_NVAPI_VERSION(NV_MICROCODE_INFO,1)

typedef struct _NV_MICROCODE_REPOS_INDEX
{
    NvU32                version;        // structure version
    NV_MICROCODE_INFO    info;           // Note that the img data here is not valid
    NvU32                offset;         // THIS is not used by the API
    NvU32                loadedDataSize;
    NvS32                indexStatus;
    union {                              // anonymous union
    struct _NV_MICROCODE_REPOS_INDEX* pNext;
    NvU64 pImgpad;                       // pad up to 64 bit on 32 bit systems
    };
} NV_MICROCODE_REPOS_INDEX;
#define NV_MICROCODE_REPOS_INDEX_VER MAKE_NVAPI_VERSION(NV_MICROCODE_REPOS_INDEX,1)

NVAPI_INTERFACE NvAPI_LoadMicrocode(NvDisplayHandle hNvDisplay, NV_MICROCODE_INFO* pMicrocodeInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetLoadedMicrocodePrograms
//
//   DESCRIPTION: Queries the currently loaded microcode programs.
//
//  SUPPORTED OS: Windows XP
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
// NOTE: It is very important that the caller of the function carefully
//       clears/frees up the memory of the linkedlist pMicrocodeReposIndex
//
// Sample code for freeing linked list
//   while (pMicrocodeReposIndex!= NULL) {
//      current = pMicrocodeReposIndex->pNext;
//      delete pMicrocodeReposIndex;
//      pMicrocodeReposIndex = current;
//   }
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetLoadedMicrocodePrograms(NvDisplayHandle hNvDisplay, NV_MICROCODE_REPOS_INDEX** pMicrocodeReposIndex);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetDisplayDriverBuildTitle
//
//   DESCRIPTION: Retrieves a string describing the driver build (called it's title)
//                Corresponds in the driver build to the #define NV_DISPLAY_DRIVER_TITLE
//
//  SUPPORTED OS: Windows XP and higher
//
//   e.g. "Nightly nvr40 40021217 Chloe_Palenchar"
//         The first word is one of "Official" (for BM), "Nightly" (for BM),
//         "DVSvirtual", "DVSreal", "Private", describing the build source.
//         The second word will be the branch, minus "OEM/" if it exists eg: R40B4, nvr40, main
//         The third word will either be a version or a directory-ish name eg: 41.11, 35021216, NV021216
//         The fourth word is the author of the most recent changelist that
//         went into the build (or author of virtual submission), or "unknown".
//         There will always be at least 2 space characters in the string. 
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetDisplayDriverBuildTitle(NvDisplayHandle hNvDisplay, NvAPI_String szTitle);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetDisplayDriverCompileType
//
//   DESCRIPTION: Retrieves a value describing the compile type of the display driver
//
//  SUPPORTED OS: Windows XP and higher
//
//                NVDIAG_DRV_COMPILE_TYPE_xxx,
//                where xxx = DEBUG, DEVELOP, RELEASE, or UNKNOWN
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////

// TBD: define compile types here...

NVAPI_INTERFACE NvAPI_GetDisplayDriverCompileType(NvDisplayHandle hNvDisplay, NvU32 *pCompileType);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetDisplayDriverSecurityType
//
//   DESCRIPTION: Retrieves a value describing the display driver security level
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetDisplayDriverSecurityLevel(NvDisplayHandle hNvDisplay, NvU32 *pdrvSecurityLevel);


typedef enum
{
    // driver access type flags
    NVAPI_REG_READ_DWORD      , // read a dword registry value
    NVAPI_REG_WRITE_DWORD     , // write a dword registry value
    NVAPI_REG_READ_BINARY     , // read a binary registry value
    NVAPI_REG_WRITE_BINARY    , // write a binary registry value
    NVAPI_REG_DELETE_VALUE    , // deletes a specific value

} NVAPI_REG_ACCESS_TYPE;

#define NV_MAX_REGISTRY_KEY_NAME 1024
#define NV_MAX_REGISTRY_KEY_VALUE_SIZE 4094
typedef struct
{
    NvU32                      version;                              // structure version
    NVAPI_REG_ACCESS_TYPE      iAccessType;                          // read or write, DWORD or binary
    char                       pszKeyName[NV_MAX_REGISTRY_KEY_NAME]; // display driver registry key to read or write
    NvU32                      cbData;                               // size of data to read or write
    void                       *pvData;                              // data to read or write
} NV_REGISTRY_DATA;
#define NV_REGISTRY_DATA_VER  MAKE_NVAPI_VERSION(NV_REGISTRY_DATA,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_AccessDisplayDriverRegistry
//
//
//   DESCRIPTION: Allows DWORD or binary read/write access to the display driver registry.
//                The path to the registry is fixed to the display driver registry path for
//                the hNvDisplay.  Only that registry path will be used and is determined at runtime.
//
//  SUPPORTED OS: Windows XP and higher
//
//   PARAMETERS: hNvDisplay - handle to display you wish to read/write values for
//               pnvRegData - Parameter block for registry operation.  Only pass in the
//                            key name, not a path.
//
// RETURN STATUS: NVAPI_ERROR, NVAPI_OK, invalid device.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_AccessDisplayDriverRegistry(NvDisplayHandle hNvDisplay, NV_REGISTRY_DATA *pnvRegData);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetDisplayDriverRegistryPath
//
//   DESCRIPTION: Retrieves the display device registry path
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetDisplayDriverRegistryPath(NvDisplayHandle hNvDisplay, NvAPI_String szRegistryPath);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetUnAttachedDisplayDriverRegistryPath
//
//   DESCRIPTION: Retrieves the display device registry path for unattached display
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetUnAttachedDisplayDriverRegistryPath(NvUnAttachedDisplayHandle hNvUnAttachedDisp, NvAPI_String szRegistryPath);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetRawFuseData
//
//   DESCRIPTION: Retrieves the raw bytes of the fuse data per GPU.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pFuseData is NULL
//                NVAPI_OK: Fuse data was returned
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
#define NVAPI_MAX_RAW_FUSE_DATA_SIZE   64
typedef struct
{
    NvU32   version;        // structure version

    NvU8    fuseData[NVAPI_MAX_RAW_FUSE_DATA_SIZE];
    NvU32   fuseDataSize;
} NV_RAW_FUSE_DATA;

#define NV_RAW_FUSE_DATA_VER  MAKE_NVAPI_VERSION(NV_RAW_FUSE_DATA,1)
NVAPI_INTERFACE NvAPI_GPU_GetRawFuseData(NvPhysicalGpuHandle hPhysicalGpu,NV_RAW_FUSE_DATA *pFuseData);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetFoundry
//
//   DESCRIPTION: Retrieves the identity of the foundry that manufactured the GPU
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pFoundry is NULL
//                NVAPI_OK: Foundry ID was returned
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//                NVAPI_NOT_SUPPORTED: if the interface is not supported (eg: earlier than g80)
//
///////////////////////////////////////////////////////////////////////////////
typedef enum
{
    NVAPI_FOUNDRY_UNKNOWN      = 0,
    NVAPI_FOUNDRY_TSMC         = 1,
    NVAPI_FOUNDRY_UMC          = 2,
    NVAPI_FOUNDRY_IBM          = 3,
    NVAPI_FOUNDRY_SMIC         = 4,
    NVAPI_FOUNDRY_CHARTERED    = 5,
    NVAPI_FOUNDRY_TOSHIBA      = 6,
} NVAPI_FOUNDRY_ID;

NVAPI_INTERFACE NvAPI_GPU_GetFoundry(NvPhysicalGpuHandle hPhysicalGpu,NVAPI_FOUNDRY_ID *pFoundry);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetVPECount
//
//   DESCRIPTION: Retrieves the number of Vertex Processing Engines (VPEs) on the GPU
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pCount is NULL
//                NVAPI_OK: *pCount is set
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetVPECount(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetShaderPipeCount
//
//   DESCRIPTION: Retrieves the number of Shader Pipes on the GPU
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pCount is NULL
//                NVAPI_OK: *pCount is set
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetShaderPipeCount(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetShaderSubPipeCount
//
//   DESCRIPTION: Retrieves the number of Shader SubPipes on the GPU
//                On newer architectures, this corresponds to the number of SM units
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pCount is NULL
//                NVAPI_OK: *pCount is set
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetShaderSubPipeCount(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_RegisterOp
//
//   DESCRIPTION: Performs one or more read or write operations on GPU registers.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
//      !! This is an extremely sensitive API and CANNOT be exported outside of NVIDIA. !!
//      !! It is meant only for use by our internal developers for diagnostics.         !!
//
//   A series of operations on registers are described by an array of NV_GPU_REGISTER_OP structs.
//
//   For each operation, flags define read/write, global or GR Context, 32 or 64 bit;
//   A 32-bit offset into BAR0 defines the starting offset.
//   A 64-bit writeMask field defines which bits to preserve in the destination.
//   A 64-bit value field defines the data to write, or the bits that were read.
//   A returned status field reports the result of each register operation.
//
//   Notes:
//
//   This interface is only supported on G8x onward.
//
//   See nvidia/sdk/inc/ctrl/ctrl2080/ctrl2080gpu.h NV2080_CTRL_GPU_REG_OP for further
//   details on the underlying RM interface.
//
//   NVAPI_GPU_REG_OP_FLAG_TYPE_GLOBAL - The register is a global privileged register.
//      Write operations take effect immediately.
//   NVAPI_GPU_REG_OP_FLAG_TYPE_GR_CTX - The register is a graphics context register.
//      Read operations return the current value from the associated global register.
//      Write operations are applied to all existing graphics engine contexts.  Any
//      newly created graphics engine contexts will also be modified.
//
//   32bit read operations                         64bit read operations
//   ------------------------------------------    ---------------------------------------------
//   regValueLo = read(bar0 + offset)              regValueLo = read(bar0 + offset)
//   regValueHi = 0                                regValueHi = read(bar0 + offset + 4)
//
//   32bit write operations
//   ------------------------------------------------------
//   new = ((read(bar0 + offset) & ~writeMaskLo) | valueLo)
//   write(bar0 + offset, new)
//
//   64bit write operations
//   -------------------------------------------------------------
//   new_lo = ((read(bar0 + offset) & ~writeMaskLo) | valueLo)
//   new_hi = ((read(bar0 + offset + 4) &  ~writeMaskHi) | valueHi)
//   write(bar0 + offset    , new_lo)
//   write(bar0 + offset + 4, new_hi)
//
//   See nvapichk for example usage.
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pRegOps is NULL or opCount is illegal
//                NVAPI_NOT_SUPPORTED: if the interface is not supported (eg: earlier than g8x)
//                NVAPI_OK: data was returned
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
#define NVAPI_GPU_MAX_REGISTER_OP_COUNT 256

typedef enum
{
    NVAPI_GPU_REG_OP_FLAG_READ             = 0x00000001,
    NVAPI_GPU_REG_OP_FLAG_WRITE            = 0x00000002,
    NVAPI_GPU_REG_OP_FLAG_32BIT            = 0x00000004,
    NVAPI_GPU_REG_OP_FLAG_64BIT            = 0x00000008,
    NVAPI_GPU_REG_OP_FLAG_TYPE_GLOBAL      = 0x00000010,
    NVAPI_GPU_REG_OP_FLAG_TYPE_GR_CTX      = 0x00000020,
} NVAPI_GPU_REG_OP_FLAGS;

typedef enum
{
    NVAPI_GPU_REG_OP_STATUS_SUCCESS        = 0x00000000,
    NVAPI_GPU_REG_OP_STATUS_INVALID_OP     = 0x00000001,    // Operation is not valid
    NVAPI_GPU_REG_OP_STATUS_INVALID_TYPE   = 0x00000002,    // Type (global/Gr_ctx) is not valid
    NVAPI_GPU_REG_OP_STATUS_INVALID_OFFSET = 0x00000004,    // Offset is not valid
    NVAPI_GPU_REG_OP_STATUS_UNSUPPORTED_OP = 0x00000008,    // Operation is not supported at this offset
} NVAPI_GPU_REG_OP_STATUS;

typedef struct
{
    NvU16 flags;     // bit flags from NVAPI_GPU_REG_OP_FLAGS
    NvU16 status;    // status of this operation from NVAPI_GPU_REG_OP_STATUS
    NvU32 offset;    // Offset from BAR0
    NvU64 writeMask; // Bits set here indicate which bits of the value field to write to the target offset
    NvU64 value;     // register value to write (or result from read)
} NV_GPU_REGISTER_OP;

typedef struct
{
    NvU32              version;  // structure version [implicitly versions NV_GPU_REGISTER_OP as well]
    NvU32              opCount;
    NV_GPU_REGISTER_OP op[NVAPI_GPU_MAX_REGISTER_OP_COUNT];
} NV_GPU_REGISTER_OP_DATA;

#define NV_GPU_REGISTER_OP_DATA_VER  MAKE_NVAPI_VERSION(NV_GPU_REGISTER_OP_DATA,1)

NVAPI_INTERFACE NvAPI_GPU_RegisterOp(NvPhysicalGpuHandle hPhysicalGpu,NV_GPU_REGISTER_OP_DATA *pRegOps);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetPartitionCount
//
//   DESCRIPTION: Retrieves the number of frame buffer partitions on the GPU
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pCount is NULL
//                NVAPI_OK: *pCount is set
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPartitionCount(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetMemPartitionMask
//
//   DESCRIPTION: Retrieves a 32-bit mask showing which memory partitions are enabled.
//                NvAPI_GPU_GetPartitionCount() returns the count of enabled partitions.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pMask is NULL
//                NVAPI_OK: *pMask is set
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetMemPartitionMask(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pMask);

///////////////////////////////////////////////////////////////////////////////
//  This escape is meant FOR SWAK USE ONLY.  Please contact
//  sw-nvapi if you wish to use this interface.
//
// FUNCTION NAME: NvAPI_GPU_GetGPCMask
//
//   DESCRIPTION: Retrieves a 32-bit mask showing which GPCs (Graphics Processor Cluster)
//                are enabled.
//
//                Returns 0 on pre-Fermi architectures.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pMask is NULL
//                NVAPI_OK: *pMask is set
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//                NVAPI_NOT_SUPPORTED: API call is not supported on current architecture
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetGPCMask(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pMask);

///////////////////////////////////////////////////////////////////////////////
//  This escape is meant FOR SWAK USE ONLY.  Please contact
//  sw-nvapi if you wish to use this interface.
//
// FUNCTION NAME: NvAPI_GPU_GetTPCMaskOnGPC
//
//   DESCRIPTION: Retrieves a 32-bit mask showing which Fermi TPCs
//                (Texture Processor Cluster) are enabled on the GPC idenified by gpcId.
//
//                gpcId values start at 0 and correspond to the position of bits
//                returned by NvAPI_GPU_GetGPCMask().
//
//                Returns 0 on pre-Fermi architectures.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pMask is NULL
//                NVAPI_OK: *pMask is set
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//                NVAPI_NOT_SUPPORTED: API call is not supported on current architecture
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetTPCMaskOnGPC(NvPhysicalGpuHandle hPhysicalGpu,NvU32 gpcId,NvU32 *pMask);

///////////////////////////////////////////////////////////////////////////////
//  This escape is meant FOR SWAK USE ONLY.  Please contact
//  sw-nvapi if you wish to use this interface.
//
// FUNCTION NAME: NvAPI_GPU_GetZCULLMask
//
//   DESCRIPTION: Retrieves a 32-bit mask showing which ZCULL
//                are enabled on the GPC idenified by gpcId.
//
//                gpcId values start at 0 and correspond to the position of bits
//                returned by NvAPI_GPU_GetGPCMask().
//
//                Returns 0 on pre-Fermi architectures.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pMask is NULL
//                NVAPI_OK: *pMask is set
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//                NVAPI_NOT_SUPPORTED: API call is not supported on current architecture
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetZCULLMask(NvPhysicalGpuHandle hPhysicalGpu,NvU32 gpcId,NvU32 *pMask);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetTPCMask
//
//   DESCRIPTION: Retrieves a 32-bit mask showing which TPCs (Texture Processor Cluster)
//                are enabled.  Returns 0 on architectures that don't have TPCs
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pMask is NULL
//                NVAPI_OK: *pMask is set
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//                NVAPI_NOT_SUPPORTED: API call is not supported on current architecture
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetTPCMask(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pMask);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetSMMask
//
//   DESCRIPTION: Retrieves a 32-bit mask showing which SMs
//                (Streaming Multiprocessor) are enabled on the TPC idenified by tpcNdx.
//
//                tpcNdx values start at 0 and correspond to the position of bits
//                returned by NvAPI_GPU_GetTPCMask().  [mask bit = 2^tpcNdx]
//
//                Returns 0 on architectures that don't have SMs
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pMask is NULL, or tpcId does not match a TPC
//                NVAPI_OK: *pMask is set
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//                NVAPI_NOT_SUPPORTED: API call is not supported on current architecture
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetSMMask(NvPhysicalGpuHandle hPhysicalGpu,NvU32 tpcId,NvU32 *pMask);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetTotalTPCCount
//
//   DESCRIPTION: Retrieves the total number of enabled TPCs (Texture Processor Cluster)
//                Returns 0 on architectures that don't have TPCs
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pCount is NULL
//                NVAPI_OK: *pCount is set
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetTotalTPCCount(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetTotalSMCount
//
//   DESCRIPTION: Retrieves the total number of enabled SMs across all TPCs
//                Returns 0 on architectures that don't have SMs
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pCount is NULL
//                NVAPI_OK: *pCount is set
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//                NVAPI_NOT_SUPPORTED: API call is not supported on current architecture
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetTotalSMCount(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetTotalSPCount
//
//   DESCRIPTION: Retrieves the total number of enabled SPs across all SMs on all TPCs
//                Returns 0 on architectures that don't have SPs
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pCount is NULL
//                NVAPI_OK: *pCount is set
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//                NVAPI_NOT_SUPPORTED: API call is not supported on current architecture
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetTotalSPCount(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetDisplayChangeInhibitState
//
//   DESCRIPTION: Retrieves the number of partiions on the GPU
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pInhibitState is NULL
//                NVAPI_OK: *pInhibitState is set to one or more values in NV_GPU_DISPLAY_CHANGE_INHIBIT
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
typedef enum _NV_GPU_DISPLAY_CHANGE_INHIBIT
{
    NVAPI_GPU_DISPLAY_CHANGE_INHIBIT_SPAN             = 0x00000001,
    NVAPI_GPU_DISPLAY_CHANGE_INHIBIT_VIDEO            = 0x00000002,
    NVAPI_GPU_DISPLAY_CHANGE_INHIBIT_3D_FULLSCREEN    = 0x00000004,
    NVAPI_GPU_DISPLAY_CHANGE_INHIBIT_DOS_FULLSCREEN   = 0x00000008,
} NV_GPU_DISPLAY_CHANGE_INHIBIT;

NVAPI_INTERFACE NvAPI_GPU_GetDisplayChangeInhibitState(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pInhibitState);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetAllOutputs
//
//   DESCRIPTION: Returns set of all GPU-output identifiers as a bitmask.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hPhysicalGpu or pOutputsMask is NULL
//                NVAPI_OK: *pOutputsMask contains a set of GPU-output identifiers
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetAllOutputs(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pOutputsMask);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetInternalDisplays
//
//   DESCRIPTION: Returns set of internal Displays as a bitmask.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hPhysicalGpu or pOutputsMask is NULL
//                NVAPI_OK: *pInternalDisplaysMask contains a set of GPU-internal display identifiers
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetInternalDisplays(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pInternalDisplaysMask);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetConnectedOutputs
//
//   DESCRIPTION: Same as NvAPI_GPU_GetAllOutputs but returns only the set of GPU-output
//                identifiers that are connected to display devices.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hPhysicalGpu or pOutputsMask is NULL
//                NVAPI_OK: *pOutputsMask contains a set of GPU-output identifiers
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetConnectedOutputs(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pOutputsMask);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetConnectedSLIOutputs
//
//   DESCRIPTION: Same as NvAPI_GPU_GetConnectedOutputs but returns only the set of GPU-output
//                identifiers that can be selected in an SLI configuration. 
//                NOTE: This function matches NvAPI_GPU_GetConnectedOutputs
//                 - On systems which are not SLI capable.
//                 - If the queried GPU is not part of a valid SLI group.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hPhysicalGpu or pOutputsMask is NULL
//                NVAPI_OK: *pOutputsMask contains a set of GPU-output identifiers
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetConnectedSLIOutputs(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pOutputsMask);



#define NV_GPU_CONNECTED_FLAG_UNCACHED 0x0
#define NV_GPU_CONNECTED_FLAG_CACHED   0x1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetConnectedOutputsEx
//
//   DESCRIPTION: Same as NvAPI_GPU_GetConnectedOutputs except takes a flag to request cached
//                or uncached connected devices. Currently XP cached/uncached is the same, so
//                this is private.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hPhysicalGpu or pOutputsMask is NULL
//                NVAPI_OK: *pOutputsMask contains a set of GPU-output identifiers
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetConnectedOutputsEx(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pOutputsMask, NvU32 flag);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetConnectedOutputsWithLidState
//
//   DESCRIPTION: Similar to NvAPI_GPU_GetConnectedOutputs this API returns the connected display identifiers that are connected
//                as a output mask but unlike NvAPI_GPU_GetConnectedOutputs this API "always" reflects the Lid State in the output mask.
//                Thus if you expect the LID close state to be available in the connection mask use this API.
//                If LID is closed then this API will remove the LID panel from the connected display identifiers.
//                If LID is open then this API will reflect the LID panel in the connected display identifiers.
//                Note:This API should be used on laptop systems and on systems where LID state is required in the connection output mask.
//                     On desktop systems the returned identifiers will match NvAPI_GPU_GetConnectedOutputs.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hPhysicalGpu or pOutputsMask is NULL
//                NVAPI_OK: *pOutputsMask contains a set of GPU-output identifiers
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetConnectedOutputsWithLidState(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pOutputsMask);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetConnectedSLIOutputsWithLidState
//
//   DESCRIPTION: Same as NvAPI_GPU_GetConnectedOutputsWithLidState but returns only the set of GPU-output
//                identifiers that can be selected in an SLI configuration. With SLI disabled
//                this function matches NvAPI_GPU_GetConnectedOutputsWithLidState
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hPhysicalGpu or pOutputsMask is NULL
//                NVAPI_OK: *pOutputsMask contains a set of GPU-output identifiers
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetConnectedSLIOutputsWithLidState(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pOutputsMask);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetConnectedOutputsWithLidStateEx
//
//   DESCRIPTION: Similar to NvAPI_GPU_GetConnectedOutputsWithLidState except takes a flag to request
//                cached or uncached connection data.  Currently XP cached/uncached is the same, so
//                this is private.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hPhysicalGpu or pOutputsMask is NULL
//                NVAPI_OK: *pOutputsMask contains a set of GPU-output identifiers
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetConnectedOutputsWithLidStateEx(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pOutputsMask, NvU32 flag);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetConnectedSLIOutputsWithLidStateEx
//
//   DESCRIPTION: Same as NvAPI_GPU_GetConnectedOutputsWithLidStateEx but returns only the set of GPU-output
//                identifiers that can be selected in an SLI configuration. With SLI disabled
//                this function matches NvAPI_GPU_GetConnectedOutputsWithLidStateEx
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hPhysicalGpu or pOutputsMask is NULL
//                NVAPI_OK: *pOutputsMask contains a set of GPU-output identifiers
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetConnectedSLIOutputsWithLidStateEx(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pOutputsMask, NvU32 flag);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetSystemType
//
//   DESCRIPTION: Returns information to identify if the GPU type is for a laptop system or a desktop system.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hPhysicalGpu or pOutputsMask is NULL
//                NVAPI_OK: *pSystemType contains the GPU system type
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
typedef enum
{
    NV_SYSTEM_TYPE_UNKNOWN = 0,
    NV_SYSTEM_TYPE_LAPTOP  = 1,
    NV_SYSTEM_TYPE_DESKTOP = 2,

} NV_SYSTEM_TYPE;

NVAPI_INTERFACE NvAPI_GPU_GetSystemType(NvPhysicalGpuHandle hPhysicalGpu, NV_SYSTEM_TYPE *pSystemType);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetActiveOutputs
//
//   DESCRIPTION: Same as NvAPI_GPU_GetAllOutputs but returns only the set of GPU-output
//                identifiers that are actively driving display devices.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hPhysicalGpu or pOutputsMask is NULL
//                NVAPI_OK: *pOutputsMask contains a set of GPU-output identifiers
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetActiveOutputs(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pOutputsMask);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetEDID
//
//   DESCRIPTION: Returns the EDID data for the specified GPU handle and connection bit mask.
//                displayOutputId should have exactly 1 bit set to indicate a single display.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pEDID is NULL; displayOutputId has 0 or > 1 bits set.
//                NVAPI_OK: *pEDID contains valid data.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found.
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle.
//                NVAPI_DATA_NOT_FOUND: requested display does not contain an EDID
//
///////////////////////////////////////////////////////////////////////////////
#define NV_EDID_V1_DATA_SIZE   256
#define NV_EDID_DATA_SIZE      NV_EDID_V1_DATA_SIZE

typedef struct
{
    NvU32   version;        //structure version
    NvU8    EDID_Data[NV_EDID_DATA_SIZE];
    NvU32   sizeofEDID;
} NV_EDID;

#define NV_EDID_VER         MAKE_NVAPI_VERSION(NV_EDID,2)

NVAPI_INTERFACE NvAPI_GPU_GetEDID(NvPhysicalGpuHandle hPhysicalGpu, NvU32 displayOutputId, NV_EDID *pEDID);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_SetEDID
//
//   DESCRIPTION: Sets the EDID data for the specified GPU handle and connection bit mask.
//                displayOutputId should have exactly 1 bit set to indicate a single display.
//                Note:The EDID will be cached for the current boot session and will be enumerated to the OS in this call.
//                     To remove the EDID set the sizeofEDID to zero.
//                     OS and NVAPI connection status APIs will reflect the newly set or removed EDID dynamically.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pEDID is NULL; displayOutputId has 0 or > 1 bits set
//                NVAPI_OK: *pEDID data was applied to the requested displayOutputId.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found.
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetEDID(NvPhysicalGpuHandle hPhysicalGpu, NvU32 displayOutputId, NV_EDID *pEDID);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetTargetID
//
//   DESCRIPTION: Returns the target ID for the specified GPU handle and connection bit mask.
//                displayOutputId should have exactly 1 bit set to indicate a single display.
//
//  SUPPORTED OS: Windows Vista and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pTargetId is NULL; displayOutputId has 0 or > 1 bits set.
//                NVAPI_OK: *pTargetId contains valid data.
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle.
//                NVAPI_NO_IMPLEMENTATION - only implemented for Win7+
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetTargetID(NvPhysicalGpuHandle hPhysicalGpu, NvU32 displayOutputId, NvU32 *pTargetId);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetOutputType
//
//   DESCRIPTION: Give a physical GPU handle and a single outputId (exactly 1 bit set), this API
//                returns the output type.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hPhysicalGpu, outputId or pOutputsMask is NULL; or outputId has > 1 bit set
//                NVAPI_OK: *pOutputType contains a NvGpuOutputType value
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
typedef enum _NV_GPU_OUTPUT_TYPE
{
    NVAPI_GPU_OUTPUT_UNKNOWN  = 0,
    NVAPI_GPU_OUTPUT_CRT      = 1,     // CRT display device
    NVAPI_GPU_OUTPUT_DFP      = 2,     // Digital Flat Panel display device
    NVAPI_GPU_OUTPUT_TV       = 3,     // TV display device
} NV_GPU_OUTPUT_TYPE;

NVAPI_INTERFACE NvAPI_GPU_GetOutputType(NvPhysicalGpuHandle hPhysicalGpu, NvU32 outputId, NV_GPU_OUTPUT_TYPE *pOutputType);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetDeviceDisplayMode
//
//   DESCRIPTION: Give a physical GPU handle and a single active displayId (exactly 1 bit set), this API
//                returns the device display mode according to hardware (including raster extension). This
//                includes the backend timing info.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hPhysicalGpu, displayId or pOutputsMask is NULL; displayId has > 1 bit set;
//                                        displayId is not an active display.
//                NVAPI_OK: *pDeviceDisplayMode contains the returned display mode information.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
typedef struct
{
    NvU32 version;          // structure version
    NvU32 activeWidth;      // Number of active horizontal pixels
    NvU32 activeHeight;     // Number of active vertical pixels
    NvU32 totalWidth;        // Total size of raster width (including blanking)
    NvU32 totalHeight;      // Total size of raster height (including blanking)
    NvU32 depth;            // Color depth
    NvU32 frequency;        // Calculated refresh rate based upon current raster and pixel clock
} NV_GPU_DISPLAY_MODE;

#define NV_GPU_DISPLAY_MODE_VER  MAKE_NVAPI_VERSION(NV_GPU_DISPLAY_MODE,1)

NVAPI_INTERFACE NvAPI_GPU_GetDeviceDisplayMode(NvPhysicalGpuHandle hPhysicalGpu, NvU32 displayId, NV_GPU_DISPLAY_MODE *pDeviceDisplayMode);

//DISPLAYPORT is all private for now. Do not change category until that info is public.
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetFlatPanelInfo
//
//   DESCRIPTION: Given a physical GPU handle and a single display outputId of the flat panel, this API
//                returns the flat panel attributes.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hPhysicalGpu, outputId or pFlatPanelInfo is NULL; or outputId has > 1 bit set.
//                NVAPI_OK: *pFlatPanelInfo contains the returned flat panel information.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found.
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle.
//                NVAPI_EXPECTED_DIGITAL_FLAT_PANEL: outputId is not associated with digital flat panel.
//
///////////////////////////////////////////////////////////////////////////////

typedef enum _NV_GPU_FLATPANEL_SIGNAL_TYPE
{
  NV_GPU_FLATPANEL_SIGNAL_TYPE_TMDS         = 0,
  NV_GPU_FLATPANEL_SIGNAL_TYPE_LVDS         = 1,
  NV_GPU_FLATPANEL_SIGNAL_TYPE_SDI          = 2,
  NV_GPU_FLATPANEL_SIGNAL_TYPE_DISPLAYPORT  = 3,

} NV_GPU_FLATPANEL_SIGNAL_TYPE;

typedef enum _NV_GPU_FLATPANEL_SIGNAL_LINK
{
  NV_GPU_FLATPANEL_SIGNAL_SINGLE_LINK       = 1,
  NV_GPU_FLATPANEL_SIGNAL_DUAL_LINK         = 2,

} NV_GPU_FLATPANEL_SIGNAL_LINK;

typedef enum _NV_GPU_FLATPANEL_SIGNAL_DISPLAYPORT_LANES
{
  NV_GPU_FLATPANEL_SIGNAL_DISPLAYPORT_NONE              = 0,
  NV_GPU_FLATPANEL_SIGNAL_DISPLAYPORT_SINGLE_LANE       = 1,
  NV_GPU_FLATPANEL_SIGNAL_DISPLAYPORT_DUAL_LANE         = 2,
  NV_GPU_FLATPANEL_SIGNAL_DISPLAYPORT_QUAD_LANE         = 3,

} NV_GPU_FLATPANEL_SIGNAL_DISPLAYPORT_LANES;

typedef enum _NV_GPU_FLATPANEL_SIGNAL_COLOR_FLAGS
{
  NV_GPU_FLATPANEL_SIGNAL_COLOR_LIMITED_RANGE           = 0x00000001,   //flatpanel supports limited color range.
  NV_GPU_FLATPANEL_SIGNAL_COLOR_AUTO_CONFIGURE          = 0x00000002,   //flatpanel supports auto-configuring the color range.
  NV_GPU_FLATPANEL_SIGNAL_COLOR_FORMAT_YCBCR422_CAPABLE = 0x00000004,   //flatpanel is YCBCR422 color format capable.
  NV_GPU_FLATPANEL_SIGNAL_COLOR_FORMAT_YCBCR444_CAPABLE = 0x00000008,   //flatpanel is YCBCR444 color format capable.

} NV_GPU_FLATPANEL_SIGNAL_COLOR_FLAGS;

typedef struct
{
    NvU32                                       version;                    //structure version
    NV_GPU_FLATPANEL_SIGNAL_TYPE                signalType;                 //flat panel signal type
    NV_GPU_FLATPANEL_SIGNAL_LINK                linkType;                   //link type
    NV_GPU_FLATPANEL_SIGNAL_DISPLAYPORT_LANES   displayPortLanes;           //1, 2 or 4 lanes in case of displayport connected panel.
    NvU32                                       colorFlags;                 //one or more bits from NV_GPU_FLATPANEL_SIGNAL_COLOR_FLAGS
    NvU32                                       hdmiCapable:1;              //hdmi status
    NvU32                                       scalerDisabled:1;           //indicates if GPU scaling is disabled(possible with SLI active on certain GPUs)
    NvU32                                       refreshRateLocked:1;        //flat panel supports 60hz only
}
NV_GPU_FLAT_PANEL_INFO;

#define NV_GPU_FLAT_PANEL_INFO_VER  MAKE_NVAPI_VERSION(NV_GPU_FLAT_PANEL_INFO,1)

NVAPI_INTERFACE NvAPI_GPU_GetFlatPanelInfo(NvPhysicalGpuHandle hPhysicalGpu, NvU32 outputId, NV_GPU_FLAT_PANEL_INFO *pFlatPanelInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_ValidateOutputCombination
//
//   DESCRIPTION: This call is used to determine if a set of GPU outputs can be active
//                simultaneously.  While a GPU may have <n> outputs, they can not typically
//                all be active at the same time due to internal resource sharing.
//
//                Given a physical GPU handle and a mask of candidate outputs, this call
//                will return NVAPI_OK if all of the specified outputs can be driven
//                simultaneously.  It will return NVAPI_INVALID_COMBINATION if they cannot.
//
//                Use NvAPI_GPU_GetAllOutputs() to determine which outputs are candidates.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_OK: combination of outputs in outputsMask are valid (can be active simultaneously)
//                NVAPI_INVALID_COMBINATION: combination of outputs in outputsMask are NOT valid
//                NVAPI_INVALID_ARGUMENT: hPhysicalGpu or outputsMask does not have at least 2 bits set
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_ValidateOutputCombination(NvPhysicalGpuHandle hPhysicalGpu, NvU32 outputsMask);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetConnectorInfo
//
//   DESCRIPTION: Given a physical GPU handle and a single outputId (exactly 1 bit set),
//                this API fills the NV_GPU_CONNECTOR_INFO with connector specific data.
//                Note:If outputId is a connected or active then the current attached connector information is returned.
//                If there is no connector attached for the outputId then all possible connections on the board are returned.
//                Some TV outputs may have multiple connectors attached or it could have ambiguous connector layout on the board.
//                In that case the connector[] array will list all connectors but doesn't
//                indicate which one is 'active'. To get the active TV connector use NvAPI_GetTVOutputInfo.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hPhysicalGpu, outputId or pOutputsMask is NULL; or outputId has > 1 bit set
//                NVAPI_OK: *pConnectorInfo contains valid NV_GPU_CONNECTOR_INFO data
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//                NVAPI_INCOMPATIBLE_STRUCT_VERSION - NV_GPU_CONNECTOR_INFO version not compatible with driver
//
///////////////////////////////////////////////////////////////////////////////

typedef enum _NV_GPU_CONNECTOR_TYPE
{
    NVAPI_GPU_CONNECTOR_VGA_15_PIN                      = 0x00000000,
    NVAPI_GPU_CONNECTOR_TV_COMPOSITE                    = 0x00000010,
    NVAPI_GPU_CONNECTOR_TV_SVIDEO                       = 0x00000011,
    NVAPI_GPU_CONNECTOR_TV_HDTV_COMPONENT               = 0x00000013,
    NVAPI_GPU_CONNECTOR_TV_SCART                        = 0x00000014,
    NVAPI_GPU_CONNECTOR_TV_COMPOSITE_SCART_ON_EIAJ4120  = 0x00000016,
    NVAPI_GPU_CONNECTOR_TV_HDTV_EIAJ4120                = 0x00000017,
    NVAPI_GPU_CONNECTOR_PC_POD_HDTV_YPRPB               = 0x00000018,
    NVAPI_GPU_CONNECTOR_PC_POD_SVIDEO                   = 0x00000019,
    NVAPI_GPU_CONNECTOR_PC_POD_COMPOSITE                = 0x0000001A,
    NVAPI_GPU_CONNECTOR_DVI_I_TV_SVIDEO                 = 0x00000020,
    NVAPI_GPU_CONNECTOR_DVI_I_TV_COMPOSITE              = 0x00000021,
    NVAPI_GPU_CONNECTOR_DVI_I                           = 0x00000030,
    NVAPI_GPU_CONNECTOR_DVI_D                           = 0x00000031,
    NVAPI_GPU_CONNECTOR_ADC                             = 0x00000032,
    NVAPI_GPU_CONNECTOR_LFH_DVI_I_1                     = 0x00000038,
    NVAPI_GPU_CONNECTOR_LFH_DVI_I_2                     = 0x00000039,
    NVAPI_GPU_CONNECTOR_SPWG                            = 0x00000040,
    NVAPI_GPU_CONNECTOR_OEM                             = 0x00000041,
    NVAPI_GPU_CONNECTOR_DISPLAYPORT_EXTERNAL            = 0x00000046,
    NVAPI_GPU_CONNECTOR_DISPLAYPORT_INTERNAL            = 0x00000047,
    NVAPI_GPU_CONNECTOR_HDMI_A                          = 0x00000061,
    NVAPI_GPU_CONNECTOR_UNKNOWN                         = 0xFFFFFFFF,
} NV_GPU_CONNECTOR_TYPE;

typedef enum _NV_GPU_CONNECTOR_PLATFORM
{
    NVAPI_GPU_CONNECTOR_PLATFORM_DEFAULT_ADD_IN_CARD   = 0x00000000,
    NVAPI_GPU_CONNECTOR_PLATFORM_TWO_PLATE_ADD_IN_CARD = 0x00000001,
    NVAPI_GPU_CONNECTOR_PLATFORM_MOBILE_ADD_IN_CARD    = 0x00000008,
    NVAPI_GPU_CONNECTOR_PLATFORM_MOBILE_BACK           = 0x00000010,
    NVAPI_GPU_CONNECTOR_PLATFORM_MOBILE_BACK_LEFT      = 0x00000011,
    NVAPI_GPU_CONNECTOR_PLATFORM_MOBILE_BACK_DOCK      = 0x00000018,
    NVAPI_GPU_CONNECTOR_PLATFORM_MAINBOARD_DEFAULT     = 0x00000020,
    NVAPI_GPU_CONNECTOR_PLATFORM_UNKNOWN               = 0xFFFFFFFF,
} NV_GPU_CONNECTOR_PLATFORM;

typedef struct
{
    NV_GPU_CONNECTOR_TYPE   type;           // connector type
    NvU32                   locationIndex;  // connector location
} NV_GPU_CONNECTOR_DATA;

#define NV_API_MAX_CONNECTOR_PER_OUTPUT     4

typedef struct
{
    NvU32                       version;            // structure version
    NV_GPU_CONNECTOR_PLATFORM   connectorPlatform;  // connector platform
    NvU32                       connectorCount;     // num valid entries in connector[]
    NV_GPU_CONNECTOR_DATA       connector[NV_API_MAX_CONNECTOR_PER_OUTPUT];
} NV_GPU_CONNECTOR_INFO;

#define NV_GPU_CONNECTOR_INFO_VER  MAKE_NVAPI_VERSION(NV_GPU_CONNECTOR_INFO,1)

NVAPI_INTERFACE NvAPI_GPU_GetConnectorInfo(NvPhysicalGpuHandle hPhysicalGpu, NvU32 outputId, NV_GPU_CONNECTOR_INFO *pConnectorInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetShortName
//
//   DESCRIPTION: Retrieves the GPU short name (NV40, G70, etc.)
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetShortName(NvPhysicalGpuHandle hPhysicalGpu, NvAPI_ShortString szName);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetFullName
//
//   DESCRIPTION: Retrieves the full GPU name as an ascii string.  Eg: "Quadro FX 1400"
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetFullName(NvPhysicalGpuHandle hPhysicalGpu, NvAPI_ShortString szName);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetPCIIdentifiers
//
//   DESCRIPTION: Returns the PCI identifiers associated with this GPU.
//                  DeviceId - the internal PCI device identifier for the GPU.
//                  SubSystemId - the internal PCI subsystem identifier for the GPU.
//                  RevisionId - the internal PCI device-specific revision identifier for the GPU.
//                  ExtDeviceId - the external PCI device identifier for the GPU.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hPhysicalGpu or an argument is NULL
//                NVAPI_OK: arguments are populated with PCI identifiers
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPCIIdentifiers(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pDeviceId,NvU32 *pSubSystemId,NvU32 *pRevisionId,NvU32 *pExtDeviceId);

typedef enum _NV_GPU_TYPE
{
    NV_SYSTEM_TYPE_GPU_UNKNOWN     = 0,
    NV_SYSTEM_TYPE_IGPU            = 1, //integrated
    NV_SYSTEM_TYPE_DGPU            = 2, //discrete
} NV_GPU_TYPE;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetGPUType
//
// DESCRIPTION: Returns information to identify the GPU type
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hPhysicalGpu
// NVAPI_OK: *pGpuType contains the GPU type
// NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
// NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetGPUType(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_TYPE *pGpuType);

typedef enum _NV_GPU_BUS_TYPE
{
    NVAPI_GPU_BUS_TYPE_UNDEFINED    = 0,
    NVAPI_GPU_BUS_TYPE_PCI          = 1,
    NVAPI_GPU_BUS_TYPE_AGP          = 2,
    NVAPI_GPU_BUS_TYPE_PCI_EXPRESS  = 3,
    NVAPI_GPU_BUS_TYPE_FPCI         = 4,
} NV_GPU_BUS_TYPE;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetBusType
//
//   DESCRIPTION: Returns the type of bus associated with this GPU.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hPhysicalGpu or pBusType is NULL
//                NVAPI_OK: *pBusType contains bus identifier
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetBusType(NvPhysicalGpuHandle hPhysicalGpu,NV_GPU_BUS_TYPE *pBusType);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetBusId
//
//   DESCRIPTION: Returns the ID of bus associated with this GPU.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hPhysicalGpu or pBusId is NULL
//                NVAPI_OK: *pBusId contains bus id
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetBusId(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pBusId);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetBusSlotId
//
//   DESCRIPTION: Returns the ID of bus-slot associated with this GPU.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hPhysicalGpu or pBusSlotId is NULL
//                NVAPI_OK: *pBusSlotId contains bus-slot id
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetBusSlotId(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pBusSlotId);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetIRQ
//
//   DESCRIPTION: Returns the interrupt number associated with this GPU.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hPhysicalGpu or pIRQ is NULL
//                NVAPI_OK: *pIRQ contains interrupt number
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetIRQ(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pIRQ);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetVbiosRevision
//
//   DESCRIPTION: Returns the revision of the video bios associated with this GPU.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hPhysicalGpu or pBiosRevision is NULL
//                NVAPI_OK: *pBiosRevision contains revision number
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetVbiosRevision(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pBiosRevision);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetVbiosOEMRevision
//
//   DESCRIPTION: Returns the OEM revision of the video bios associated with this GPU.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hPhysicalGpu or pBiosRevision is NULL
//                NVAPI_OK: *pBiosRevision contains revision number
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetVbiosOEMRevision(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pBiosRevision);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetVbiosOemInfo
//
//   DESCRIPTION: Returns some OEM specific data from the vbios associated this GPU.
//
//    PARAMETERS: hPhysicalGpu(IN) - GPU selection.
//                pVbiosOemInfo(OUT) - Structure containing OEM information retrieved.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_OK: *pVbiosOemInfo contains info
//                NVAPI_INVALID_ARGUMENT: hPhysicalGpu or pVbiosOemInfo is NULL
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
typedef struct
{
    NvU32              version;        //structure version
    NvAPI_ShortString  vendorName;
    NvAPI_ShortString  productName;
    NvAPI_ShortString  productRevision;
} NV_VBIOS_OEM_INFO;
#define NV_VBIOS_OEM_INFO_VER MAKE_NVAPI_VERSION(NV_VBIOS_OEM_INFO,1)

NVAPI_INTERFACE NvAPI_GPU_GetVbiosOemInfo(NvPhysicalGpuHandle hPhysicalGpu,NV_VBIOS_OEM_INFO *pVbiosOemInfo);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetVbiosMxmVersion
//
//   DESCRIPTION: Returns the MXM Spec version of the video bios associated this GPU.
//
//    PARAMETERS: hPhysicalGpu(IN) - GPU selection.
//                pBiosMxmVersion(OUT) - MXM Version information retrieved.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_OK: *pBiosMxmVersion contains version number
//                NVAPI_INVALID_ARGUMENT: hPhysicalGpu or pBiosMxmVersion is NULL
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//                NVAPI_NOT_SUPPORTED: the specified GPU is not MXM form factor
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetVbiosMxmVersion(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pBiosMxmVersion);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetVbiosImage
//
//   DESCRIPTION: Returns the entire VBIOS image associated with this GPU.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hPhysicalGpu or pImage is NULL
//                NVAPI_OK: *pImage contains the vbios image, (parsing it is up to the caller)
//                NVAPI_INCOMPATIBLE_STRUCT_VERSION - NV_VBIOS_IMAGE version not compatible with driver
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
#define NV_VBIOS_IMAGE_SIZE (64*1024)
typedef struct
{
    NvU32   version;        //structure version
    NvU32   bufferSize;
    NvU8    buffer[NV_VBIOS_IMAGE_SIZE];
} NV_VBIOS_IMAGE;

#define NV_VBIOS_IMAGE_VER MAKE_NVAPI_VERSION(NV_VBIOS_IMAGE,1)
NVAPI_INTERFACE NvAPI_GPU_GetVbiosImage(NvPhysicalGpuHandle hPhysicalGpu,NV_VBIOS_IMAGE *pImage);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetMXMBlock
//
//   DESCRIPTION: Returns the MXM information block
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hPhysicalGpu or pMXMBlock is NULL
//                NVAPI_OK: *pMXMBlock is now set
//                NVAPI_INCOMPATIBLE_STRUCT_VERSION - NV_MXM_BLOCK version not compatible with driver
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
#define NV_MXM_BLOCK_SIZE (64*1024)
typedef struct
{
    NvU32   version;        //structure version
    NvU32   bufferSize;
    NvU8    buffer[NV_MXM_BLOCK_SIZE];
} NV_MXM_BLOCK;
#define NV_MXM_BLOCK_VER MAKE_NVAPI_VERSION(NV_MXM_BLOCK,1)
NVAPI_INTERFACE NvAPI_GPU_GetMXMBlock(NvPhysicalGpuHandle hPhysicalGpu, NV_MXM_BLOCK *pMXMBlock);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetVbiosVersionString
//
//   DESCRIPTION: Returns the full bios version string in the form of xx.xx.xx.xx.yy where
//                the xx numbers come from NvAPI_GPU_GetVbiosRevision and yy comes from
//                NvAPI_GPU_GetVbiosOEMRevision.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hPhysicalGpu is NULL
//                NVAPI_OK: szBiosRevision contains version string
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetVbiosVersionString(NvPhysicalGpuHandle hPhysicalGpu,NvAPI_ShortString szBiosRevision);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetAGPAperture
//
//   DESCRIPTION: Returns AGP aperture in megabytes
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pSize is NULL
//                NVAPI_OK: call successful
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetAGPAperture(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pSize);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetCurrentAGPRate
//
//   DESCRIPTION: Returns the current AGP Rate (1 = 1x, 2=2x etc, 0 = AGP not present)
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pRate is NULL
//                NVAPI_OK: call successful
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetCurrentAGPRate(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pRate);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetCurrentPCIEDownstreamWidth
//
//   DESCRIPTION: Returns the number of PCIE lanes being used for the PCIE interface
//                downstream from the GPU.
//
//                On systems that do not support PCIE, the maxspeed for the root link
//                will be zero.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pWidth is NULL
//                NVAPI_OK: call successful
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetCurrentPCIEDownstreamWidth(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pWidth);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_SetCurrentPCIEWidth
//
//   DESCRIPTION: Sets the number of PCIE lanes being used for the PCIE interface.
//                The exact corresponding Get for this function is:
//                    pInfo->gpu.currentWidth from NvAPI GPU_GetPCIEInfo()
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: newWidth is not a valid PCIE width value for the system.
//                NVAPI_NOT_SUPPORTED: this feature is not supported on this GPU
//                NVAPI_OK: call successful
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetCurrentPCIEWidth(NvPhysicalGpuHandle hPhysicalGpu,NvU32 newWidth);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_SetCurrentPCIESpeed
//
//   DESCRIPTION: Sets the PCIE speed in mega-bits per second for the PCIE interface.
//                Typical PCIE speed are 2500 Mbps or 5000 Mbps.
//                The exact corresponding Get for this function is:
//                    pInfo->gpu.currentSpeed from NvAPI GPU_GetPCIEInfo()
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: newSpeed is not a valid PCIE speed value for the system.
//                NVAPI_NOT_SUPPORTED: this feature is not supported on this GPU
//                NVAPI_OK: call successful
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetCurrentPCIESpeed(NvPhysicalGpuHandle hPhysicalGpu, NvU32 newSpeed);

typedef enum
{
    NV_PCIE_ASPM_STATE_DISABLED = 0,
    NV_PCIE_ASPM_STATE_L0S      = 0x1,
    NV_PCIE_ASPM_STATE_L1       = 0x2,
    NV_PCIE_ASPM_STATE_L0S_L1   = 0x3,
} NV_PCIE_ASPM_STATE;

typedef enum
{
    NV_PCIE_GENERATION_GEN_1 = 1,
    NV_PCIE_GENERATION_GEN_2 = 2,
} NV_PCIE_GENERATION;

typedef struct
{
    NvU32 maxSpeed;               // in Mega-bits per second
    NvU32 maxWidth;               // in lanes
    NvU32 supportedStates;        // see NV_PCIE_ASPM_STATE
    NvU32 currentSpeed;           // in Mega-bits per second
    NvU32 currentWidth;           // in lanes
    NvU32 currentState;           // see NV_PCIE_ASPM_STATE
} NV_PCIE_LINK_INFO_V1;

typedef struct
{
    NvU32 version;

    NV_PCIE_LINK_INFO_V1 root;
    NV_PCIE_LINK_INFO_V1 gpu;
    NV_PCIE_LINK_INFO_V1 upstream;
    NV_PCIE_LINK_INFO_V1 downstream;

} NV_PCIE_INFO_V1;

typedef struct
{
    NvU32 maxSpeed;                         // in Mega-bits per second
    NV_PCIE_GENERATION maxGeneration;       // Implemented PCIe Generation
    NvU32 maxWidth;                         // in lanes
    NV_PCIE_ASPM_STATE supportedStates;     // see NV_PCIE_ASPM_STATE

    NvU32 currentSpeed;                     // in Mega-bits per second
    NV_PCIE_GENERATION currentGeneration;   // currently negotiated PCIe Generation
    NvU32 currentWidth;                     // in lanes
    NV_PCIE_ASPM_STATE currentState;        // see NV_PCIE_ASPM_STATE
} NV_PCIE_LINK_INFO_V2;

typedef struct
{
    NvU32 version;

    NV_PCIE_LINK_INFO_V2 root;
    NV_PCIE_LINK_INFO_V2 gpu;
    NV_PCIE_LINK_INFO_V2 upstream;
    NV_PCIE_LINK_INFO_V2 downstream;
    NV_PCIE_LINK_INFO_V2 board;

} NV_PCIE_INFO_V2;

typedef NV_PCIE_LINK_INFO_V2 NV_PCIE_LINK_INFO;
typedef NV_PCIE_INFO_V2 NV_PCIE_INFO;

#define NV_PCIE_INFO_VER_1  MAKE_NVAPI_VERSION(NV_PCIE_INFO_V1,1)
#define NV_PCIE_INFO_VER_2  MAKE_NVAPI_VERSION(NV_PCIE_INFO_V2,2)
#define NV_PCIE_INFO_VER    NV_PCIE_INFO_VER_2

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetPCIEInfo
//
//   DESCRIPTION: Returns detailed info about the PCIE bus capabilities and current state both upstream
//                and downstream from the GPU
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pInfo is NULL
//                NVAPI_OK: call successful
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPCIEInfo(NvPhysicalGpuHandle hPhysicalGpu,NV_PCIE_INFO *pInfo);

typedef enum
{
    NV_PCIE_LINK_ERROR_CORR_ERROR       = 0x00000001,
    NV_PCIE_LINK_ERROR_NON_FATAL_ERROR  = 0x00000002,
    NV_PCIE_LINK_ERROR_FATAL_ERROR      = 0x00000004,
    NV_PCIE_LINK_ERROR_UNSUPP_REQUEST   = 0x00000008,
} NV_PCIE_LINK_ERROR;

typedef enum
{
    NV_PCIE_LINK_ERROR_FLAG_MASK_KNOWN_CORR_ERROR_ON_RECOVERY = 0x00000001,
} NV_PCIE_LINK_ERROR_FLAG;

typedef struct
{
    NvU32 version;

    NvU32 root;     //Returns PCIE link error on ROOT (bitfield of NV_PCIE_LINK_ERROR)
    NvU32 gpu;      //Returns PCIE link error on GPU  (bitfield of NV_PCIE_LINK_ERROR)

} NV_PCIE_LINK_ERROR_INFO_V1;

typedef struct
{
    NvU32 version;

    NvU32 root;     //Returns PCIE link error on ROOT (bitfield of NV_PCIE_LINK_ERROR)
    NvU32 gpu;      //Returns PCIE link error on GPU  (bitfield of NV_PCIE_LINK_ERROR)

    NvU32 flags;    //Special options  (bitfield of NV_PCIE_LINK_ERROR_FLAG)

} NV_PCIE_LINK_ERROR_INFO_V2;

typedef NV_PCIE_LINK_ERROR_INFO_V2     NV_PCIE_LINK_ERROR_INFO;

#define NV_PCIE_LINK_ERROR_INFO_VER_1  MAKE_NVAPI_VERSION(NV_PCIE_LINK_ERROR_INFO_V1,1)
#define NV_PCIE_LINK_ERROR_INFO_VER_2  MAKE_NVAPI_VERSION(NV_PCIE_LINK_ERROR_INFO_V2,2)
#define NV_PCIE_LINK_ERROR_INFO_VER    NV_PCIE_LINK_ERROR_INFO_VER_2



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_ClearPCIELinkErrorInfo
//
//   DESCRIPTION: Returns and clears PCIE link errors on both the GPU and the root port.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pInfo is NULL
//                NVAPI_OK: call successful
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_ClearPCIELinkErrorInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_PCIE_LINK_ERROR_INFO *pInfo);

typedef enum
{
    NV_PCIE_LINK_AER_UNCORR_TRAINING_ERR      = 0x00000001,
    NV_PCIE_LINK_AER_UNCORR_DLINK_PROTO_ERR   = 0x00000002,
    NV_PCIE_LINK_AER_UNCORR_POISONED_TLP      = 0x00000004,
    NV_PCIE_LINK_AER_UNCORR_FC_PROTO_ERR      = 0x00000008,
    NV_PCIE_LINK_AER_UNCORR_CPL_TIMEOUT       = 0x00000010,
    NV_PCIE_LINK_AER_UNCORR_CPL_ABORT         = 0x00000020,
    NV_PCIE_LINK_AER_UNCORR_UNEXP_CPL         = 0x00000040,
    NV_PCIE_LINK_AER_UNCORR_RCVR_OVERFLOW     = 0x00000080,
    NV_PCIE_LINK_AER_UNCORR_MALFORMED_TLP     = 0x00000100,
    NV_PCIE_LINK_AER_UNCORR_ECRC_ERROR        = 0x00000200,
    NV_PCIE_LINK_AER_UNCORR_UNSUPPORTED_REQ   = 0x00000400,
    NV_PCIE_LINK_AER_CORR_RCV_ERR             = 0x00010000,
    NV_PCIE_LINK_AER_CORR_BAD_TLP             = 0x00020000,
    NV_PCIE_LINK_AER_CORR_BAD_DLLP            = 0x00040000,
    NV_PCIE_LINK_AER_CORR_RPLY_ROLLOVER       = 0x00080000,
    NV_PCIE_LINK_AER_CORR_RPLY_TIMEOUT        = 0x00100000,
    NV_PCIE_LINK_AER_CORR_ADVISORY_NONFATAL   = 0x00200000,
} NV_PCIE_LINK_AER;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_ClearPCIELinkAERInfo
//
//   DESCRIPTION: Returns and clears PCIE link errors through Advanced Error Reporting (AER)
//                NOTE: pInfo is a NV_PCIE_LINK_AER bitfield.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pInfo is NULL
//                NVAPI_OK: call successful
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_ClearPCIELinkAERInfo(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pInfo);


typedef struct
{
    NvU32 version;

    NvU32 driveStrengthRiseCount;             // Failure count for drive strength rising
    NvU32 driveStrengthFallCount;             // Failure count for drive strength falling
    NvU32 driveStrengthTermCount;             // Failure count for drive strength termination
    NvU32 slewStrengthRiseCount;              // Failure count for slew strength rising
    NvU32 slewStrengthFallCount;              // Failure count for slew strength falling
} NV_GPU_FRAMEBUFFER_CALIBRATION_LOCK_FAILURES_INFO;

#define NV_GPU_FRAMEBUFFER_CALIBRATION_LOCK_FAILURES_INFO_VER  MAKE_NVAPI_VERSION(NV_GPU_FRAMEBUFFER_CALIBRATION_LOCK_FAILURES_INFO,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetFrameBufferCalibrationLockFailures
//
//   DESCRIPTION: Returns the number of failures of various types in frame buffer calibration lock
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pParams is NULL
//                NVAPI_OK: call successful
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//                NVAPI_NOT_SUPPORTED: Frame buffer calibration lock failure detection is not supported on this GPU.
//                NVAPI_INCOMPATIBLE_STRUCT_VERSION: the version of the INFO struct is not supported
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetFrameBufferCalibrationLockFailures(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_FRAMEBUFFER_CALIBRATION_LOCK_FAILURES_INFO *pParams);


typedef enum _NV_DISPLAY_UNDERFLOW_MODE
{
    NV_DISPLAY_UNDERFLOW_MODE_DISABLED,  // underflow checking is disabled
    NV_DISPLAY_UNDERFLOW_MODE_REPEAT,    // checking is enabled, but the underflow is automatically cleared periodically
    NV_DISPLAY_UNDERFLOW_MODE_STICKY,    // underflow bit is sticky until explicitly cleared
} NV_DISPLAY_UNDERFLOW_MODE;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_SetDisplayUnderflowMode
//
// DESCRIPTION:     Sets the current HW handling on display underflow for testing and debugging.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS:   NVAPI_INVALID_HANDLE: hNvDisplay was not a valid NVIDIA dipslay handle
//                  NVAPI_INVALID_ARGUMENT: mode is invalid
//                  NVAPI_OK: Call successful
//                  NVAPI_NOT_SUPPORTED: GPU does not support display underflow reporting
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetDisplayUnderflowMode(NvDisplayHandle hNvDisplay, NV_DISPLAY_UNDERFLOW_MODE mode);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetDisplayUnderflowStatus
//
// DESCRIPTION:     Returns the underflow status bit, which is set when the GPU was unable to keep up with display output.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS:      hNvDisplay(IN)          - NVIDIA display selection
//                  clearUnderflow(IN)      - If set, the underflow status bit will be cleared after the result is returned.
//                  pUnderflowDetected(OUT) - Display underflow status
//
// RETURN STATUS:   NVAPI_INVALID_HANDLE: hNvDisplay was not a valid NVIDIA dipslay handle
//                  NVAPI_INVALID_ARGUMENT: pUnderflowDetected is NULL
//                  NVAPI_OK: Call successful
//                  NVAPI_NOT_SUPPORTED: GPU does not support display underflow reporting
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetDisplayUnderflowStatus(NvDisplayHandle hNvDisplay, NvU32 clearUnderflow, NvU32 *pUnderflowDetected);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetPhysicalFrameBufferSize
//
//   DESCRIPTION: Returns the physical size of framebuffer in Kb.  This does NOT include any
//                system RAM that may be dedicated for use by the GPU.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pSize is NULL
//                NVAPI_OK: call successful
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPhysicalFrameBufferSize(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pSize);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetVirtualFrameBufferSize
//
//   DESCRIPTION: Returns the virtual size of framebuffer in Kb.  This includes the physical RAM plus any
//                system RAM that has been dedicated for use by the GPU.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pSize is NULL
//                NVAPI_OK: call successful
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetVirtualFrameBufferSize(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pSize);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetBarInfo
//
//   DESCRIPTION: Retrieves information on all GPU base-address-registers
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pInfo is NULL
//                NVAPI_OK: *pInfo is set (count gives the # of BARs populated in the array)
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
#define NV_GPU_MAX_BAR_COUNT 8

typedef struct
{
    NvU32   version;        //structure version
    NvU8    count;
    struct
    {
        NvU32 flags;        // For future use (no flags yet defined)
        NvU32 barSize;
        NvU64 barOffset;
    } barInfo[NV_GPU_MAX_BAR_COUNT];
} NV_GPU_BAR_INFO;
#define NV_GPU_BAR_INFO_VER         MAKE_NVAPI_VERSION(NV_GPU_BAR_INFO,1)

NVAPI_INTERFACE NvAPI_GPU_GetBarInfo(NvPhysicalGpuHandle hPhysicalGpu,NV_GPU_BAR_INFO *pInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetQuadroStatus
//
//   DESCRIPTION: Retrieves the Quadro status for the GPU (1 if Quadro, 0 if GeForce)
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetQuadroStatus(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pStatus);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetPSFloorSweepStatus
//                NvAPI_GPU_GetVSFloorSweepStatus
//
//   DESCRIPTION: Retrieves floorsweeping information for the vertex and pixel
//                shader units.  Bit field for each, unified architectures will
//                return the same value for both VS and PS.
//                NEVER TO BE EXPOSED!!!!!
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////

//  SUPPORTED OS: Mac OS X, Windows XP and higher
NVAPI_INTERFACE NvAPI_GPU_GetPSFloorSweepStatus(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pReturn);

//  SUPPORTED OS: Mac OS X, Windows XP and higher
NVAPI_INTERFACE NvAPI_GPU_GetVSFloorSweepStatus(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pReturn);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetSerialNumber
//
//   DESCRIPTION: Retrieves a unique serial number from the specified GPU
//                The format may vary from GPU to GPU, but is within 64-bits
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetSerialNumber(NvPhysicalGpuHandle hPhysicalGpu, NvU64 *pSerialNum);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_ManufacturingInfo
//
//   DESCRIPTION: Retrieves a unique serial number from the specified GPU
//                The format may vary from GPU to GPU, but is within 128-bits
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////

typedef struct
{
    NvU32 version;
    NvU64 ecid[2];
}NV_MANUFACTURING_INFO;
#define NV_MANUFACTURING_INFO_VER  MAKE_NVAPI_VERSION(NV_MANUFACTURING_INFO,1)
NVAPI_INTERFACE NvAPI_GPU_ManufacturingInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_MANUFACTURING_INFO *info);



typedef enum
{
    NV_GPU_RAM_TYPE_UNKNOWN = 0,
    NV_GPU_RAM_TYPE_SDRAM   = 1,
    NV_GPU_RAM_TYPE_DDR1    = 2,
    NV_GPU_RAM_TYPE_DDR2    = 3,
    NV_GPU_RAM_TYPE_GDDR2   = 4,
    NV_GPU_RAM_TYPE_GDDR3   = 5,
    NV_GPU_RAM_TYPE_GDDR4   = 6,
    NV_GPU_RAM_TYPE_DDR3    = 7,
    NV_GPU_RAM_TYPE_GDDR5   = 8
} NV_GPU_RAM_TYPE;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetRamType
//
//   DESCRIPTION: Retrieves the type of VRAM associated with this CPU
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetRamType(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_RAM_TYPE *pRamType);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetRamConfigStrap
//
//   DESCRIPTION: Retrieves a 32-bit value that indicates (indirectly) the type of
//                RAM configuration associated with the GPU.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetRamConfigStrap(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pRamConfigStrap);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetRamBusWidth
//
//   DESCRIPTION: Returns the width of the GPU's RAM memory bus.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetRamBusWidth(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pBusWidth);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetFBWidthAndLocation
//
//   DESCRIPTION: Returns the width and location of the GPU's RAM memory bus.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////
typedef enum _NV_GPU_FB_LOCATION
{
    NV_GPU_FB_RAM_LOCATION_UNKNOWN       = 0,
    NV_GPU_FB_RAM_LOCATION_GPU_DEDICATED = 1,
    NV_GPU_FB_RAM_LOCATION_SYS_SHARED    = 2,
    NV_GPU_FB_RAM_LOCATION_SYS_DEDICATED = 3,
} NV_GPU_FB_LOCATION;
NVAPI_INTERFACE NvAPI_GPU_GetFBWidthAndLocation(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pBusWidth, NV_GPU_FB_LOCATION *pFBLocation);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetRamBankCount
//
//   DESCRIPTION: Returns the number of banks of RAM associated with the GPU.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetRamBankCount(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pBankCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetArchInfo
//
//   DESCRIPTION: Retrieves arch/impl/rev for the specified GPU
//                INTERNAL USE ONLY!
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////
typedef struct
{
    NvU32 version;

    NvU32 architecture;
    NvU32 implementation;
    NvU32 revision;

} NV_GPU_ARCH_INFO;
#define NV_GPU_ARCH_INFO_VER  MAKE_NVAPI_VERSION(NV_GPU_ARCH_INFO,1)

NVAPI_INTERFACE NvAPI_GPU_GetArchInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_ARCH_INFO *pGpuArchInfo);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetExtendedMinorRevision
//
//   DESCRIPTION: Retrieves extended minor revision for the specified GPU
//                INTERNAL USE ONLY!
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//                NVAPI_NOT_SUPPORTED if the value is not available on this GPU
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetExtendedMinorRevision(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pValue);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetSampleType
//
//   DESCRIPTION: Retrieves the type of sample for the specified GPU
//                INTERNAL USE ONLY!
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//                NVAPI_NOT_SUPPORTED if the value is not available on this GPU
//
///////////////////////////////////////////////////////////////////////////////
typedef enum _NV_GPU_SAMPLE_TYPE
{
    NV_GPU_SAMPLE_NONE       = 0,    // The GPU is not a sample, it's a production part.
    NV_GPU_SAMPLE_ES         = 1,    // The GPU is an engineering sample. (ES)
    NV_GPU_SAMPLE_QS         = 2,    // The GPU is a qualification sample. (QS)
    NV_GPU_SAMPLE_PS         = 3,    // The GPU is a production sample. (PS)
    NV_GPU_SAMPLE_QS_PS_PROD = 4,    // The GPU is QS,PS or a production part, but NOT an ES.
} NV_GPU_SAMPLE_TYPE;
NVAPI_INTERFACE NvAPI_GPU_GetSampleType(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_SAMPLE_TYPE *pValue);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetHardwareQualType
//
//   DESCRIPTION: Retrieves the hardware qualification type for the specified GPU
//                INTERNAL USE ONLY!
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//                NVAPI_NOT_SUPPORTED if the value is not available on this GPU
//
///////////////////////////////////////////////////////////////////////////////
typedef enum _NV_GPU_HW_QUAL_TYPE
{
    NV_GPU_HW_QUAL_TYPE_NONE          = 0,    // The GPU is not a HW Qual part, there is no HW qual type
    NV_GPU_HW_QUAL_TYPE_NOMINAL       = 1,
    NV_GPU_HW_QUAL_TYPE_SLOW          = 2,
    NV_GPU_HW_QUAL_TYPE_FAST          = 3,
    NV_GPU_HW_QUAL_TYPE_HIGH_LEAKAGE  = 4,
} NV_GPU_HW_QUAL_TYPE;
NVAPI_INTERFACE NvAPI_GPU_GetHardwareQualType(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_HW_QUAL_TYPE *pValue);

///////////////////////////////////////////////////////////////////////////////
//
//  GPU Clock Control
//
//  These APIs allow the user to get and set individual clock domains
//  on a per-GPU basis.
//
///////////////////////////////////////////////////////////////////////////////
#define NVAPI_MAX_GPU_CLOCKS            32
#define NVAPI_MAX_GPU_PERF_VOLTAGES     16
#define NVAPI_MAX_GPU_PERF_PSTATES      16

typedef enum _NV_GPU_CLOCK_INFO_DOMAIN_ID
{
    NVAPI_GPU_CLOCK_INFO_DOMAIN_NV      = 0,
    NVAPI_GPU_CLOCK_INFO_DOMAIN_M       = 4,
    NVAPI_GPU_CLOCK_INFO_DOMAIN_HOTCLK  = 7,
    NVAPI_GPU_CLOCK_INFO_DOMAIN_UNDEFINED = NVAPI_MAX_GPU_CLOCKS,
} NV_GPU_CLOCK_INFO_DOMAIN_ID;

typedef enum _NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID
{
    NVAPI_GPU_PERF_VOLTAGE_INFO_DOMAIN_CORE      = 0,
    NVAPI_GPU_PERF_VOLTAGE_INFO_DOMAIN_UNDEFINED = NVAPI_MAX_GPU_PERF_VOLTAGES,
} NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID;

typedef enum _NV_GPU_CLOCK_DOMAIN_ID
{
    NVAPI_GPU_CLOCK_DOMAIN_NV      = 0,
    NVAPI_GPU_CLOCK_DOMAIN_G       = 1,
    NVAPI_GPU_CLOCK_DOMAIN_S       = 2,
    NVAPI_GPU_CLOCK_DOMAIN_R       = 3,
    NVAPI_GPU_CLOCK_DOMAIN_M       = 4,
    NVAPI_GPU_CLOCK_DOMAIN_HOST    = 5,
    NVAPI_GPU_CLOCK_DOMAIN_DISP    = 6,
    NVAPI_GPU_CLOCK_DOMAIN_HOTCLK  = 7,
    NVAPI_GPU_CLOCK_DOMAIN_PCLK0   = 8,
    NVAPI_GPU_CLOCK_DOMAIN_PCLK1   = 9,
    NVAPI_GPU_CLOCK_DOMAIN_BYPCLK  = 10,
    NVAPI_GPU_CLOCK_DOMAIN_XCLK    = 11,
    NVAPI_GPU_CLOCK_DOMAIN_VPV     = 12,
    NVAPI_GPU_CLOCK_DOMAIN_VPS     = 13,
    NVAPI_GPU_CLOCK_DOMAIN_GPUCACHECLK     = 14,
    NVAPI_GPU_CLOCK_DOMAIN_UNDEFINED = NVAPI_MAX_GPU_CLOCKS,
} NV_GPU_CLOCK_DOMAIN_ID;

typedef enum _NV_GPU_PERF_VOLTAGE_DOMAIN_ID
{
    NVAPI_GPU_PERF_VOLTAGE_DOMAIN_CORE      = 0,
    NVAPI_GPU_PERF_VOLTAGE_DOMAIN_FB        = 1,
    NVAPI_GPU_PERF_VOLTAGE_DOMAIN_UNDEFINED = NVAPI_MAX_GPU_PERF_VOLTAGES,

} NV_GPU_PERF_VOLTAGE_DOMAIN_ID;

typedef struct
{
    NvU32                  version;         // Structure version
    struct
    {
        NvU32                  frequency;       // frequency of clock in Khz

        // These bits are only valid on NvAPI_GPU_GetAllClocks
        NvU32                  bIsPresent:1;    // set if this domain is present on this GPU
        NvU32                  bDrivingDDR:1;   // set if clock is driving DDR memory

        NvU32                  bSetClock:1;   // if set during NvAPI_GPU_SetClocks call, this domain will be set

    } domain[NVAPI_MAX_GPU_CLOCKS];
} NV_GPU_CLOCK_INFO_V1;

typedef struct
{
    NvU32                  version;                     // Structure version
    struct
    {
        NvU32                   frequency;              // frequency of clock in Khz
        // These bits are only valid on NvAPI_GPU_GetAllClocks
        NvU32                   bIsPresent:1;           // set if this domain is present on this GPU
        NvU32                   bDrivingDDR:1;          // set if clock is driving DDR memory
        NvU32                   bSetClock:1;            // if set during NvAPI_GPU_SetClocks call, this domain will be set
    } domain[NVAPI_MAX_GPU_CLOCKS];
    // used in NvAPI_GPU_GetAllClocks to retreive thermal slowdown frequency values
    struct
    {
        NvU32                   effectiveFrequency;     // == domain[i].frequency unless we have some slowdown (i.e. thermal)
        NvU32                   reserved[6];            // reserved for binary compatibility in future api extensions
    } extendedDomain[NVAPI_MAX_GPU_CLOCKS];
} NV_GPU_CLOCK_INFO_V2;

typedef NV_GPU_CLOCK_INFO_V2 NV_GPU_CLOCK_INFO;

#define NV_GPU_CLOCK_INFO_VER_1  MAKE_NVAPI_VERSION(NV_GPU_CLOCK_INFO_V1,1)
#define NV_GPU_CLOCK_INFO_VER_2  MAKE_NVAPI_VERSION(NV_GPU_CLOCK_INFO_V2,2)
#define NV_GPU_CLOCK_INFO_VER    NV_GPU_CLOCK_INFO_VER_2

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetAllClocks
//
//   DESCRIPTION: This retrieves the NV_GPU_CLOCK_INFO structure for the specified physical GPU.
//                     For each clock domain:
//                        bIsPresent is set for each domain that is present on the GPU
//                        bDrivingDDR is set if that clock is driving dual-data-rate RAM
//                        frequency is the rate (in Khz) of the clock at the time of the call
//
//                Each domain's info is indexed in the array.  For example:
//                      clkInfo.domain[NVAPI_GPU_CLOCK_DOMAIN_M] holds the info for the 'M' domain
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_INVALID_ARGUMENT - pClkInfo is NULL
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the INFO struct is not supported
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetAllClocks(NvPhysicalGpuHandle hPhysicalGPU, NV_GPU_CLOCK_INFO *pClkInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_SetClocks
//
//   DESCRIPTION: This allows the caller to set one or more GPU clock domains with one call.
//                Some domains MUST be changed in conjunctions with others on some architectures.
//                It's up to the caller to know the details and do the right thing.
//
//                If bSetDeferred is set, the clocks will be changed with the next modeset event.
//                Otherwise, the clocks will be set at the time of the call.
//
//                Only domains in the array with bSetClock set will be affected. Due to PLL
//                programming constraints, the actual value set may vary slightly from the
//                requested frequency.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_INVALID_ARGUMENT - pClkInfo is NULL
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the INFO struct is not supported
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetClocks(NvPhysicalGpuHandle hPhysicalGPU, NvU32 bSetDeferred, NV_GPU_CLOCK_INFO *pClkInfo);

//Performance flags for the HybridMode APIs.
#define NV_PERF_CLOCK_GPU_HYBRID_MODE_SUPPORTED       0x00000001 //Hybrid mode available on the selected GPU
#define NV_PERF_CLOCK_GPU_HYBRID_MODE_ENABLE          0x00000002 //Enable Hybrid Mode
#define NV_PERF_CLOCK_GPU_HYBRID_MODE_DISABLE         0x00000004 //Disable Hybrid Mode
#define NV_PERF_CLOCK_GPU_HYBRID_MODE_ACTIVE          0x00000008 //Hybrid Mode enabled and active with higher voltage
#define NV_PERF_CLOCK_GPU_HYBRID_MODE_INACTIVE        0x00000010 //Hybrid Mode enabled but inactive with no gpu demand or default clocks.

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_SetPerfHybridMode
//
// DESCRIPTION:     API to enable or disable the performance overclocking Hybrid Mode.
//                  On NVAPI_OK the perf tables should be requeried with NvAPI_GPU_GetPerfClocks.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS:      hPhysicalGPU(IN) - GPU selection.
//                  gpuPerfFlags - Hybrid mode selection set to NV_PERF_CLOCK_GPU_HYBRID_MODE_ENABLE or DISABLE.
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_NOT_SUPPORTED - HybridMode is not supported on this GPU.
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_GPU_SetPerfHybridMode(NvPhysicalGpuHandle hPhysicalGpu, NvU32 gpuPerfFlags);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetPerfHybridMode
//
// DESCRIPTION:     API to query the performance overclocking Hybrid Mode status.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS:      hPhysicalGPU(IN) - GPU selection.
//                  pgpuPerfFlags - Hybrid mode status. One or more flags from NV_PERF_CLOCK_GPU_HYBRID_MODE.
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_INVALID_ARGUMENT - pGpuPerfFlags is NULL
//    NVAPI_NOT_SUPPORTED - HybridMode is not supported on this GPU.
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_GPU_GetPerfHybridMode(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pGpuPerfFlags);

///////////////////////////////////////////////////////////////////////////////


//Performance table overclocking

typedef enum _NV_GPU_PERF_CLOCK_DOMAIN_ID
{
    NVAPI_GPU_PERF_CLOCK_DOMAIN_NV      = 0,
    NVAPI_GPU_PERF_CLOCK_DOMAIN_M       = 4,
    NVAPI_GPU_PERF_CLOCK_DOMAIN_HOTCLK  = 7,

} NV_GPU_PERF_CLOCK_DOMAIN_ID;

#define NVAPI_MAX_GPU_PERF_CLOCKS       32


#define NVAPI_MAX_PERF_CLOCK_LEVELS     12
#define NVAPI_TARGET_ALL_PERF_LEVELS    0xffffffff

#define NV_PERF_CLOCK_LEVEL_STATE_DEFAULT                   0x00000000 //level is in its default state
#define NV_PERF_CLOCK_LEVEL_STATE_OVERCLOCKED               0x00000001 //level is overclocked
#define NV_PERF_CLOCK_LEVEL_STATE_DESKTOP                   0x00000002 //2d desktop perf level
#define NV_PERF_CLOCK_LEVEL_STATE_PERFORMANCE               0x00000004 //3d applications perf level
#define NV_PERF_CLOCK_LEVEL_STATE_TEST                      0x00000008 //test the new clocks for this level. Does not apply.
#define NV_PERF_CLOCK_LEVEL_STATE_TEST_SUCCESS              0x00000010 //test result

#define NV_PERF_CLOCK_GPU_STATE_DEFAULT                     0x00000000 //default state
#define NV_PERF_CLOCK_GPU_STATE_DYNAMIC_SUPPORTED           0x00000001 //gpu supports dynamic performance level transitions
#define NV_PERF_CLOCK_GPU_STATE_DESKTOP                     0x00000002 //gpu in desktop level
#define NV_PERF_CLOCK_GPU_STATE_PERFORMANCE                 0x00000004 //gpu in performance level
#define NV_PERF_CLOCK_GPU_STATE_ACTIVE_CLOCKING_SUPPORTED   0x00000008 //active clocking supported
#define NV_PERF_CLOCK_GPU_STATE_ACTIVE_CLOCKING_ENABLE      0x00000010 //enable active clocking
#define NV_PERF_CLOCK_GPU_STATE_ACTIVE_CLOCKING_DISABLE     0x00000020 //disable active clocking
#define NV_PERF_CLOCK_GPU_STATE_MEMCLK_CONTROL_DISABLED     0x00000040 //memory clock control disabled
#define NV_PERF_CLOCK_GPU_STATE_GFXCLK_CONTROL_DISABLED     0x00000080 //core clock control disabled
#define NV_PERF_CLOCK_GPU_STATE_SET_DEFERRED                0x00000100 //No immediate perf transitions. Deferred until perf triggers kick in.
#define NV_PERF_CLOCK_GPU_STATE_TESTING_CLOCKS_SUPPORTED    0x00000200 //testing clocks supported

typedef struct
{
    NvU32   version;                                //IN perf clock table version
    NvU32   levelCount;                             //number of the performance levels. count increases everytime a level is overclocked
    NvU32   gpuPerflevel;                           //OUT the current perf level. This is a dynamic level which can possibly change on every call
    NvU32   domainCount;                            //IN/OUT number of domains
    NvU32   gpuPerfFlags;                           //IN/OUT gpu flags - one of the flags defined in NV_PERF_CLOCK_GPU_STATE
    struct
    {
        NvU32   level;                              //IN/OUT performance level indicator, range 0 to levelCount - 1.
        NvU32   flags;                              //IN/OUT per level flags - one of more flags defined in NV_PERF_CLOCK_LEVEL_STATE
        struct
        {
            NV_GPU_PERF_CLOCK_DOMAIN_ID domainId;       //IN/OUT current domain indicator - one of the ids from NV_GPU_PERF_CLOCK_DOMAIN_ID
            NvU32                       domainFlags;    //reserved unused domain flags
            NvU32                       currentFreq;    //IN/OUT current clock KHz
            NvU32                       defaultFreq;    //default clock KHz
            NvU32                       minFreq;        //min KHz
            NvU32                       maxFreq;        //max KHz
            NvU32                       bSetClock:1;    //IN if set during NvAPI_GPU_SetPerfClocks call, this domain currentFreq will be applied
        } domain[NVAPI_MAX_GPU_PERF_CLOCKS];
    } perfLevel[NVAPI_MAX_PERF_CLOCK_LEVELS];

} NV_GPU_PERF_CLOCK_TABLE;

#define NV_GPU_PERF_CLOCK_TABLE_VER  MAKE_NVAPI_VERSION(NV_GPU_PERF_CLOCK_TABLE,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetPerfClocks
//
// DESCRIPTION:     Retrieves the performance clock table information for one or all the supported levels.
//                  NOTE: This call will return 0 for system memory
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS:      hPhysicalGPU(IN) - GPU selection.
//                  level(IN) - Specific level selection. Zero for all levels. Number of levels increases with overclocking of the levels.
//                  pPerfClkTable(OUT) - Table of performance levels retrieved.
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the PERF_CLOCK_TABLE struct is not supported
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPerfClocks(NvPhysicalGpuHandle hPhysicalGpu, NvU32 level, NV_GPU_PERF_CLOCK_TABLE *pPerfClkTable);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_SetPerfClocks
//
// DESCRIPTION:     Overclock a specific level in the performance table or overclock all levels with bSetClock set.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS:      hPhysicalGPU(IN) - GPU selection.
//                  level(IN) - Specific level selection. Zero for all levels. Number of levels increases with overclocking of the levels.
//                  pPerfClkTable(IN) - Table of performance levels to set.
//                  Any other than DEFAULT for GPU and Level flags - gpuPerfFlags and level flags gets applied.
//                  If bSetClock is set, currentFreq gets applied.
//                  Overclocking DOMAIN_NV requires simulteneous overclocking of DOMAIN_M, else overclocking will fail.
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the PERF_CLOCK_TABLE struct is not supported
//    NVAPI_TESTING_CLOCKS_NOT_SUPPORTED - testing clocks not supported
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_GPU_SetPerfClocks(NvPhysicalGpuHandle hPhysicalGpu, NvU32 level, NV_GPU_PERF_CLOCK_TABLE *pPerfClkTable);

///////////////////////////////////////////////////////////////////////////////////
//  GPU Cooler Controls
//  Provides ability to Get and Set the fan level or equivalent cooler levels for various target devices associated with the GPU

#define NVAPI_MAX_COOLERS_PER_GPU_VER1  3
#define NVAPI_MAX_COOLERS_PER_GPU_VER2  20

#define NVAPI_MAX_COOLERS_PER_GPU       NVAPI_MAX_COOLERS_PER_GPU_VER2
#define NVAPI_MIN_COOLER_LEVEL          0
#define NVAPI_MAX_COOLER_LEVEL          100
#define NVAPI_MAX_COOLER_LEVELS         24

typedef enum
{
    NVAPI_COOLER_TYPE_NONE = 0,
    NVAPI_COOLER_TYPE_FAN,
    NVAPI_COOLER_TYPE_WATER,
    NVAPI_COOLER_TYPE_LIQUID_NO2,
} NV_COOLER_TYPE;

typedef enum
{
    NVAPI_COOLER_CONTROLLER_NONE = 0,
    NVAPI_COOLER_CONTROLLER_ADI,
    NVAPI_COOLER_CONTROLLER_INTERNAL,
} NV_COOLER_CONTROLLER;

typedef enum
{
    NVAPI_COOLER_POLICY_NONE = 0,
    NVAPI_COOLER_POLICY_MANUAL,                     //Manual adjustment of cooler level. Gets applied right away independent of temperature or performance level.
    NVAPI_COOLER_POLICY_PERF,                       //GPU performance controls the cooler level.
    NVAPI_COOLER_POLICY_TEMPERATURE_DISCRETE = 4,   //Discrete thermal levels control the cooler level.
    NVAPI_COOLER_POLICY_TEMPERATURE_CONTINUOUS = 8, //Cooler level adjusted at continuous thermal levels.
    NVAPI_COOLER_POLICY_HYBRID,                     //Hybrid of performance and temperature levels.
} NV_COOLER_POLICY;

typedef enum
{
    NVAPI_COOLER_TARGET_NONE = 0,   
    NVAPI_COOLER_TARGET_GPU,                //GPU cooler requires NvPhysicalGpuHandle
    NVAPI_COOLER_TARGET_MEMORY,             //GPU memory cooler requires NvPhysicalGpuHandle
    NVAPI_COOLER_TARGET_POWER_SUPPLY = 4,   //GPU power supply cooler requires NvPhysicalGpuHandle
    NVAPI_COOLER_TARGET_ALL = 7,            //This cooler cools all of the components related to its target gpu.
    NVAPI_COOLER_TARGET_VCD_COOLER1 = 8,    //Visual Computing Device coolers 1 to 20
    NVAPI_COOLER_TARGET_VCD_COOLER2,        //Requires NvVisualComputingDeviceHandle     
    NVAPI_COOLER_TARGET_VCD_COOLER3,   
    NVAPI_COOLER_TARGET_VCD_COOLER4,   
    NVAPI_COOLER_TARGET_VCD_COOLER5,   
    NVAPI_COOLER_TARGET_VCD_COOLER6,   
    NVAPI_COOLER_TARGET_VCD_COOLER7,   
    NVAPI_COOLER_TARGET_VCD_COOLER8,   
    NVAPI_COOLER_TARGET_VCD_COOLER9,   
    NVAPI_COOLER_TARGET_VCD_COOLER10,  
    NVAPI_COOLER_TARGET_VCD_COOLER11,  
    NVAPI_COOLER_TARGET_VCD_COOLER12,  
    NVAPI_COOLER_TARGET_VCD_COOLER13,  
    NVAPI_COOLER_TARGET_VCD_COOLER14,  
    NVAPI_COOLER_TARGET_VCD_COOLER15,  
    NVAPI_COOLER_TARGET_VCD_COOLER16,  
    NVAPI_COOLER_TARGET_VCD_COOLER17,  
    NVAPI_COOLER_TARGET_VCD_COOLER18,  
    NVAPI_COOLER_TARGET_VCD_COOLER19,  
    NVAPI_COOLER_TARGET_VCD_COOLER20,  
} NV_COOLER_TARGET;

typedef enum
{
    NVAPI_COOLER_CONTROL_NONE = 0,
    NVAPI_COOLER_CONTROL_TOGGLE,                   //ON/OFF
    NVAPI_COOLER_CONTROL_VARIABLE,                 //Suppports variable control.
} NV_COOLER_CONTROL;

typedef enum
{
    NVAPI_INACTIVE = 0,             //inactive or unsupported
    NVAPI_ACTIVE = 1,               //active and spinning in case of fan
} NV_COOLER_ACTIVITY_LEVEL;

typedef struct
{
    NvU32   version;                //structure version
    NvU32   count;                  //number of associated coolers with the selected GPU
    struct
    {
        NV_COOLER_TYPE              type;               //type of cooler - FAN, WATER, LIQUID_NO2...
        NV_COOLER_CONTROLLER        controller;         //internal, ADI...
        NvU32                       defaultMinLevel;    //the min default value % of the cooler
        NvU32                       defaultMaxLevel;    //the max default value % of the cooler
        NvU32                       currentMinLevel;    //the current allowed min value % of the cooler
        NvU32                       currentMaxLevel;    //the current allowed max value % of the cooler
        NvU32                       currentLevel;       //the current value % of the cooler
        NV_COOLER_POLICY            defaultPolicy;      //cooler control policy - auto-perf, auto-thermal, manual, hybrid...
        NV_COOLER_POLICY            currentPolicy;      //cooler control policy - auto-perf, auto-thermal, manual, hybrid...
        NV_COOLER_TARGET            target;             //cooling target - GPU, memory, chipset, powersupply, Visual Computing Device...
        NV_COOLER_CONTROL           controlType;        //toggle or variable
        NV_COOLER_ACTIVITY_LEVEL    active;             //is the cooler active - fan spinning...
    } cooler[NVAPI_MAX_COOLERS_PER_GPU_VER1];
} NV_GPU_GETCOOLER_SETTINGS_V1;

typedef struct
{
    NvU32   version;                //structure version
    NvU32   count;                  //number of associated coolers with the selected GPU
    struct
    {
        NV_COOLER_TYPE              type;               //type of cooler - FAN, WATER, LIQUID_NO2...
        NV_COOLER_CONTROLLER        controller;         //internal, ADI...
        NvU32                       defaultMinLevel;    //the min default value % of the cooler
        NvU32                       defaultMaxLevel;    //the max default value % of the cooler
        NvU32                       currentMinLevel;    //the current allowed min value % of the cooler
        NvU32                       currentMaxLevel;    //the current allowed max value % of the cooler
        NvU32                       currentLevel;       //the current value % of the cooler
        NV_COOLER_POLICY            defaultPolicy;      //cooler control policy - auto-perf, auto-thermal, manual, hybrid...
        NV_COOLER_POLICY            currentPolicy;      //cooler control policy - auto-perf, auto-thermal, manual, hybrid...
        NV_COOLER_TARGET            target;             //cooling target - GPU, memory, chipset, powersupply, Visual Computing Device...
        NV_COOLER_CONTROL           controlType;        //toggle or variable
        NV_COOLER_ACTIVITY_LEVEL    active;             //is the cooler active - fan spinning...
    } cooler[NVAPI_MAX_COOLERS_PER_GPU_VER2];
} NV_GPU_GETCOOLER_SETTINGS_V2;


#define NV_GPU_GETCOOLER_SETTINGS           NV_GPU_GETCOOLER_SETTINGS_V2

#define NV_GPU_GETCOOLER_SETTINGS_VER1      MAKE_NVAPI_VERSION(NV_GPU_GETCOOLER_SETTINGS_V1,1)
#define NV_GPU_GETCOOLER_SETTINGS_VER2A     MAKE_NVAPI_VERSION(NV_GPU_GETCOOLER_SETTINGS_V2,1)  // For shipped R180 compatibility
#define NV_GPU_GETCOOLER_SETTINGS_VER2      MAKE_NVAPI_VERSION(NV_GPU_GETCOOLER_SETTINGS_V2,2)

#define NV_GPU_GETCOOLER_SETTINGS_VER       NV_GPU_GETCOOLER_SETTINGS_VER2

typedef struct
{
    NvU32   version;        //structure version
    struct
    {
        NvU32               currentLevel;           //the new value % of the cooler
        NV_COOLER_POLICY    currentPolicy;          //the new cooler control policy - auto-perf, auto-thermal, manual, hybrid...
    } cooler[NVAPI_MAX_COOLERS_PER_GPU_VER1];
} NV_GPU_SETCOOLER_LEVEL_V1;

typedef struct
{
    NvU32   version;        //structure version
    struct
    {
        NvU32               currentLevel;           //the new value % of the cooler
        NV_COOLER_POLICY    currentPolicy;          //the new cooler control policy - auto-perf, auto-thermal, manual, hybrid...
    } cooler[NVAPI_MAX_COOLERS_PER_GPU_VER2];
} NV_GPU_SETCOOLER_LEVEL_V2;

#define NV_GPU_SETCOOLER_LEVEL          NV_GPU_SETCOOLER_LEVEL_V2

#define NV_GPU_SETCOOLER_LEVEL_VER1     MAKE_NVAPI_VERSION(NV_GPU_SETCOOLER_LEVEL_V1,1)
#define NV_GPU_SETCOOLER_LEVEL_VER2     MAKE_NVAPI_VERSION(NV_GPU_SETCOOLER_LEVEL_V2,1)

#define NV_GPU_SETCOOLER_LEVEL_VER      NV_GPU_SETCOOLER_LEVEL_VER2

typedef struct
{
    NvU32               version;        //structure version
    NV_COOLER_POLICY    policy;         //selected policy to update the cooler levels for, example NVAPI_COOLER_POLICY_PERF
    struct
    {
        NvU32 levelId;      // level indicator for a policy
        NvU32 currentLevel; // new cooler level for the selected policy level indicator.
        NvU32 defaultLevel; // default cooler level for the selected policy level indicator.
    } policyCoolerLevel[NVAPI_MAX_COOLER_LEVELS];
} NV_GPU_COOLER_POLICY_TABLE;

#define NV_GPU_COOLER_POLICY_TABLE_VER MAKE_NVAPI_VERSION(NV_GPU_COOLER_POLICY_TABLE,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetCoolerSettings
//
// DESCRIPTION:     Retrieves the cooler information of all coolers or a specific cooler associated with the selected GPU.
//                  Coolers are indexed 0 to NVAPI_MAX_COOLERS_PER_GPU-1.
//                  To retrieve specific cooler info set the coolerIndex to the appropriate cooler index.
//                  To retrieve info for all cooler set coolerIndex to NVAPI_COOLER_TARGET_ALL.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS :     hPhysicalGPU(IN) - GPU selection.
//                  coolerIndex(IN)  - Explicit cooler index selection.
//                  pCoolerInfo(OUT) - Array of cooler settings.
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_INVALID_ARGUMENT - pCoolerInfo is NULL
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the INFO struct is not supported
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetCoolerSettings(NvPhysicalGpuHandle hPhysicalGpu, NvU32 coolerIndex, NV_GPU_GETCOOLER_SETTINGS *pCoolerInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_SetCoolerLevels
//
// DESCRIPTION:     Set the cooler levels for all coolers or a specific cooler associated with the selected GPU.
//                  Coolers are indexed 0 to NVAPI_MAX_COOLERS_PER_GPU-1. Every cooler level with non-zero currentpolicy gets applied.
//                  The new level should be in the range of minlevel and maxlevel retrieved from GetCoolerSettings API or between
//                  and NVAPI_MIN_COOLER_LEVEL to MAX_COOLER_LEVEL.
//                  To set level for a specific cooler set the coolerIndex to the appropriate cooler index.
//                  To set level for all coolers set coolerIndex to NVAPI_COOLER_TARGET_ALL.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// NOTE:            To lock the fan speed independent of the temperature or performance changes set the cooler currentPolicy to
//                  NVAPI_COOLER_POLICY_MANUAL else set it to the current policy retrieved from the GetCoolerSettings API.
// PARAMETERS:      hPhysicalGPU(IN) - GPU selection.
//                  coolerIndex(IN)  - Explicit cooler index selection.
//                  pCoolerLevels(IN) - Updated cooler level and cooler policy.
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_INVALID_ARGUMENT - pCoolerLevels is NULL
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the INFO struct is not supported
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetCoolerLevels(NvPhysicalGpuHandle hPhysicalGpu, NvU32 coolerIndex, NV_GPU_SETCOOLER_LEVEL *pCoolerLevels);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_RestoreCoolerSettings
//
// DESCRIPTION:     Restore the modified cooler settings to NVIDIA defaults.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS:      hPhysicalGPU(IN) - GPU selection.
//                  pCoolerIndex(IN) - Array containing absolute cooler indexes to restore. Pass NULL restore all coolers.
//                  CoolerCount - Number of coolers to restore.
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the INFO struct is not supported
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_RestoreCoolerSettings(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pCoolerIndex, NvU32 coolerCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetCoolerPolicyTable
//
// DESCRIPTION:     Retrieves the table of cooler and policy levels for the selected policy. Supported only for NVAPI_COOLER_POLICY_PERF.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS:      hPhysicalGPU(IN) - GPU selection.
//                  coolerIndex(IN) - cooler index selection.
//                  pCoolerTable(OUT) - Table of policy levels and associated cooler levels.
//                  count(OUT) - Count of the number of valid levels for the selected policy.
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the INFO struct is not supported
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetCoolerPolicyTable(NvPhysicalGpuHandle hPhysicalGpu, NvU32 coolerIndex, NV_GPU_COOLER_POLICY_TABLE *pCoolerTable, NvU32 *count);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_SetCoolerPolicyTable
//
// DESCRIPTION:     Restore the modified cooler settings to NVIDIA defaults. Supported only for NVAPI_COOLER_POLICY_PERF.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS:      hPhysicalGPU(IN) - GPU selection.
//                  coolerIndex(IN) - cooler index selection.
//                  pCoolerTable(IN) - Updated table of policy levels and associated cooler levels. Every non-zero policy level gets updated.
//                  count(IN) - Number of valid levels in the policy table.
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the INFO struct is not supported
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetCoolerPolicyTable(NvPhysicalGpuHandle hPhysicalGpu, NvU32 coolerIndex, NV_GPU_COOLER_POLICY_TABLE *pCoolerTable, NvU32 count);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_RestoreCoolerPolicyTable
//
// DESCRIPTION:     Restores the perf table policy levels to the defaults.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS:      hPhysicalGPU(IN) - GPU selection.
//                  coolerIndex(IN) - cooler index selection.
//                  pCoolerIndex(IN) - Array containing absolute cooler indexes to restore. Pass NULL restore all coolers.
//                  coolerCount - Number of coolers to restore.
//                  policy - restore for the selected policy
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_RestoreCoolerPolicyTable(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pCoolerIndex, NvU32 coolerCount, NV_COOLER_POLICY policy);


#define NV_GPU_PERF_PSTATES_FLAGS_PERFMON_ENABLED        0x00000001
#define NV_GPU_PERF_PSTATES_FLAGS_DYN_PSTATES_CAPABLE    0x00000002
#define NV_GPU_PERF_PSTATES_FLAGS_DYNAMIC_PSTATE_ENABLED 0x00000004

#define NV_GPU_PERF_SET_FORCE_PSTATE_FLAGS_ASYNC       0x00000001

#define NV_GPU_PERF_PSTATE_FLAGS_PCIELIMIT_GEN1       0x00000001
#define NV_GPU_PERF_PSTATE_FLAGS_OVERCLOCKED_TRUE     0x00000002

typedef enum _NV_GPU_PERF_PSTATE_ID
{
    NVAPI_GPU_PERF_PSTATE_P0                = 0,
    NVAPI_GPU_PERF_PSTATE_P1                = 1,
    NVAPI_GPU_PERF_PSTATE_P2                = 2,
    NVAPI_GPU_PERF_PSTATE_P3                = 3,
    NVAPI_GPU_PERF_PSTATE_P8                = 8,
    NVAPI_GPU_PERF_PSTATE_P10               = 10,
    NVAPI_GPU_PERF_PSTATE_P12               = 12,
    NVAPI_GPU_PERF_PSTATE_P15               = 15,
    NVAPI_GPU_PERF_PSTATE_UNDEFINED         = NVAPI_MAX_GPU_PERF_PSTATES,

} NV_GPU_PERF_PSTATE_ID;

typedef enum _NV_GPU_PERF_PSTATE_FALLBACK
{
    NVAPI_GPU_PERF_PSTATE_FALLBACK_RETURN_ERROR = 0,
    NVAPI_GPU_PERF_PSTATE_FALLBACK_HIGHER_PERF  = 1,
    NVAPI_GPU_PERF_PSTATE_FALLBACK_LOWER_PERF   = 2,

} NV_GPU_PERF_PSTATE_FALLBACK;

typedef struct
{
    NvU32   version;
    NvU32   flags;
    NvU32   numPstates;
    NvU32   numClocks;
    NvU32   numVoltages;
    struct
    {
        NV_GPU_PERF_PSTATE_ID   pstateId;
        NvU32                   flags;
        struct
        {
            NV_GPU_CLOCK_DOMAIN_ID domainId;
            NvU32                                flags;
            NvU32                                freq;

        } clocks[NVAPI_MAX_GPU_PERF_CLOCKS];
        struct
        {
            NV_GPU_PERF_VOLTAGE_DOMAIN_ID domainId;
            NvU32                       flags;
            NvU32                       mvolt;

        } voltages[NVAPI_MAX_GPU_PERF_VOLTAGES];

    } pstates[NVAPI_MAX_GPU_PERF_PSTATES];

} NV_GPU_PERF_PSTATES;

#define NV_GPU_PERF_PSTATES_VER  MAKE_NVAPI_VERSION(NV_GPU_PERF_PSTATES,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetPstates
//
// DESCRIPTION:     Retrieves all performance states (P-States) information.
//                  This API is defined for internal usage.  A similar API NvAPI_GPU_GetPstatesInfo is 
//                  provided for NDA users with restricted functions.
//
//                  P-States are GPU active/executing performance capability and power consumption states.
//                  P-States ranges from P0 to P15, with P0 being the highest performance/power state, and
//                  P15 being the lowest performance/power state. Each P-State, if available, maps to a
//                  performance level. Not all P-States are available on a given system. The definition
//                  of each P-States are currently as follow:
//                    P0/P1 - Maximum 3D performance
//                    P2/P3 - Balanced 3D performance-power
//                    P8 - Basic HD video playback
//                    P10 - DVD playback
//                    P12 - Minimum idle power consumption
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS:      hPhysicalGPU(IN)  - GPU selection.
//                  pPerfPstates(OUT) - P-States information retrieved, as detailed below:
//                  - flags containing the following info:
//                      bit 0 indicates if perfmon is enabled or not
//                      bit 1 indicates if dynamic Pstate is capable or not
//                      bit 2 indicates if dynamic Pstate is enable or not
//                  - numPstates is the number of available P-States
//                  - numClocks is the number of clock domains supported by each P-State
//                  - numVoltages is the number of voltage domains supported by each P-State
//                  - pstates has valid index range from 0 to numPstates - 1
//                  - pstates[i].pstateId is the ID of the P-State,
//                      containing the following info:
//                    - pstates[i].flags containing the following info:
//                        bit 0 indicates if the PCIE limit is GEN1 or GEN2
//                        bit 1 indicates if the Pstate is overclocked or not
//                    - pstates[i].clocks has valid index range from 0 to numClocks -1
//                    - pstates[i].clocks[j].domainId is the ID of the clock domain,
//                        containing the following info:
//                      - pstates[i].clocks[j].flags is reserved for future use.
//                      - pstates[i].clocks[j].freq is the clock frequency in kHz
//                    - pstates[i].voltages has valid index range from 0 to numVoltages - 1
//                    - pstates[i].voltages[j].domainId is the ID of the voltage domain,
//                        containing the following info:
//                      - pstates[j].voltages[j].flags is reserved for future use.
//                      - pstates[j].voltages[j].mvolt is the voltage level in milli-volt
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the NV_GPU_PERF_PSTATES struct is not supported
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPstates(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_PERF_PSTATES *pPerfPstates);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_SetPstates
//
// DESCRIPTION:     Sets a subset (from 1 to all) of all performance states (P-States) information.  This 
//                  API is defined for NDA usage.
//
//                  P-States are GPU active/executing performance capability and power consumption states.
//                  P-States ranges from P0 to P15, with P0 being the highest performance/power state, and
//                  P15 being the lowest performance/power state. Each P-State, if available, maps to a
//                  performance level. Not all P-States are available on a given system. The definition
//                  of each P-States are currently as follow:
//                    P0/P1 - Maximum 3D performance
//                    P2/P3 - Balanced 3D performance-power
//                    P8 - Basic HD video playback
//                    P10 - DVD playback
//                    P12 - Minimum idle power consumption
//
//                  The changes this API makes are *not* persistent across a driver unload or reboot.  
//                  Client applications must handle enforcing persistence.  However, client apps should
//                  also be careful not to persist bad pstate configurations across reboots (i.e. if the
//                  bad pstate configuration hangs the chip and the client application always applies that
//                  configuration on boot, the user will never be able to boot and revert those changes
//                  without booting to safe mode).
//
//                  Some important caveats for this API, we will keep this information internal only for 
//                  the present:
//                    a) At present, we can only override the P0 pstate with this function.  For more
//                       information about unlocking this for other pstate (for internal testing only!) 
//                       see documentation of NV2080_CTRL_CMD_PERF_SET_PSTATE_INFO.  Any attempt to 
//                       override pstates below P0 will silently fail: everything will return okay but no
//                       changes will be made.
//                    b) We are unable to change the pstate voltage on pre-Fermi boards.  To enable this
//                       on Tesla dGPUs (for internal testing only!) see documentation of 
//                       NV2080_CTRL_CMD_PERF_SET_PSTATE_INFO.  Any attempt to change the voltage will 
//                       silently fail.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS:      hPhysicalGPU(IN)  - GPU selection.
//                  pPerfPstates(IN) - P-States information retrieved, as detailed below:
//                  - flags is reserved for future use
//                  - numPstates the number of p-states specified
//                  - numClocks is the number of clock domains specified in each p-state.
//                  - numVoltages is the number of voltage domains specified in each p-State
//                  - pstates has valid index range from 0 to numPstates - 1
//                  - pstates[i].pstateId is the ID of the P-State,
//                      containing the following info:
//                    - pstates[i].flags is reserved for future use
//                    - pstates[i].clocks has valid index range from 0 to numClocks -1
//                    - pstates[i].clocks[j].domainId is the ID of the clock domain,
//                        containing the following info:
//                      - pstates[i].clocks[j].flags is reserved for future use.
//                      - pstates[i].clocks[j].freq is the clock frequency in kHz
//                    - pstates[i].voltages has valid index range from 0 to numVoltages - 1
//                    - pstates[i].voltages[j].domainId is the ID of the voltage domain,
//                        containing the following info:
//                      - pstates[j].voltages[j].flags is reserved for future use.
//                      - pstates[j].voltages[j].mvolt is the voltage level in milli-volt
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the NV_GPU_PERF_PSTATES struct is not supported
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetPstates(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_PERF_PSTATES *pPerfPstates);



typedef struct
{
    NvU32   version;
    NvU32   flags;
    NvU32   numPstates;
    NvU32   numClocks;
    struct
    {
        NV_GPU_PERF_PSTATE_ID   pstateId;
        NvU32                   flags;
        struct
        {
            NV_GPU_CLOCK_INFO_DOMAIN_ID domainId;
            NvU32                                flags;
            NvU32                                freq;

        } clocks[NVAPI_MAX_GPU_PERF_CLOCKS];

    } pstates[NVAPI_MAX_GPU_PERF_PSTATES];

} NV_GPU_PERF_PSTATES_INFO_V1;

typedef struct
{
    NvU32   version;
    NvU32   flags;
    NvU32   numPstates;
    NvU32   numClocks;
    NvU32   numVoltages;
    struct
    {
        NV_GPU_PERF_PSTATE_ID   pstateId;
        NvU32                   flags;
        struct
        {
            NV_GPU_CLOCK_INFO_DOMAIN_ID domainId;
            NvU32                                flags;
            NvU32                                freq;

        } clocks[NVAPI_MAX_GPU_PERF_CLOCKS];
        struct
        {
            NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID domainId;
            NvU32                       flags;
            NvU32                       mvolt;

        } voltages[NVAPI_MAX_GPU_PERF_VOLTAGES];

    } pstates[NVAPI_MAX_GPU_PERF_PSTATES];

} NV_GPU_PERF_PSTATES_INFO_V2;

typedef  NV_GPU_PERF_PSTATES_INFO_V2 NV_GPU_PERF_PSTATES_INFO;

#define NV_GPU_PERF_PSTATES_INFO_VER1  MAKE_NVAPI_VERSION(NV_GPU_PERF_PSTATES_INFO_V1,1)
#define NV_GPU_PERF_PSTATES_INFO_VER2  MAKE_NVAPI_VERSION(NV_GPU_PERF_PSTATES_INFO_V2,2)

#define NV_GPU_PERF_PSTATES_INFO_VER   NV_GPU_PERF_PSTATES_INFO_VER2

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetPstatesInfo
//
// DESCRIPTION:     Retrieves all performance states (P-States) information.
//
//                  P-States are GPU active/executing performance capability and power consumption states.
//                  P-States ranges from P0 to P15, with P0 being the highest performance/power state, and
//                  P15 being the lowest performance/power state. Each P-State, if available, maps to a
//                  performance level. Not all P-States are available on a given system. The definition
//                  of each P-States are currently as follow:
//                    P0/P1 - Maximum 3D performance
//                    P2/P3 - Balanced 3D performance-power
//                    P8 - Basic HD video playback
//                    P10 - DVD playback
//                    P12 - Minimum idle power consumption
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS:      hPhysicalGPU(IN)  - GPU selection.
//                  pPerfPstates(OUT) - P-States information retrieved, as detailed below:
//                  - flags is reserved for future use.
//                  - numPstates is the number of available P-States
//                  - numClocks is the number of clock domains supported by each P-State
//                  - pstates has valid index range from 0 to numPstates - 1
//                  - pstates[i].pstateId is the ID of the P-State,
//                      containing the following info:
//                    - pstates[i].flags containing the following info:
//                        bit 0 indicates if the PCIE limit is GEN1 or GEN2
//                        bit 1 indicates if the Pstate is overclocked or not
//                    - pstates[i].clocks has valid index range from 0 to numClocks -1
//                    - pstates[i].clocks[j].domainId is the ID of the clock domain,
//                        containing the following info:
//                      - pstates[i].clocks[j].flags is reserved for future use.
//                      - pstates[i].clocks[j].freq is the clock frequency in kHz
//                    - pstates[i].voltages has a valid index range from 0 to numVoltages - 1
//                    - pstates[i].voltages[j].domainId is the ID of the voltage domain,
//                        containing the following info:
//                      - pstates[i].voltages[j].flags is reserved for future use.
//                      - pstates[i].voltages[j].mvolt is the voltage in mV
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the NV_GPU_PERF_PSTATES struct is not supported
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPstatesInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_PERF_PSTATES_INFO *pPerfPstatesInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_SetPstatesInfo
//
// DESCRIPTION:     Retrieves all performance states (P-States) information.
//
//                  P-States are GPU active/executing performance capability and power consumption states.
//                  P-States ranges from P0 to P15, with P0 being the highest performance/power state, and
//                  P15 being the lowest performance/power state. Each P-State, if available, maps to a
//                  performance level. Not all P-States are available on a given system. The definition
//                  of each P-States are currently as follow:
//                    P0/P1 - Maximum 3D performance
//                    P2/P3 - Balanced 3D performance-power
//                    P8 - Basic HD video playback
//                    P10 - DVD playback
//                    P12 - Minimum idle power consumption
//
//                  The changes this API makes are *not* persistent across a driver unload or reboot.  
//                  Client applications must handle enforcing persistence.  However, client apps should
//                  also be careful not to persist bad pstate configurations across reboots (i.e. if the
//                  bad pstate configuration hangs the chip and the client application always applies that
//                  configuration on boot, the user will never be able to boot and revert those changes
//                  without booting to safe mode).
//
//                  NOTE: This API was introduced starting with NV_GPU_PERF_PSTATES_INFO structure version 
//                  NV_GPU_PERF_PSTATES_INFO_VER2.  This API must be called with structure version 
//                  >= NV_GPU_PERF_PSTATES_INFO_VER2.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS:      hPhysicalGPU(IN)  - GPU selection.
//                  pPerfPstates(IN) - P-States information retrieved, as detailed below:
//                  - flags is reserved for future use.
//                  - numPstates the number of p-states specified
//                  - numClocks is the number of clock domains specified in each p-state.
//                  - numVoltages is the number of voltage domains specified in each p-State
//                  - pstates has valid index range from 0 to numPstates - 1
//                  - pstates[i].pstateId is the ID of the P-State,
//                      containing the following info:
//                    - pstates[i].flags is reserved for future use
//                    - pstates[i].clocks has valid index range from 0 to numClocks -1
//                    - pstates[i].clocks[j].domainId is the ID of the clock domain,
//                        containing the following info:
//                      - pstates[i].clocks[j].flags is reserved for future use.
//                      - pstates[i].clocks[j].freq is the clock frequency in kHz
//                    - pstates[i].voltages has a valid index range from 0 to numVoltages - 1
//                    - pstates[i].voltages[j].domainId is the ID of the voltage domain,
//                        containing the following info:
//                      - pstates[i].voltages[j].flags is reserved for future use.
//                      - pstates[i].voltages[j].mvolt is the voltage in mV
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the NV_GPU_PERF_PSTATES struct is not supported
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetPstatesInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_PERF_PSTATES_INFO *pPerfPstatesInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetCurrentPstate
//
// DESCRIPTION:     Retrieves the current performance state (P-State).
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS:      hPhysicalGPU(IN)    - GPU selection.
//                  pCurrentPstate(OUT) - The ID of the P-State the GPU is currently in.
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_NOT_SUPPORTED - P-States is not supported on this setup
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetCurrentPstate(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_PERF_PSTATE_ID *pCurrentPstate);

typedef enum _NV_PERF_PSTATE_CLIENT_LIMIT_ID
{
    NVAPI_PERF_PSTATE_CLIENT_LIMIT_HARD                 = 0x00000001,       // P-States Hard limit 
    NVAPI_PERF_PSTATE_CLIENT_LIMIT_SOFT                 = 0x00000002,       // P-States Soft limit 
    NVAPI_PERF_PSTATE_CLIENT_LIMIT_BOTH                 = 0x00000003        // For both hard and soft P-States limits
} NV_GPU_PERF_PSTATE_CLIENT_LIMIT_ID;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetPstateClientLimits
//
// DESCRIPTION:     Get soft or hard limit of performance state (P-State)
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS:      hPhysicalGPU(IN)  - GPU selection.
//                  limitId(IN)       - To indicate hard limit or soft limit 
//                  PstateLimit(OUT)  - The ID of the P-State that is the current limit
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_INVALID_ARGUMENT - Invalid input parameter
//    NVAPI_NOT_SUPPORTED - P-States is not supported on this setup
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPstateClientLimits(NvPhysicalGpuHandle hPhysicalGpu,
                                                NV_GPU_PERF_PSTATE_CLIENT_LIMIT_ID limitId,
                                                NV_GPU_PERF_PSTATE_ID* PstateLimit);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_SetPstateClientLimits
//
// DESCRIPTION:     Set soft or hard limit of performance state (P-State)
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS:      hPhysicalGPU(IN)  - GPU selection.
//                  limitId(IN)       - To indicate hard limit, soft limit or both
//                  PstateLimit(IN)   - The ID of the P-State to be the new limit
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_INVALID_ARGUMENT - Invalid input parameter
//    NVAPI_NOT_SUPPORTED - P-States is not supported on this setup
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetPstateClientLimits(NvPhysicalGpuHandle hPhysicalGpu,
                                                NV_GPU_PERF_PSTATE_CLIENT_LIMIT_ID limitId,
                                                NV_GPU_PERF_PSTATE_ID PstateLimit);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_EnableOverclockedPstates
//
// DESCRIPTION:     To allow overclocked P-states 
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS:      hPhysicalGPU(IN)  - GPU selection.
//                  bEnable(IN)       - (boolean) To enable or disable overclocked P-states 
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_INVALID_ARGUMENT - Invalid input parameter
//    NVAPI_NOT_SUPPORTED - P-States or overclocked P-states is not supported on this setup
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_EnableOverclockedPstates(NvPhysicalGpuHandle hPhysicalGpu,
                                                   NvU8 bEnable);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_EnableDynamicPstates
//
// DESCRIPTION:     Enables or Disables Dynamic P-states 
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS:      hPhysicalGPU(IN)  - GPU selection.
//                  bEnable(IN)       - (boolean) To enable or disable Dynamic P-states 
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_INVALID_ARGUMENT - Invalid input parameter
//    NVAPI_NOT_SUPPORTED - P-States is not supported on this setup
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_EnableDynamicPstates(NvPhysicalGpuHandle hPhysicalGpu,
                                               NvU8 bEnable);

#define NVAPI_MAX_GPU_UTILIZATIONS 8

typedef enum _NV_GPU_UTILIZATION_DOMAIN_ID
{
    NVAPI_GPU_UTILIZATION_DOMAIN_GPU    = 0,
    NVAPI_GPU_UTILIZATION_DOMAIN_FB     = 1,
    NVAPI_GPU_UTILIZATION_DOMAIN_VID    = 2,
} NV_GPU_UTILIZATION_DOMAIN_ID;

typedef struct
{
    NvU32       version;        // Structure version
    NvU32       flags;          // Reserved for future use
    struct
    {
        NvU32   bIsPresent:1;   // Set if this utilization domain is present on this GPU
        NvU32   percentage;     // Percentage of time where the domain is considered busy in the last 1 second interval
        NvU32   incThreshold;   // Utilization threshold that can trigger a perf-increasing P-State change when crossed
        NvU32   decThreshold;   // Utilization threshold that can trigger a perf-decreasing P-State change when crossed
    } utilization[NVAPI_MAX_GPU_UTILIZATIONS];
} NV_GPU_DYNAMIC_PSTATES_INFO;
#define NV_GPU_DYNAMIC_PSTATES_INFO_VER MAKE_NVAPI_VERSION(NV_GPU_DYNAMIC_PSTATES_INFO,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetDynamicPstatesInfo
//
// DESCRIPTION:   This retrieves the NV_GPU_DYNAMIC_PSTATES_INFO structure for the specified physical GPU.
//                    flags is reserved for future use
//                    For each utilization domain:
//                        bIsPresent is set for each domain that is present on the GPU
//                        percentage is the percentage of time where the domain is considered busy in the last 1 second interval
//                        incThreshold is utilization threshold that can trigger a perf-increasing P-State change when crossed
//                        decThreshold is utilization threshold that can trigger a perf-decreasing P-State change when crossed
//
//                Each domain's info is indexed in the array.  For example:
//                    pDynamicPstatesInfo->utilization[NVAPI_GPU_UTILIZATION_DOMAIN_GPU] holds the info for the GPU domain
//                There are currently 3 domains, for which GPU utilization and dynamic P-State thresholds can be retrieved
//                    graphic engine (GPU), frame buffer (FB), and video engine (VID).
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_INVALID_ARGUMENT - pDynamicPstatesInfo is NULL
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the INFO struct is not supported
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetDynamicPstatesInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_DYNAMIC_PSTATES_INFO *pDynamicPstatesInfo);

typedef struct
{
    NvU32       version;        // Structure version
    NvU32       flags;          // Reserved for future use
    struct
    {
        NvU32   bIsPresent:1;   // Set if this utilization domain is present on this GPU
        NvU32   percentage;     // Percentage of time where the domain is considered busy in the last 1 second interval
    } utilization[NVAPI_MAX_GPU_UTILIZATIONS];
} NV_GPU_DYNAMIC_PSTATES_INFO_EX;
#define NV_GPU_DYNAMIC_PSTATES_INFO_EX_VER MAKE_NVAPI_VERSION(NV_GPU_DYNAMIC_PSTATES_INFO_EX,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetDynamicPstatesInfoEx
//
// DESCRIPTION:   This retrieves the NV_GPU_DYNAMIC_PSTATES_INFO_EX structure for the specified physical GPU.
//                    flags contains following information:
//                      bit 0 indicates if the dynamic Pstate is enabled or not
//                    For each utilization domain:
//                        bIsPresent is set for each domain that is present on the GPU
//                        percentage is the percentage of time where the domain is considered busy in the last 1 second interval
//
//                Each domain's info is indexed in the array.  For example:
//                    pDynamicPstatesInfo->utilization[NVAPI_GPU_UTILIZATION_DOMAIN_GPU] holds the info for the GPU domain
//                There are currently 3 domains, for which GPU utilization and dynamic P-State thresholds can be retrieved
//                    graphic engine (GPU), frame buffer (FB), and video engine (VID).
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_INVALID_ARGUMENT - pDynamicPstatesInfo is NULL
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the INFO struct is not supported
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetDynamicPstatesInfoEx(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_DYNAMIC_PSTATES_INFO_EX *pDynamicPstatesInfoEx);


#define NVAPI_MAX_GPU_PERF_DOMAIN_VOLTAGES   128

typedef struct
{
    NvU32   version;
    NvU32   flags;
    NvU32   numDomains;

    struct
    {
        NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID domainId;
        NvU32                              flags;
        NvU32                              numVoltages;
        struct
        {
            NvU32                       flags;
            NvU32                       mvolt;
        } voltages[NVAPI_MAX_GPU_PERF_DOMAIN_VOLTAGES];
    } domains[NVAPI_MAX_GPU_PERF_VOLTAGES];

} NV_GPU_PERF_VOLTAGES;

#define NV_GPU_PERF_VOLTAGES_VER  MAKE_NVAPI_VERSION(NV_GPU_PERF_VOLTAGES,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetVoltages
//
// DESCRIPTION:     Returns the supported voltage levels for each supported voltage domain on the board.
//                  These are the valid voltage levels which can be used for NvAPI_GPU_SetPstates() and
//                  NvAPI_GPU_SetPstatesInfo().
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS:      hPhysicalGPU(IN)  - GPU selection.
//                  pPerfVoltages(OUT) - Voltage information retrieved, as detailed below:
//                  - flags - currently unsupported
//                  - numDomains - the number of voltage domains supported on the board
//                  - domains - valid index range from 0 to numDomains - 1
//                    - domains[i].domainId - the ID of the voltage domain
//                    - domains[i].flags - currently unsupported
//                    - domains[i].numVoltages - number of voltage levels defined for this domain
//                    - domains[i].voltages -  valid index range from 0 to domains[i].numVoltages - 1
//                      - domains[i].voltages[j].flags - currently unsupported
//                      - domains[i].voltages[j].mvolt - voltage in mV
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the NV_GPU_PERF_PSTATES struct is not supported
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetVoltages(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_PERF_VOLTAGES *pPerfVoltages);


///////////////////////////////////////////////////////////////////////////////////
//  Thermal API
//  Provides ability to get temperature levels from the various thermal sensors associated with the GPU

#define NVAPI_MAX_THERMAL_SENSORS_PER_GPU 3

typedef enum
{
    NVAPI_THERMAL_TARGET_NONE          = 0,
    NVAPI_THERMAL_TARGET_GPU           = 1,     //GPU core temperature requires NvPhysicalGpuHandle
    NVAPI_THERMAL_TARGET_MEMORY        = 2,     //GPU memory temperature requires NvPhysicalGpuHandle
    NVAPI_THERMAL_TARGET_POWER_SUPPLY  = 4,     //GPU power supply temperature requires NvPhysicalGpuHandle
    NVAPI_THERMAL_TARGET_BOARD         = 8,     //GPU board ambient temperature requires NvPhysicalGpuHandle
    NVAPI_THERMAL_TARGET_VCD_BOARD     = 9,     //Visual Computing Device Board temperature requires NvVisualComputingDeviceHandle
    NVAPI_THERMAL_TARGET_VCD_INLET     = 10,    //Visual Computing Device Inlet temperature requires NvVisualComputingDeviceHandle
    NVAPI_THERMAL_TARGET_VCD_OUTLET    = 11,    //Visual Computing Device Outlet temperature requires NvVisualComputingDeviceHandle
    NVAPI_THERMAL_TARGET_ALL           = 15,
    NVAPI_THERMAL_TARGET_UNKNOWN       = -1,
} NV_THERMAL_TARGET;

typedef enum
{
    NVAPI_THERMAL_CONTROLLER_NONE = 0,
    NVAPI_THERMAL_CONTROLLER_GPU_INTERNAL,
    NVAPI_THERMAL_CONTROLLER_ADM1032,
    NVAPI_THERMAL_CONTROLLER_MAX6649,
    NVAPI_THERMAL_CONTROLLER_MAX1617,
    NVAPI_THERMAL_CONTROLLER_LM99,
    NVAPI_THERMAL_CONTROLLER_LM89,
    NVAPI_THERMAL_CONTROLLER_LM64,
    NVAPI_THERMAL_CONTROLLER_ADT7473,
    NVAPI_THERMAL_CONTROLLER_SBMAX6649,
    NVAPI_THERMAL_CONTROLLER_VBIOSEVT,
    NVAPI_THERMAL_CONTROLLER_OS,
    NVAPI_THERMAL_CONTROLLER_UNKNOWN = -1,
} NV_THERMAL_CONTROLLER;

typedef struct
{
    NvU32   version;                //structure version
    NvU32   count;                  //number of associated thermal sensors
    struct
    {
        NV_THERMAL_CONTROLLER       controller;         //internal, ADM1032, MAX6649...
        NvU32                       defaultMinTemp;     //the min default temperature value of the thermal sensor in degrees centigrade
        NvU32                       defaultMaxTemp;    //the max default temperature value of the thermal sensor in degrees centigrade
        NvU32                       currentTemp;       //the current temperature value of the thermal sensor in degrees centigrade
        NV_THERMAL_TARGET           target;             //thermal senor targeted @ GPU, memory, chipset, powersupply, Visual Computing Device...
    } sensor[NVAPI_MAX_THERMAL_SENSORS_PER_GPU];

} NV_GPU_THERMAL_SETTINGS;

#define NV_GPU_THERMAL_SETTINGS_VER  MAKE_NVAPI_VERSION(NV_GPU_THERMAL_SETTINGS,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetThermalSettings
//
// DESCRIPTION:     Retrieves the thermal information of all thermal sensors or specific thermal sensor associated with the selected GPU.
//                  Thermal sensors are indexed 0 to NVAPI_MAX_THERMAL_SENSORS_PER_GPU-1.
//                  To retrieve specific thermal sensor info set the sensorIndex to the required thermal sensor index.
//                  To retrieve info for all sensors set sensorIndex to NVAPI_THERMAL_TARGET_ALL.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS :     hPhysicalGPU(IN) - GPU selection.
//                  sensorIndex(IN)  - Explicit thermal sensor index selection.
//                  pThermalSettings(OUT) - Array of thermal settings.
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_INVALID_ARGUMENT - pThermalInfo is NULL
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the INFO struct is not supported
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetThermalSettings(NvPhysicalGpuHandle hPhysicalGpu, NvU32 sensorIndex, NV_GPU_THERMAL_SETTINGS *pThermalSettings);


// ====================================================
// Thermal slowdown status
// ====================================================

typedef enum
{
    NVAPI_GPU_THERMAL_SLOWDOWN_ENABLED                = 0x0000,         // thermal slowdown mechanisms enabled
    NVAPI_GPU_THERMAL_SLOWDOWN_DISABLED_ALL           = 0xFFFF,         // all thermal slowdown mechanisms disabled (HW, SW, Pstate)
} NV_GPU_THERMAL_SLOWDOWN;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_SetThermalSlowdownState
//
// DESCRIPTION:     Disables/enables thermal slowdown for particular GPU.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS :     slowdownState(IN) - Slowdown state, currently NONE/ALL.
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_INVALID_ARGUMENT - slowdownState unsupported
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetThermalSlowdownState(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_THERMAL_SLOWDOWN slowdownState);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetThermalSlowdownState
//
// DESCRIPTION:     Retreives the thermal slowdown information for particular GPU.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS :     slowdownState(OUT) - Slowdown state, currently NONE/ALL.
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_INVALID_ARGUMENT - NULL pointer passed (slowdownState)
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetThermalSlowdownState(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_THERMAL_SLOWDOWN *slowdownState);


// ====================================================
// Thermal simulation mode
// ====================================================

typedef enum
{
    NVAPI_GPU_THERMAL_SIMULATION_DISABLED               = 0x0000,
    NVAPI_GPU_THERMAL_SIMULATION_ENABLED                = 0x0001,
} NV_GPU_THERMAL_SIMULATION_MODE;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_SetThermalSimulationMode
//
// DESCRIPTION:     Disables/enables thermal simulation mode.
//                  This NvAPI call allows to fake temperature of an existing
//                  thermal sensor. Once we enable thermal simulation mode,
//                  all readings of particualr sensor will be constant value
//                  (simulated temperature). Disabling this feature will return
//                  thermal sensor to original state.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS :     sensor(IN) - affected sensor
//                  tempSimMode(IN) - turning ON/OFF temp. simulation mode
//                  temperature(IN) - simulated temperature (0 <= temp <= 255 deg Celsius)
//                                    (unused if tempSimMode is _DISABLED)
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_INVALID_ARGUMENT - temperature is out of range
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_NOT_SUPPORTED - Thermal simulation is not supported
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetThermalSimulationMode(NvPhysicalGpuHandle hPhysicalGpu, NvU32 sensor, NV_GPU_THERMAL_SIMULATION_MODE tempSimMode, NvU32 temperature);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetThermalSimulationMode
//
// DESCRIPTION:     Retreives the thermal simulation mode.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS :     sensor(IN) - sensor
//                  tempSimMode(OUT) - temperature simulation mode
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_INVALID_ARGUMENT - NULL pointer passed (tempSimMode)
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_NOT_SUPPORTED - Thermal simulation is not supported
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetThermalSimulationMode(NvPhysicalGpuHandle hPhysicalGpu, NvU32 sensor, NV_GPU_THERMAL_SIMULATION_MODE *tempSimMode);

typedef enum _NVAPI_DITHER_TYPE
{
    NVAPI_DITHER_TYPE_DEFAULT = 0,  // enable/disable based on the default behavior
    NVAPI_DITHER_TYPE_ENABLE  = 1,  // enable dithering
    NVAPI_DITHER_TYPE_DISABLE = 2,  // disable dithering
} NVAPI_DITHER_TYPE;

typedef enum _NVAPI_DITHER_BITS
{
    NVAPI_DITHER_BITS_6BITS = 0,
    NVAPI_DITHER_BITS_8BITS = 1,
} NVAPI_DITHER_BITS;

typedef enum _NVAPI_DITHER_MODE
{
    NVAPI_DITHER_MODE_DYNAMIC_ERR_ACC = 0,
    NVAPI_DITHER_MODE_STATIC_ERR_ACC  = 1,
    NVAPI_DITHER_MODE_DYNAMIC_2X2     = 2,
    NVAPI_DITHER_MODE_STATIC_2X2      = 3,
} NVAPI_DITHER_MODE;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_SetDitherControl
//
// DESCRIPTION: Sets display related HW dither controls (dithering a higher bpp framebuffer to a lower bpp display)
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:    outputId(IN)   - One of the selected outputId retrieved from NvAPI_GPU_GetActiveOutputs or
//                                 NvAPI_GetView, to identify the targeted TV.
//                type(IN)       - The dithering mode to apply (default, enable, or disable)
//                bits(IN)       - The bits to dither to
//                mode(IN)       - The dither mode
//
// RETURN STATUS:
//    NVAPI_OK - Dither controls successfully set.
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle.
//    NVAPI_INVALID_ARGUMENT - Parameters passed do not match the hardware implementation
//    NVAPI_NOT_SUPPORTED - Dither control feature is not supported on the selected GPU
//    NVAPI_NO_IMPLEMENTATION - No implementation for dither controls implemented for this GPU
//    NVAPI_ERROR - Dither controls were not successfully propogated
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetDitherControl(NvPhysicalGpuHandle hPhysicalGpu,
                                           NvU32 outputId,
                                           NVAPI_DITHER_TYPE type,
                                           NVAPI_DITHER_BITS bits,
                                           NVAPI_DITHER_MODE mode);


typedef enum _NV_TV_ENCODER_TYPE
{
    NV_ENCODER_TYPE_UNKNOWN         = 0,

    NV_ENCODER_TYPE_BROOKTREE_868   = 1,
    NV_ENCODER_TYPE_BROOKTREE_869   = 2,
    NV_ENCODER_TYPE_BROOKTREE_871   = 3,
    NV_ENCODER_TYPE_BROOKTREE_870   = 4,
    NV_ENCODER_TYPE_BROOKTREE_872   = 5,
    NV_ENCODER_TYPE_BROOKTREE_873   = 6,
    NV_ENCODER_TYPE_BROOKTREE_874   = 7,
    NV_ENCODER_TYPE_BROOKTREE_875   = 8,
    NV_ENCODER_TYPE_BROOKTREE_890   = 9,
    NV_ENCODER_TYPE_BROOKTREE_891   = 10,
    NV_ENCODER_TYPE_BROOKTREE_892   = 11,

    NV_ENCODER_TYPE_CHRONTEL_7003   = 12,
    NV_ENCODER_TYPE_CHRONTEL_7004   = 13,
    NV_ENCODER_TYPE_CHRONTEL_7005   = 14,
    NV_ENCODER_TYPE_CHRONTEL_7006   = 15,
    NV_ENCODER_TYPE_CHRONTEL_7007   = 16,
    NV_ENCODER_TYPE_CHRONTEL_7008   = 17,
    NV_ENCODER_TYPE_CHRONTEL_7009   = 18,
    NV_ENCODER_TYPE_CHRONTEL_7010   = 19,
    NV_ENCODER_TYPE_CHRONTEL_7011   = 20,
    NV_ENCODER_TYPE_CHRONTEL_7012   = 21,
    NV_ENCODER_TYPE_CHRONTEL_7019   = 22,
    NV_ENCODER_TYPE_CHRONTEL_7021   = 23,
    NV_ENCODER_TYPE_CHRONTEL_7301   = 24,

    NV_ENCODER_TYPE_PHILIPS_7102    = 25,
    NV_ENCODER_TYPE_PHILIPS_7103    = 26,
    NV_ENCODER_TYPE_PHILIPS_7108    = 27,
    NV_ENCODER_TYPE_PHILIPS_7109    = 28,
    NV_ENCODER_TYPE_PHILIPS_7108B   = 29,
    NV_ENCODER_TYPE_PHILIPS_7108A   = 30,
    NV_ENCODER_TYPE_PHILIPS_7109A   = 31,
    NV_ENCODER_TYPE_PHILIPS_7104    = 32,
    NV_ENCODER_TYPE_PHILIPS_7105    = 33,

    NV_ENCODER_TYPE_NVIDIA_TV17     = 34,
    NV_ENCODER_TYPE_NVIDIA_MV17     = 35,
    NV_ENCODER_TYPE_NVIDIA_MV36     = 36,
    NV_ENCODER_TYPE_NVIDIA_G80      = 37,

} NV_TV_ENCODER_TYPE;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetTvEncoderType
//
//   DESCRIPTION: Retrieves the TV encoder type associated with the specifed GPU handle.
//                The output id be 0 to retrieve encoder info.
//                The output id can be the outputId of type NVAPI_GPU_OUTPUT_TV if the query for a specific encoder in case of a multi-encoder board.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_OK: call successful.
//                NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//                NVAPI_INVALID_ARGUMENT: pEncoderType is NULL
//                NVAPI_EXPECTED_TV_DISPLAY: expected TV output display in outputId.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetTvEncoderType(NvPhysicalGpuHandle hPhysicalGpu, NvU32 outputId, NV_TV_ENCODER_TYPE *pEncoderType);

////////////////////////////////////////////////////////////////////////////////
//NvAPI_TVOutput Information

typedef enum _NV_DISPLAY_TV_FORMAT
{
    NV_DISPLAY_TV_FORMAT_NONE         = 0,
    NV_DISPLAY_TV_FORMAT_SD_NTSCM     = 0x00000001,
    NV_DISPLAY_TV_FORMAT_SD_NTSCJ     = 0x00000002,
    NV_DISPLAY_TV_FORMAT_SD_PALM      = 0x00000004,
    NV_DISPLAY_TV_FORMAT_SD_PALBDGH   = 0x00000008,
    NV_DISPLAY_TV_FORMAT_SD_PALN      = 0x00000010,
    NV_DISPLAY_TV_FORMAT_SD_PALNC     = 0x00000020,
    NV_DISPLAY_TV_FORMAT_SD_576i      = 0x00000100,
    NV_DISPLAY_TV_FORMAT_SD_480i      = 0x00000200,
    NV_DISPLAY_TV_FORMAT_ED_480p      = 0x00000400,
    NV_DISPLAY_TV_FORMAT_ED_576p      = 0x00000800,
    NV_DISPLAY_TV_FORMAT_HD_720p      = 0x00001000,
    NV_DISPLAY_TV_FORMAT_HD_1080i     = 0x00002000,
    NV_DISPLAY_TV_FORMAT_HD_1080p     = 0x00004000,
    NV_DISPLAY_TV_FORMAT_HD_720p50    = 0x00008000,
    NV_DISPLAY_TV_FORMAT_HD_1080p24   = 0x00010000,
    NV_DISPLAY_TV_FORMAT_HD_1080i50   = 0x00020000,
    NV_DISPLAY_TV_FORMAT_HD_1080p50   = 0x00040000,

    NV_DISPLAY_TV_FORMAT_SD_OTHER     = 0x01000000,
    NV_DISPLAY_TV_FORMAT_ED_OTHER     = 0x02000000,
    NV_DISPLAY_TV_FORMAT_HD_OTHER     = 0x04000000,

    NV_DISPLAY_TV_FORMAT_ANY          = 0x80000000,

} NV_DISPLAY_TV_FORMAT;


typedef struct
{
    NvU32                   version;                            //[IN]       Structure version.
    NvU32                   supportedFormats;                   //[OUT only] One or more TV formats defined in NV_DISPLAY_TV_FORMAT matching, encoder supported formats for analog TVs or EDID exposed modes for digital TVs.
    NV_DISPLAY_TV_FORMAT    currentFormat;                      //[IN/OUT]   One of the selected TV output format from supportedFormats defined in NV_DISPLAY_TV_FORMAT.
    NV_GPU_CONNECTOR_TYPE   currentConnector;                   //[IN/OUT]   For Analog TV, valid TV output connector is one of the NVAPI_GPU_CONNECTOR_TV types.
                                                                //           For Digital TV, valid TV output connector is one of the NVAPI_GPU_CONNECTOR_DVI types.
} NV_DISPLAY_TV_OUTPUT_INFO;

#define NV_DISPLAY_TV_OUTPUT_INFO_VER MAKE_NVAPI_VERSION(NV_DISPLAY_TV_OUTPUT_INFO, 1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetTVOutputInfo
//
//   DESCRIPTION: Retrieves the TV display output information of the selected display.
//
//  SUPPORTED OS: Windows Vista and higher
//
//    PARAMETERS: hNvDisplay(IN)    - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                outputId(IN)      - One of the selected outputId retrieved from NvAPI_GPU_GetActiveOutputs or NvAPI_GetView, to identify the targeted TV.
//                                    Can be NULL to auto pick the TV output associated with hNvDisplay.
//                                    The outputId has to be of type NVAPI_GPU_OUTPUT_TV or NVAPI_GPU_OUTPUT_DFP in case of digital HDTV.
//                pTVOutInfo(OUT)  -  The returned TV output information.
//                                    With digital HDTV, the supportedFormats are limited to the available EIA-861B modes in the EDID
//                                    or the custom 861B modes if added by the user.
//
// RETURN STATUS: NVAPI_OK: call successful.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found.
//                NVAPI_EXPECTED_DISPLAY_HANDLE: hNvDisplay is not a valid display handle.
//                NVAPI_INVALID_ARGUMENT: pTVOutInfo is NULL.
//                NVAPI_INCOMPATIBLE_STRUCT_VERSION: the version of the NV_DISPLAY_TV_OUTPUT_INFO_VER struct is not supported.
//                NVAPI_EXPECTED_TV_DISPLAY: expected TV output display in outputId.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetTVOutputInfo(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_DISPLAY_TV_OUTPUT_INFO *pTVOutInfo);


typedef struct
{
    NvU32   version;                //IN version info

    struct
    {
        NvU32   defaultLevel;       //OUT default level
        NvU32   currentLevel;       //IN/OUT current level
        NvU32   minLevel;           //OUT min range level
        NvU32   maxLevel;           //OUT max range level
    }   flicker, saturation;

} NV_TV_ENCODER_CONTROLS;

#define NV_TV_ENCODER_CONTROLS_VER  MAKE_NVAPI_VERSION(NV_TV_ENCODER_CONTROLS,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetTVEncoderControls
//
//   DESCRIPTION: Retrieves the flicker and saturation levels for the selected TV.
//
//  SUPPORTED OS: Windows Vista and higher
//
//    PARAMETERS: hNvDisplay(IN) - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                outputId(IN)   - One of the selected outputId retrieved from NvAPI_GPU_GetActiveOutputs or NvAPI_GetView, to identify the target
//                                 output in case multiple targets are associated with the selected hNvDisplay.
//                                 Can be NULL to pick the display output id associated with hNvDisplay.
//                pTvEncoderInfo(OUT)  - The returned TV encoder controls and its levels.
//                Note: If maxLevel and minLevel are both zeros then that control is not supported on this GPU and should not be used.
//
// RETURN STATUS: NVAPI_OK: call successful.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found.
//                NVAPI_EXPECTED_DISPLAY_HANDLE: hNvDisplay is not a valid display handle.
//                NVAPI_INVALID_ARGUMENT: pTvEncoderInfo is NULL.
//                NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the NV_TV_ENCODER_CONTROLS struct is not supported
//                NVAPI_NOT_SUPPORTED - TV or this API is not supported on the selected GPU
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetTVEncoderControls(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_TV_ENCODER_CONTROLS *pTvEncoderInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SetTVEncoderControls
//
//   DESCRIPTION: Sets the flicker and saturation levels for the selected TV.
//
//  SUPPORTED OS: Windows Vista and higher
//
//    PARAMETERS: hNvDisplay(IN) - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                outputId(IN)   - One of the selected outputId retrieved from NvAPI_GPU_GetActiveOutputs or NvAPI_GetView, to identify the target
//                                 output in case multiple targets are associated with the selected hNvDisplay.
//                                 Can be NULL to pick the display output id associated with hNvDisplay.
//                pTvEncoderInfo(IN)  - The selected TV encoder levels gets applied.
//
// RETURN STATUS: NVAPI_OK: call successful.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found.
//                NVAPI_EXPECTED_DISPLAY_HANDLE: hNvDisplay is not a valid display handle.
//                NVAPI_INVALID_ARGUMENT: pTvEncoderInfo is NULL.
//                NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the NV_TV_ENCODER_CONTROLS struct is not supported
//                NVAPI_NOT_SUPPORTED - TV or this API is not supported on the selected GPU
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetTVEncoderControls(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_TV_ENCODER_CONTROLS *pTvEncoderInfo);

typedef enum
{
    NV_TV_BORDER_COLOR_BLACK    = 0,
    NV_TV_BORDER_COLOR_GREY     = 1,
} NV_TV_BORDER_COLOR;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetTVOutputBorderColor
//
//   DESCRIPTION: Retrieves the color of the TV border.
//
//  SUPPORTED OS: Windows Vista and higher
//
//    PARAMETERS: hNvDisplay(IN) - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                outputId(IN)   - One of the selected outputId retrieved from NvAPI_GPU_GetActiveOutputs or NvAPI_GetView, to identify the target
//                                 output in case multiple targets are associated with the selected hNvDisplay.
//                                 Can be NULL to pick the display output id associated with hNvDisplay.
//                pBorderColor(OUT)  - The returned TV border color.
//
// RETURN STATUS: NVAPI_OK: call successful.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found.
//                NVAPI_EXPECTED_DISPLAY_HANDLE: hNvDisplay is not a valid display handle.
//                NVAPI_INVALID_ARGUMENT: pBorderColor is NULL.
//                NVAPI_NOT_SUPPORTED - TV or this API is not supported on the selected GPU
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetTVOutputBorderColor(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_TV_BORDER_COLOR *pBorderColor);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SetTVOutputBorderColor
//
//   DESCRIPTION: Sets the color of the TV border.
//
//  SUPPORTED OS: Windows Vista and higher
//
//    PARAMETERS: hNvDisplay(IN) - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                outputId(IN)   - One of the selected outputId retrieved from NvAPI_GPU_GetActiveOutputs or NvAPI_GetView, to identify the target
//                                 output in case multiple targets are associated with the selected hNvDisplay.
//                                 Can be NULL to pick the display output id associated with hNvDisplay.
//                borderColor(IN)  - The TV border color to set.
//
// RETURN STATUS: NVAPI_OK: call successful.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found.
//                NVAPI_EXPECTED_DISPLAY_HANDLE: hNvDisplay is not a valid display handle.
//                NVAPI_NOT_SUPPORTED - TV or this API is not supported on the selected GPU
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetTVOutputBorderColor(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_TV_BORDER_COLOR borderColor);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetDisplayPosition
//
//   DESCRIPTION: Retrieves the display position of the associated analog display.
//
//  SUPPORTED OS: Windows Vista and higher
//
//    PARAMETERS: hNvDisplay(IN) - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                outputId(IN)   - One of the selected outputId retrieved from NvAPI_GPU_GetActiveOutputs or NvAPI_GetView, to identify the target
//                                 output in case multiple targets are associated with the selected hNvDisplay.
//                                 Can be NULL to pick the display output id associated with hNvDisplay.
//                pXOffset and pYOffset(OUT)  - The returned display position Offsets.
//
// RETURN STATUS: NVAPI_OK: call successful.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found.
//                NVAPI_EXPECTED_DISPLAY_HANDLE: hNvDisplay is not a valid display handle.
//                NVAPI_INVALID_ARGUMENT: pBorderColor is NULL.
//                NVAPI_NOT_SUPPORTED - This API is not supported.
//                NVAPI_EXPECTED_ANALOG_DISPLAY - Selected display is not an analog display.
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetDisplayPosition(NvDisplayHandle hNvDisplay, NvU32 outputId, NvU32 *pXOffset, NvU32 *pYOffset);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SetDisplayPosition
//
//   DESCRIPTION: Sets the display position of the associated analog display.
//
//  SUPPORTED OS: Windows Vista and higher
//
//    PARAMETERS: hNvDisplay(IN) - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                outputId(IN)   - One of the selected outputId retrieved from NvAPI_GPU_GetActiveOutputs or NvAPI_GetView, to identify the target
//                                 output in case multiple targets are associated with the selected hNvDisplay.
//                                 Can be NULL to pick the display output id associated with hNvDisplay.
//                xOffset and yOffset(IN)  - The set display position Offsets.
//
// RETURN STATUS: NVAPI_OK: call successful.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found.
//                NVAPI_EXPECTED_DISPLAY_HANDLE: hNvDisplay is not a valid display handle.
//                NVAPI_NOT_SUPPORTED - This API is not supported.
//                NVAPI_EXPECTED_ANALOG_DISPLAY - Selected display is not an analog display.
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetDisplayPosition(NvDisplayHandle hNvDisplay, NvU32 outputId, NvU32 xOffset, NvU32 yOffset);

///////////////////////////////////////////////////////////////////////////////////
//  GPU topology reconfiguration APIs.
//  Provides ability to define one or more SLI devices and standalone GPU topology.
//
//  NV_GPU_TOPOLOGY - this structure defines a set of all GPUs present in a system.  All GPUs with
//  the same parentNdx value describe a single logical GPU.  GPUs that have a unique parentNdx
//  represent standalone GPUs.
//
//  The values returned in parentNdx are arbitrary.  They are only used to determine which
//  physical GPUs will belong to the same logical-GPU.
//

typedef enum
{
    NV_GPU_TOPOLOGY_STATUS_OK                       = 0x00000000,//SLI is capable, topology "status" field indicates this state.
    NV_GPU_TOPOLOGY_STATUS_INVALID_GPU_COUNT        = 0x00000001,//SLI is NOT capable, "pStatus" param in NvAPI_GetValidGpuTopologies indicates these states.
    NV_GPU_TOPOLOGY_STATUS_OS_NOT_SUPPORTED         = 0x00000002,
    NV_GPU_TOPOLOGY_STATUS_OS_ERROR                 = 0x00000004,
    NV_GPU_TOPOLOGY_STATUS_NO_VIDLINK               = 0x00000008,
    NV_GPU_TOPOLOGY_STATUS_INSUFFICIENT_LINK_WIDTH  = 0x00000010,
    NV_GPU_TOPOLOGY_STATUS_CPU_NOT_SUPPORTED        = 0x00000020,
    NV_GPU_TOPOLOGY_STATUS_GPU_NOT_SUPPORTED        = 0x00000040,
    NV_GPU_TOPOLOGY_STATUS_BUS_NOT_SUPPORTED        = 0x00000080,
    NV_GPU_TOPOLOGY_STATUS_NON_APPROVED_CHIPSET     = 0x00000100,
    NV_GPU_TOPOLOGY_STATUS_VBIOS_NOT_SUPPORTED      = 0x00000200,
    NV_GPU_TOPOLOGY_STATUS_GPU_MISMATCH             = 0x00000400,
    NV_GPU_TOPOLOGY_STATUS_ARCH_MISMATCH            = 0x00000800,
    NV_GPU_TOPOLOGY_STATUS_IMPL_MISMATCH            = 0x00001000,
    NV_GPU_TOPOLOGY_STATUS_REV_MISMATCH             = 0x00002000,
    NV_GPU_TOPOLOGY_STATUS_NON_PCIE_BUS             = 0x00004000,
    NV_GPU_TOPOLOGY_STATUS_FB_MISMATCH              = 0x00008000,
    NV_GPU_TOPOLOGY_STATUS_VBIOS_MISMATCH           = 0x00010000,
    NV_GPU_TOPOLOGY_STATUS_QUADRO_MISMATCH          = 0x00020000,
    NV_GPU_TOPOLOGY_STATUS_BUS_TOPOLOGY_ERROR       = 0x00040000,
    NV_GPU_TOPOLOGY_STATUS_PCI_ID_MISMATCH          = 0x00080000,
    NV_GPU_TOPOLOGY_STATUS_CONFIGSPACE_ACCESS_ERROR = 0x00100000,
    NV_GPU_TOPOLOGY_STATUS_INCONSISTENT_CONFIG_SPACE= 0x00200000,
    NV_GPU_TOPOLOGY_STATUS_CONFIG_NOT_SUPPORTED     = 0x00400000,
    NV_GPU_TOPOLOGY_STATUS_RM_NOT_SUPPORTED         = 0x00800000,
    NV_GPU_TOPOLOGY_STATUS_TOPOLOGY_NOT_ALLOWED     = 0x01000000,
    NV_GPU_TOPOLOGY_STATUS_MOBILE_MISMATCH          = 0x02000000,// The system has a mix of notebook and desktop GPUs
    NV_GPU_TOPOLOGY_STATUS_NO_TOPOLOGIES_IN_HYBRID_POWER_MODE = 0x04000000,
} NV_GPU_TOPOLOGY_STATUS_FLAGS;


typedef enum
{
    NV_SET_GPU_TOPOLOGY_DEFER_APPLY                 = 0x00000001,//calling application controls the reload of the display driver
    NV_SET_GPU_TOPOLOGY_DEFER_3D_APP_SHUTDOWN       = 0x00000002,//calling application will control the shutdown of non-migratable applications holding hw resources
    NV_SET_GPU_TOPOLOGY_DEFER_DISPLAY_RECONFIG      = 0x00000004,//calling application will control the display configuration required for the settopology to work
    NV_SET_GPU_TOPOLOGY_RELOAD_DRIVER               = 0x80000000,//calling application requesting force reload given correct topology.
} NV_SET_GPU_TOPOLOGY_FLAGS;

// All of these flags are Readonly unless otherwise noted in NvAPI_SetGpuTopologies()
typedef enum
{
    NV_GPU_TOPOLOGY_ACTIVE                          = 0x00000001,// This topology is currently active.
    NV_GPU_TOPOLOGY_VIDLINK_PRESENT                 = 0x00000002,// Video link between all GPUs is present. (physically bridged)
    NV_GPU_TOPOLOGY_MULTIGPU                        = 0x00000004,// This is a "Multi-GPU"-labeled topology.
    NV_GPU_TOPOLOGY_GX2_BOARD                       = 0x00000008,// GPUs comprising this topology are Dagwoods.
    NV_GPU_TOPOLOGY_DYNAMIC_NOT_ALLOWED             = 0x00000010,// Dynamically switching to SLI is not allowed (it requires a reboot)
    NV_GPU_TOPOLOGY_ACTIVE_IMPLICIT                 = 0x00000020,// Implicit Read only SLI is ACTIVE on this topology of gpus. NvAPI_SetHybridMode can be used to disable this topology.
    NV_GPU_TOPOLOGY_ENABLE_SLI_BY_DEFAULT           = 0x00000040,// SLI must be enabled by default, otherwise SLI is optional
    NV_GPU_TOPOLOGY_ENABLE_CORELOGIC_BROADCAST      = 0x00000080,// Broadcast mode is enabled in the corelogic chipset.
    NV_GPU_TOPOLOGY_BROADCAST                       = 0x00000100,// Broadcast mode is enabled
    NV_GPU_TOPOLOGY_UNICAST                         = 0x00000200,// Unicast mode enabled
    NV_GPU_TOPOLOGY_4_WAY_SLI                       = 0x00000400,// This is a "4-Way-SLI"-labeled topology.
    NV_GPU_TOPOLOGY_COMPUTE                         = 0x00010000,// Gpus in this topology are for SLI compute.
                                                                 // All these GPUs of this SLI compute group can be enum'd using NvAPI_GPU_CudaEnumComputeCapableGpus.
    NV_GPU_TOPOLOGY_SLIMULTIMON                     = 0x00020000,// This topology allows multi-display SLI output
    NV_GPU_TOPOLOGY_VIDLINK_CONNECTOR_PRESENT       = 0x00040000,// Vidlink connectors on all GPUs are present (not not necessarily connected)
    NV_GPU_TOPOLOGY_VIEW_CAN_SPAN_GPUS              = 0x00080000,// This topology allows multi-display SLI output across GPUs
} NV_GPU_TOPOLOGY_FLAGS;

typedef enum
{
    NV_SLI_GROUP_ACTIVE                          = 0x00000001,// This SLI group is currently active.
} NV_SLI_GROUP_FLAGS;

typedef struct
{
    NvU32                   version;                                    //structure version
    NvU32                   gpuCount;                                   //count of GPUs in this topology
    NvPhysicalGpuHandle     hPhysicalGpu[NVAPI_MAX_GPU_PER_TOPOLOGY];   //array of GPU handles
    NvU32                   displayGpuIndex;                            //index of the display GPU owner in the gpu array
    NvU32                   displayOutputTargetMask;                    //target device mask
    NvU32                   flags;                                      //one or more topology flags from NV_GPU_TOPOLOGY_FLAGS
    NvU32                   status;                                     //indicates one of the flags in NV_GPU_TOPOLOGY_STATUS_FLAGS
} NV_GPU_TOPOLOGY_V1;

#define NV_GPU_TOPOLOGY_VER_1  MAKE_NVAPI_VERSION(NV_GPU_TOPOLOGY_V1,1)

typedef struct
{
    NvU32                   version;                                    //structure version
    NvU32                   gpuCount;                                   //count of GPUs in this topology
    NvPhysicalGpuHandle     hPhysicalGpu[NVAPI_MAX_GPU_PER_TOPOLOGY];   //array of GPU handles
    NvU32                   displayGpuIndex;                            //index of the display GPU owner in the gpu array
    NvU32                   displayOutputTargetMask;                    //target device mask
    NvU32                   noDisplayGpuMask;                           //index mask in the hPhysicalGpu[] array pointing to GPUs that cannot display when SLI is enabled
    NvU32                   flags;                                      //one or more topology flags from NV_GPU_TOPOLOGY_FLAGS
    NvU32                   status;                                     //indicates one of the flags in NV_GPU_TOPOLOGY_STATUS_FLAGS
} NV_GPU_TOPOLOGY;

#define NV_GPU_TOPOLOGY_VER  MAKE_NVAPI_VERSION(NV_GPU_TOPOLOGY,2)

typedef struct
{
    NvU32                   version;                                    //structure version
    NvU64                   topologyMask;                               //mask of indexes in gpuTopo
    NvU32                   flags;                                      //one or more SLI group flags from NV_GPU_SLI_GROUP_FLAGS
} NV_SLI_GROUP;

#define NV_GPU_SLI_GROUP_VER  MAKE_NVAPI_VERSION(NV_SLI_GROUP,1)

typedef struct
{
    NvU32                   version;                                    //structure version
    NvU32                   gpuTopoCount;                               //count of valid topologies
    NV_GPU_TOPOLOGY_V1       gpuTopo[NVAPI_MAX_AVAILABLE_GPU_TOPOLOGIES];//max gputopologies
} NV_GPU_TOPOLOGIES_V1;
#define NV_GPU_TOPOLOGIES_VER_1  MAKE_NVAPI_VERSION(NV_GPU_TOPOLOGIES_V1,1)

typedef struct
{
    NvU32                   version;                                    //structure version
    NvU32                   gpuTopoCount;                               //count of valid topologies
    NV_GPU_TOPOLOGY_V1      gpuTopo[NVAPI_MAX_AVAILABLE_GPU_TOPOLOGIES];//max gputopologies
    NvU32                   sliGroupCount;                              //count of valid SLI groups
    NV_SLI_GROUP            sliGroup[NVAPI_MAX_AVAILABLE_SLI_GROUPS];   //max SLI groups
} NV_GPU_TOPOLOGIES_V2;
#define NV_GPU_TOPOLOGIES_VER_2  MAKE_NVAPI_VERSION(NV_GPU_TOPOLOGIES_V2,2)

typedef struct
{
    NvU32                   version;                                    //structure version
    NvU32                   gpuTopoCount;                               //count of valid topologies
    NV_GPU_TOPOLOGY         gpuTopo[NVAPI_MAX_AVAILABLE_GPU_TOPOLOGIES];//max gputopologies
    NvU32                   sliGroupCount;                              //count of valid SLI groups
    NV_SLI_GROUP            sliGroup[NVAPI_MAX_AVAILABLE_SLI_GROUPS];   //max SLI groups
} NV_GPU_TOPOLOGIES;
#define NV_GPU_TOPOLOGIES_VER   MAKE_NVAPI_VERSION(NV_GPU_TOPOLOGIES,3)

#define NV_GPU_VALID_GPU_TOPOLOGIES NV_GPU_TOPOLOGIES
#define NV_GPU_INVALID_GPU_TOPOLOGIES NV_GPU_TOPOLOGIES
#define NV_GPU_VALID_GPU_TOPOLOGIES_VER  NV_GPU_TOPOLOGIES_VER
#define NV_GPU_INVALID_GPU_TOPOLOGIES_VER  NV_GPU_TOPOLOGIES_VER
#define NV_GPU_VALID_GPU_TOPOLOGIES_V1 NV_GPU_TOPOLOGIES_V1
#define NV_GPU_INVALID_GPU_TOPOLOGIES_V1 NV_GPU_TOPOLOGIES_V1
#define NV_GPU_VALID_GPU_TOPOLOGIES_VER_1  NV_GPU_TOPOLOGIES_VER_1
#define NV_GPU_INVALID_GPU_TOPOLOGIES_VER_1  NV_GPU_TOPOLOGIES_VER_1
#define NV_GPU_VALID_GPU_TOPOLOGIES_V2 NV_GPU_TOPOLOGIES_V2
#define NV_GPU_INVALID_GPU_TOPOLOGIES_V2 NV_GPU_TOPOLOGIES_V2
#define NV_GPU_VALID_GPU_TOPOLOGIES_VER_2  NV_GPU_TOPOLOGIES_VER_2
#define NV_GPU_INVALID_GPU_TOPOLOGIES_VER_2  NV_GPU_TOPOLOGIES_VER_2

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GetValidGpuTopologies
//
// DESCRIPTION:     This API returns all valid GPU topologies that can be used to configure the physical GPUs
//                  using the NvAPI_SetGpuTopologies API. Also returns the current active topologies.
//
//                  This call returns an array of NV_GPU_TOPOLOGY structs; one for each valid configuration
//                  of GPUs present in the system.  Note that this list is constant while GPUs remain in the
//                  same slots in the system.  It is not affected by which GPUs are presently in use.
//                  NV_GPU_TOPOLOGY.displayGpuIndex returned will match the boot GPU if it exists as an active topology.
//                  If it not an active topology, it points to the "first" GPU that has a display monitor connected.
//                  This call also returns an array of NV_SLI_GROUP, describing the list of topologies combinations 
//                  that can be enabled at the same time.
//
//  SUPPORTED OS: Windows XP and higher
// PARAMETERS:      ptopology(OUT): An array of *pCount (OUT) topology structures. Use NvAPI_SetGpuTopology() to set 
//                  up one or several of these GPU topologies.
//                  sliGroup(OUT): An array of *sliGroupCount (OUT) sli goup structures, describing which topologies
//                  can be set up concurrently.
//                  pStatus(OUT): Any system status returned in case zero topology is retrieved. 
//                  System status is one or more flags in NV_GPU_TOPOLOGY_STATUS_FLAGS when SLI is NOT capable.
//
// RETURN STATUS    NVAPI_OK: Call succeeded; 1 or more GPU topologies were returned
//                  NVAPI_INVALID_ARGUMENT: one or more args are invalid
//                  NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVidia GPU driving a display was found
//                  NVAPI_ERROR: Miscellaneous Error.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetValidGpuTopologies(NV_GPU_VALID_GPU_TOPOLOGIES *pTopology, NvU32 *pStatus);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GetValidGpuTopologiesInternal
//
// DESCRIPTION:     Similar to NvAPI_GetValidGpuTopologies but returns also the topologies that are 
//                  valid but not allowed to be active (like 2 GPUs in a subset of 3 GPUs)
//
//  SUPPORTED OS: Windows XP and higher
// PARAMETERS:      ptopology(OUT): An array of *pCount (OUT) topology structures. Use NvAPI_SetGpuTopology() to set 
//                  up one of these GPU topologies.
//                  sliGroup(OUT): An array of *sliGroupCount (OUT) sli goup structures, describing which topologies
//                  can be set up concurrently.
//                  pStatus(OUT): Any system status returned in case zero topology is retrieved.
//                  System status is one or more flags in NV_GPU_TOPOLOGY_STATUS_FLAGS when SLI is NOT capable.
//
// RETURN STATUS    NVAPI_OK: Call succeeded; 1 or more GPU topologies were returned
//                  NVAPI_INVALID_ARGUMENT: one or more args are invalid
//                  NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                  NVAPI_ERROR: Miscellaneous Error.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetValidGpuTopologiesInternal(NV_GPU_VALID_GPU_TOPOLOGIES *pTopology, NvU32 *pStatus);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GetInvalidGpuTopologies
//
// DESCRIPTION:     This API returns all invalid GPU topologies and the current active topologies.
//
//                  This call returns an array of NV_GPU_TOPOLOGY structs; one for each invalid configuration
//                  of GPUs present in the system. Note that this list is constant while GPUs remain in the
//                  same slots in the system.  It is not affected by which GPUs that are presently in use.
//
//                  The topologies with the status NV_GPU_TOPOLOGY_STATUS_TOPOLOGY_NOT_ALLOWED are valid for
//                  the system but not for productization.
//
//  SUPPORTED OS: Windows XP and higher
// PARAMETERS:      ptopology(OUT): An array of *pCount (OUT) topology structures.
//                  sliGroup, *sliGroupCount (OUT): No SLI groups returned here. *sliGroupCount = 0.
//
// RETURN STATUS    NVAPI_OK: Call succeeded; 1 or more GPU topologies were returned
//                  NVAPI_INVALID_ARGUMENT: one or more args are invalid
//                  NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                  NVAPI_ERROR: Miscellaneous Error.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetInvalidGpuTopologies(NV_GPU_INVALID_GPU_TOPOLOGIES *pTopology);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_SetGpuTopologies
//
// DESCRIPTION:     This API lets the caller configure the physical GPUs in the system into one or more logical devices
//                  defined by the NV_GPU_TOPOLOGY structure.
//                  Recommended that the caller application:
//                  - save the current GPU topology retrieved from NvAPI_EnumLogicalGPUs and NvAPI_GetPhysicalGPUsFromLogicalGPU APIs.
//                  - save the current view state for associated displays on these GPUs using the GetView and GetDisplayTargets APIs.
//                  - set NV_GPU_TOPOLOGY.displayGpuIndex to the GPU index in the topology with an active display connection.
//                  - if DEFER_3D_APP_SHUTDOWN is not set notify the user that all 3D application will be forced to close.
//                  - itself does not create 3D handles or objects that can block the topology transition.
//                  - On Vista the calling app must run in elevated mode for the transition to succeed.
//                  - On Vista this API can be called from a system service to derive the elevated context of the System service.
//                  - Non migratable apps running can prevent a successful transition if DEFER_3D_APP_SHUTDOWN is set.
//                  - To query non migratable apps use the NvAPI_QueryNonMigratableApps API.
//                  - More than 1 multi-GPU topology being enabled need to have the NV_GPU_TOPOLOGY_SLI_GROUPS flag set
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:      pTopology(IN) - a pointer to a array of structure definining the desired GPU topology retrieved
//                  from NvAPI_GetValidGpuTopologies
//                  flags(IN) - See NV_SET_GPU_TOPOLOGY_FLAGS
//
// RETURN STATUS:   NVAPI_OK: Call succeeded. pTopology.gputTopo[].flags indicates the new status. Reenum all GPU handles after this call.
//                  NVAPI_API_NOT_INTIALIZED: NVAPI not initialized
//                  NVAPI_INVALID_ARGUMENT: one or more args are invalid.
//                  NVAPI_INCOMPATIBLE_STRUCT_VERSION - NV_CPU_INFO version not compatible with driver
//                  NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found.
//                  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//                  NVAPI_INVALID_HANDLE: physical handle is invalid
//                  NVAPI_ERROR: check the status returned in pTopology->status.
//                  NVAPI_TIMEOUT_RECONFIGURING_GPU_TOPO: timeout while reconfiguring GPUs
//                  NVAPI_IMPLICIT_SET_GPU_TOPOLOGY_CHANGE_NOT_ALLOWED: there is any implicit GPU topo active. Use NVAPI_SetHybridMode to change topology.
//                  NVAPI_REQUEST_USER_TO_CLOSE_NON_MIGRATABLE_APPS: Prompt the user to close all non-migratable apps.
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetGpuTopologies(NV_GPU_VALID_GPU_TOPOLOGIES *pTopology, NvU32 flags);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_GPU_GetPerGpuTopologyStatus
//
// DESCRIPTION:    Returns per GPU topology state flags from NV_GPU_TOPOLOGY_STATUS_FLAGS for the queried GPU handle.
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:     hPhysicalGPU(IN) - GPU selection.
//                 pStatus(OUT)     - Indicates one or more flags from NV_GPU_TOPOLOGY_STATUS_FLAGS which are the subset of the
//                                    same flags retrieved from NV_GPU_TOPOLOGY.status or pStatus in NvAPI_GetValidGpuTopologies API.
//                 Note: The per GPU topology status can be queried independent of the whether the queried GPU is part of a topology or not.
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPerGpuTopologyStatus(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pStatus);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetTopologyStatusString
//
//   DESCRIPTION: converts an SLI status into a null terminated string
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: null terminated string (always, never NULL)
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetTopologyStatusString(NvU32 nr,NvAPI_String szDesc);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetTopologyFlagString
//
//   DESCRIPTION: converts an SLI topology flag value string into a null terminated string
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: null terminated string (always, never NULL)
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetTopologyFlagString(NvU32 nr,NvAPI_String szDesc);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetSliGroupFlagString
//
//   DESCRIPTION: converts an SLI group flag value string into a null terminated string
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: null terminated string (always, never NULL)
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetSliGroupFlagString(NvU32 nr,NvAPI_String szDesc);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetGpuTopologySystemProperties
//
// DESCRIPTION: returns the system properties mask the SLI approval
//              uses to make its decision
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:     pTopology(IN) - Topology with the gpu count and the physical gpu handles set.
//                 pSystemProperties(OUT)  - the system properties mask for this SLI config.

// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_INVALID_ARGUMENT - one or more args are invalid
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetGpuTopologySystemProperties(NV_GPU_TOPOLOGY *pTopology, NvU32 *pSystemProperties);

typedef enum
{
    NV_GPU_TOPOLOGY_SYSPROP_IS_MOBILE                       = 0x00000001, // Mobile config
    NV_GPU_TOPOLOGY_SYSPROP_IS_CANOAS                       = 0x00000002, // Canoas config
    NV_GPU_TOPOLOGY_SYSPROP_IS_E551                         = 0x00000004, // E551 config
    NV_GPU_TOPOLOGY_SYSPROP_IS_BR02                         = 0x00000008, // Config has a BR02
    NV_GPU_TOPOLOGY_SYSPROP_IS_BR03                         = 0x00000010, // Each GPU is behind a BR03
    NV_GPU_TOPOLOGY_SYSPROP_IS_BR04                         = 0x00000020, // Each GPU is behind a BR04
    NV_GPU_TOPOLOGY_SYSPROP_IS_BR_ANY                       = 0x00000040, // Config has none or any BR03, BR04
    NV_GPU_TOPOLOGY_SYSPROP_IS_CPU_XEON                     = 0x00000080, // Is the CPU a Xeon
    NV_GPU_TOPOLOGY_SYSPROP_IS_QUADRO                       = 0x00000100, // Quadro only
    NV_GPU_TOPOLOGY_SYSPROP_IS_OS_VISTA                     = 0x00000200, // OS is Vista
    NV_GPU_TOPOLOGY_SYSPROP_IS_2BR03                        = 0x00000400, // minimum of 2 Cascaded BR03s behind each GPU
    NV_GPU_TOPOLOGY_SYSPROP_IS_3BR03                        = 0x00000800, // minimum of 3 Cascaded BR03s behind each GPU
    NV_GPU_TOPOLOGY_SYSPROP_IS_OS_XP                        = 0x00001000, // OS is XP
    NV_GPU_TOPOLOGY_SYSPROP_IS_VIDEO_BRIDGE                 = 0x00002000, // Video bridge present
    NV_GPU_TOPOLOGY_SYSPROP_IS_OS_UNIX                      = 0x00004000, // OS is Unix
    NV_GPU_TOPOLOGY_SYSPROP_IS_GEFORCE                      = 0x00008000, // GeForce only
    NV_GPU_TOPOLOGY_SYSPROP_IS_CANOAS2                      = 0x00010000, // Canoas 2.0 config
    NV_GPU_TOPOLOGY_SYSPROP_IS_OS_MODS                      = 0x00040000, // OS is MODS
    NV_GPU_TOPOLOGY_SYSPROP_IS_COMMON_BR03                  = 0x00080000, // All GPUs have a common BR03
    NV_GPU_TOPOLOGY_SYSPROP_IS_COMMON_BR04                  = 0x00100000, // All GPUs have a common BR04 
    NV_GPU_TOPOLOGY_SYSPROP_IS_SHARED_BR03                  = 0x00200000, // Each GPU is shares a BR03 with another GPU
    NV_GPU_TOPOLOGY_SYSPROP_IS_SHARED_BR04                  = 0x00400000, // Each GPU is shares a BR04 with another GPU
    NV_GPU_TOPOLOGY_SYSPROP_IS_2BR04                        = 0x00800000, // There is a minimum of 2 Cascaded BR04s behind each GPU
    NV_GPU_TOPOLOGY_SYSPROP_IS_BR04_REV_A03                 = 0x01000000, // All BR04 revisions are A03
    NV_GPU_TOPOLOGY_SYSPROP_IS_MXM_INTERPOSER               = 0x02000000, // All GPUS are behind an MXM_INTERPOSER interposer card
    NV_GPU_TOPOLOGY_SYSPROP_IS_NO_BR_NOTBR04A03             = 0x04000000, // All non-root port bridges in the system other than GX2 are BR04 A03
    NV_GPU_TOPOLOGY_SYSPROP_IS_SLI_APPROVAL_COOKIE          = 0x08000000, // The SBIOS has an SLI approval cookie
    NV_GPU_TOPOLOGY_SYSPROP_IS_BR04_PRESENT                 = 0x10000000, // A BR04 is present in the system - not necessarily serving a GPU
    NV_GPU_TOPOLOGY_SYSPROP_IS_2BR04_NOT_CASCADED           = 0x20000000, // There is a minimum of two non cascaded BR04s in the system
    NV_GPU_TOPOLOGY_SYSPROP_IS_4_WAY_SLI_APPROVAL_COOKIE    = 0x40000000, //  The SBIOS has an SLI approval cookie allowing 4-way SLI
} NV_GPU_TOPOLOGY_SYSTEM_PROPERTY_FLAGS;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetGpuTopologySystemPropertiesString
//
//   DESCRIPTION: converts an SLI system properties mask into a null terminated string
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: null terminated string (always, never NULL)
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetGpuTopologySystemPropertiesString(NvU32 nr,NvAPI_String szDesc);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_RestartDisplayDriver
//
// DESCRIPTION:     This API lets the caller restart the display driver
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS:   NVAPI_OK: Call succeeded.
//                  NVAPI_API_NOT_INTIALIZED: NVAPI not initialized
//                  NVAPI_ERROR: the call failed
//                  NVAPI_TIMEOUT_RECONFIGURING_GPU_TOPO: timeout while reconfiguring GPUs
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_RestartDisplayDriver();

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_GPU_GetAllGpusOnSameBoard
//
// DESCRIPTION:    Returns a set of GPUs handles that exists on the same board as the queried GPU handle.
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:     hPhysicalGPU(IN) - GPU selection.
//                 nvGPUHandle      - The associated GPUs on the same board as the queried GPU. This array includes the queried GPU handle too.
//                 pGpuCount        - The count of GPUs that exists on the same board. This count includes the queried GPU handle too.
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetAllGpusOnSameBoard(NvPhysicalGpuHandle hPhysicalGpu, NvPhysicalGpuHandle nvGPUHandle[NVAPI_MAX_PHYSICAL_GPUS], NvU32 *pGpuCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SYS_GetChipSetTopologyStatus
//
// DESCRIPTION:   Returns topology state flags from NV_GPU_TOPOLOGY_STATUS_FLAGS possible with the System ChipSet.
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:    pStatus(OUT)     - Indicates one or more flags from NV_GPU_TOPOLOGY_STATUS_FLAGS which are the subset of the
//                                   same flags retrieved from NV_GPU_TOPOLOGY.status or pStatus in NvAPI_GetValidGpuTopologies API.
// RETURN STATUS:
//    NVAPI_OK    - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_GetChipSetTopologyStatus(NvU32 *pStatus);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_SetTopologyDisplayGPU
//
// DESCRIPTION:     On an active GPU topology this API lets the caller switch the display output between GPUs in the topology.
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:      hLogicalGPU(IN) - Active logical gpu topology containing more than one physical gpus.
//                  hGPU(IN) - Target GPU handle where the display should be outputted.
//                  displayOutputId(IN) - Connected display output Id on the target GPU which should be activated.
//
// RETURN STATUS:   NVAPI_OK: Call succeeded. Display output switched on the target GPU's displayOutputId.
//                  NVAPI_INVALID_ARGUMENT: one or more args are invalid. displayOutputId should be connected to the target hGPU.
//                  NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found.
//                  NVAPI_NO_ACTIVE_SLI_TOPOLOGY: logical gpu does not contain more than one physical GPU.
//                  NVAPI_NO_VIDLINK : Video bridge required for this target gpu switch to succeed.
//                  NVAPI_ERROR: Request failed.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetTopologyDisplayGPU(NvLogicalGpuHandle hLogicalGPU, NvPhysicalGpuHandle hGPU, NvU32 displayOutputId);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GetTopologyDisplayGPU
//
// DESCRIPTION:     On an active GPU topology this API lets the caller query the target GPU and the display output Id.
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:      hLogicalGPU(IN) - Active logical gpu topology containing more than one physical gpus.
//                  pPhysicalGpu(OUT) - Target GPU handle where the display is getting outputted.
//                  pDisplayOutputId(OUT) - Active connected display output Id on the target GPU.
//
// RETURN STATUS:   NVAPI_OK: Call succeeded.
//                  NVAPI_INVALID_ARGUMENT: one or more args are invalid.
//                  NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found.
//                  NVAPI_ERROR: Request failed.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetTopologyDisplayGPU(NvLogicalGpuHandle hLogicalGPU, NvPhysicalGpuHandle *pPhysicalGpu, NvU32 *pDisplayOutputId);

// End of GPU topology configuration APIs

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SYS_GetSliApprovalCookie
//
// DESCRIPTION: retrieves the SLI approval cookie. This is a string returned 
//              by the SBIOS to allow SLI on selected motherboards.
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:     SliApprovalCookie (OUT)  - the SLI approval cookie string.
//                                            An empty string means no SLI approval cookie.
//            

// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_INVALID_ARGUMENT - one or more args are invalid
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_GetSliApprovalCookie(NvAPI_String SliApprovalCookie);

typedef struct
{
    NvU32      version;        //structure version
    struct{
        NvU32   displayMask;
    } input;
    struct{
        NvU32   isDP2DVI:1;
        NvU32   isDP2HDMI:1;
    } output;

} NV_NVAPI_GET_DP_DONGLE_INFO;
#define NV_NVAPI_GET_DP_DONGLE_INFO_VER  MAKE_NVAPI_VERSION(NV_NVAPI_GET_DP_DONGLE_INFO,1)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_Get_DisplayPort_DongleInfo
//
// DESCRIPTION: Gets the DisplayPort Dongle info like DP2DVI/DP2HDMI. 
//
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:     hPhysicalGPU(IN) - GPU selection.
//                 NV_NVAPI_GET_DP_DONGLE_INFO - data input/output structure
//            

// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_INVALID_ARGUMENT - one or more args are invalid
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_Get_DisplayPort_DongleInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_NVAPI_GET_DP_DONGLE_INFO *pDongleInfo);

///////////////////////////////////////////////////////////////////////////////////
//  I2C API
//  Provides ability to read or write data using I2C protocol.
//  These APIs allow I2C access only to DDC monitors

#define NVAPI_MAX_SIZEOF_I2C_DATA_BUFFER 4096
#define NVAPI_DISPLAY_DEVICE_MASK_MAX 24

typedef struct
{
    NvU32                   version;        //structure version
    NvU32                   displayMask;    //the Display Mask of the concerned display
    NvU8                    bIsDDCPort;     //Flag indicating DDC port or a communication port
    NvU8                    i2cDevAddress;  //the I2C target device address
    NvU8*                   pbI2cRegAddress;//the I2C target register address
    NvU32                   regAddrSize;    //the size in bytes of target register address
    NvU8*                   pbData;         //The buffer of data which is to be read/written
    NvU32                   cbSize;         //The size of Data buffer to be read.
    NvU32                   i2cSpeed;       //The target speed of the transaction (between 28kbps to 40kbps; not guaranteed)
} NV_I2C_INFO;

#define NV_I2C_INFO_VER  MAKE_NVAPI_VERSION(NV_I2C_INFO,1)
/***********************************************************************************/

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_I2CRead
//
// DESCRIPTION:    Read data buffer from I2C port
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS:     hPhysicalGPU(IN) - GPU selection.
//                 NV_I2C_INFO *pI2cInfo -The I2c data input structure
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_INCOMPATIBLE_STRUCT_VERSION - structure version is not supported
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_I2CRead(NvPhysicalGpuHandle hPhysicalGpu, NV_I2C_INFO *pI2cInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_I2CWrite
//
// DESCRIPTION:    Writes data buffer to I2C port
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS:     hPhysicalGPU(IN) - GPU selection.
//                 NV_I2C_INFO *pI2cInfo -The I2c data input structure
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_INCOMPATIBLE_STRUCT_VERSION - structure version is not supported
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_I2CWrite(NvPhysicalGpuHandle hPhysicalGpu, NV_I2C_INFO *pI2cInfo);

#define NVAPI_I2C_FLAGS_PRIVILEGE           0x1
#define NVAPI_I2C_FLAGS_DATA_ENCRYPTED      0x2 // Currently Encrypted I2C is not supported
#define NVAPI_I2C_FLAGS_NONSTD_SI1930UC     0x4
#define NVAPI_I2C_FLAGS_PX3540              0x10

typedef struct
{
    NvU32                   flags;        // I2C flags for Priviledged, Encrypted and non-std Si1930uC i2c access
    NvU32                   encrClientID; // Client ID for Encrypted I2C
} NV_I2C_INFO_EX;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_I2CWriteEx
//
// DESCRIPTION:    Writes data buffer to I2C port
//                 Please use DisplayMask as Zero, If I2C access required for non display devices
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS:     hPhysicalGPU(IN) - GPU selection.
//                 NV_I2C_INFO *pI2cInfo -The I2c data input structure
//                 NV_I2C_INFO_EX *pI2cInfoEx - The I2c extended data input structure
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_INCOMPATIBLE_STRUCT_VERSION - structure version is not supported
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_I2CWriteEx(NvPhysicalGpuHandle hPhysicalGpu, NV_I2C_INFO *pI2cInfo, NV_I2C_INFO_EX *pI2cInfoEx);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_I2CReadEx
//
// DESCRIPTION:    Read data buffer from I2C port
//                 Please use DisplayMask as Zero, If I2C access required for non display devices
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS:     hPhysicalGPU(IN) - GPU selection.
//                 NV_I2C_INFO *pI2cInfo -The I2c data input structure
//                 NV_I2C_INFO_EX *pI2cInfoEx - The I2c extended data input structure
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_INCOMPATIBLE_STRUCT_VERSION - structure version is not supported
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_I2CReadEx(NvPhysicalGpuHandle hPhysicalGpu, NV_I2C_INFO *pI2cInfo, NV_I2C_INFO_EX *pI2cInfoEx);

// END OF I2C API


///////////////////////////////////////////////////////////////////////////////
// POWERMIZER APIs
//
// Provides the ability to Limit PowerMizer's Maximum Performance.
// Grants access on Adaptive Clocking turn on and off.
// PowerMizer can be either Soft Limited or Hard Limited.
// Soft Limit can be exceeded by the adaptive systems in the GPU if there is a need.
// Hard Limit cannot be exceeded even if there is a need to exceed this limit.
//
//////////////////////////////////////////////////////////////////////////////
typedef enum _NV_LEVEL_INFO
{
    NVAPI_PWR_MZR_HARD_LIMIT_MAX                        = 0x00000001,       // Power Mizer Maximum Performance for Hard limit
    NVAPI_PWR_MZR_HARD_LIMIT_BAL                        = 0x00000002,       // Power Mizer Balanced Performance for Hard limit
    NVAPI_PWR_MZR_MAX_BATT                              = 0x00000003,       // Power Mizer Maximum Battery Performance
    NVAPI_PWR_MZR_SOFT_LIMIT_MAX                        = 0x00000004,       // Power mizer Maximum performance for Soft limit
    NVAPI_PWR_MZR_SOFT_LIMIT_BAL                        = 0x00000005,       // Power mizer Balanced performance for Soft limit
    NVAPI_ADC_OFF                                       = 0x00000006,       // Adaptive Clocking Disable
    NVAPI_ADC_ON                                        = 0x00000007,       // Adaptive Clocking Enable
} NV_LEVEL_INFO;


typedef enum _NV_PWR_SOURCE_INFO
{
    NVAPI_PWR_SOURCE_AC                                 = 0x00000001,       // Power source AC
    NVAPI_PWR_SOURCE_BATT                               = 0x00000002,       // Power source Battery
} NV_PWR_SOURCE_INFO;

typedef enum _NV_SELECT_INFO
{
    NVAPI_INDEX_PWR_MZR_HARD                            = 0x00000001,       // To set/get PowerMizer Hard limits. Hard limits modifies the hardware limits.
    NVAPI_INDEX_PWR_MZR_SOFT                            = 0x00000002,       // To set/get PowerMizer Soft limits. Soft limits sets the application preference and could be exceeded upto Hard limits if required by the system.
    NVAPI_INDEX_ADC                                     = 0x00000003,       // To set/get Adaptive Clocking parameters where the driver automatically selects the limits.
} NV_SELECT_INFO;


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:    NvAPI_GPU_GetPowerMizerInfo
//
// DESCRIPTION:      Gets the PowerMizer Maximum Limit for Battery or AC
//                   Gets the Adaptive Clocking status for Battery or AC
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:       hPhysicalGPU(IN)         GPU selection.
//                   powerSource              Power source selection with one of the values from NV_PWR_SOURCE_INFO.
//                   select                   PowerMizer type selection with one of the values from NV_SELECT_INFO.
//                   pLevel                   Pointer to return value
//
// RETURN STATUS:
//                   NVAPI_OK                 completed request
//                   NVAPI_NOT_SUPPORTED      Power Mizer Not supported
//                   NVAPI_ERROR              Invalid return to API
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPowerMizerInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_PWR_SOURCE_INFO powerSourceInfo,
                                          NV_SELECT_INFO select, NV_LEVEL_INFO *pLevelInfo);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:    NvAPI_GPU_SetPowerMizerInfo
//
// DESCRIPTION:      Sets the PowerMizer Maximum Limit for both Battery and/or AC
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:       hPhysicalGPU(IN)          GPU selection
//                   powerSource               Power source selection with one of the values from NV_PWR_SOURCE_INFO.
//                   select                    PowerMizer type selection with one of the values from NV_SELECT_INFO.
//                   level                     Level that has to be set on PwrMzr /Adaptive clocking
//
// RETURN STATUS:    NVAPI_OK                  completed request
//                   NVAPI_NOT_SUPPORTED       PowerMizer Not supported
//                   NVAPI_INVALID_ARGUMENT    Invalid arguments
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetPowerMizerInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_PWR_SOURCE_INFO powerSourceInfo,
                                         NV_SELECT_INFO select, NV_LEVEL_INFO levelInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_RmConfigGet
//
//   DESCRIPTION: This is a TEMPORARY implementation of RM configGet for LDDM.
//                This escape is meant for use by swak only.  Please contact
//                sw-nvapi if you wish to use this interface.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_RmConfigGet(NvDisplayHandle hNvDisplay,NvU32 opcode,NvU32 *pValue);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetVideoPerformanceData
//
// DESCRIPTION: Returns video-related performance data (frame drops, enabled video
//              processing features flags, etc) for the most recently played video stream.
//
//              The data is returned in a string with following format:
//              TokenName1=Value1;TokenName2=Value2;TokenName3=Value3;
//              Token names and values consist of only non-whitespace characters exluding the
//              '=' and ';' delimiter characters. There is no whitespace between
//              TokenNames, Values, '=', and ';' characters
//
//  SUPPORTED OS: Windows XP and higher
//
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pData is NULL
//                NVAPI_OK: data has been written to pData.
//                NVAPI_ERROR: failed to retrieve performance data.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetVideoPerformanceData(char *pData, NvU32 dataSize);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SetVideoPerformanceDataCollectionEnabled
//
// DESCRIPTION: Enables or disables logging of video performance data by the driver.
//              This data can be then collected using NvAPI_GetVideoPerformanceData call.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_OK: logging was successfully enabled or disabled
//                NVAPI_ERROR: failed to set the registry flag enabling logging
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetVideoPerformanceDataCollectionEnabled(NvU32 bEnabled);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetVideoPerformanceDataCollectionEnabled
//
// DESCRIPTION: Outputs whether video performance data collection is enabled.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pbEnabled is NULL
//                NVAPI_OK: logging status was successfully written to pbEnabled
//                NVAPI_ERROR: failed to get the registry flag to determine
//                             if logging is enabled
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetVideoPerformanceDataCollectionEnabled(NvU32* pbEnabled);


typedef enum _NV_VIDEO_PMMC_ACTION
{
    NV_VIDEO_PMMC_DELETE       = 0,        // finished, delete report and resources
    NV_VIDEO_PMMC_START,                   // enable, alloc resources, start logging
    NV_VIDEO_PMMC_STOP,                    // stop logging, free resources except report
} NV_VIDEO_PMMC_ACTION;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Video_PmmC_SetMode
//
//   DESCRIPTION: Set the video engines use of Perfmon Mode C based on the VideoPmmCSetModeAction enum
//                For information on PmmC, see nvPerfmonModeC.cpp - comments in header
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Video_PmmC_SetMode(NV_VIDEO_PMMC_ACTION modeAction);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Video_PmmC_GetReport
//
//   DESCRIPTION: Get the data from Video Perfmon Mode C
//                If pReport == NULL, then pbytesNeeded is filled so the caller
//                can allocate the memory.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Video_PmmC_GetReport(NvU32 bytesAllocd, NvU32 *pBytesNeeded, char *pReport);


typedef struct
{
    NvU32       version;            // structure version
    NvU32       dwControl;
    NvU32       dwTrig0Sel;
    NvU32       dwTrig1Sel;
    NvU32       dwEventSel;
    NvU32       dwSampleSel;
    NvU32       dwSampleOp;
    NvU32       engine[12];
    NvU32       sigtype[12];
} NV_VIDEO_PMMC_DOMAIN_CONTROL;
#define NV_VIDEO_PMMC_DOMAIN_CONTROL_VER  MAKE_NVAPI_VERSION(NV_VIDEO_PMMC_DOMAIN_CONTROL,1)

typedef struct
{
    NvU32                           version;            // structure version
    NvU32                           bEnable;
    NvU32                           dwMaxCaptureRecords;
    NvU32                           dwMaxReportRecords;
    NV_VIDEO_PMMC_DOMAIN_CONTROL    controlSetup;
} NV_VIDEO_PMMC_DOMAIN_CONTROL_SETUP;
#define NV_VIDEO_PMMC_DOMAIN_CONTROL_SETUP_VER  MAKE_NVAPI_VERSION(NV_VIDEO_PMMC_DOMAIN_CONTROL_SETUP,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Video_Pmmc_SetDomainConfig
//
//   DESCRIPTION: Setup the domain capture hw control for Video Perfmon Mode C
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Video_Pmmc_SetDomainConfig(NvU32 domain, NV_VIDEO_PMMC_DOMAIN_CONTROL_SETUP *setupData);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_SetPerfLevel
//
// DESCRIPTION: Sets GPU perf level to a specified level. For testing only.
//              There is a known limitation that after locking to the target
//              perf level, there is currently no way to release the lock.
//              Note that this function is now obsolete and is being replaced
//              by NvAPI_GPU_SetForcePstate.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: handle is invalid
//                NVAPI_OK: GPU perf level is successfully set
//                NVAPI_ERROR: failed to set GPU perf level
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetPerfLevel(NvPhysicalGpuHandle hPhysicalGpu, NvU32 level);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_SetForcePstate
//
// DESCRIPTION:     Forces the GPU into the specified performance state (P-State).
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS:      hPhysicalGPU(IN) - GPU selection.
//                  forcePstate(IN)  - The ID of the P-State to force the GPU into.
//                                     Specify NV_GPU_PERF_PSTATE_UNDEFINED to stop
//                                     forcing to any P-State, and allow the driver to
//                                     dynamically determine the optimal P-State.
//                  fallback(IN)     - The fallback strategy when the specified P-State
//                                     is not available.
//                    e.g. If FALLBACK_RETURN_ERROR is specified, the function would just return
//                         error when the P-State specified by forcePstate is not available.
//                         If FALLBACK_HIGHER_PERF is specified, the function would fallback
//                         to a higher performance P-State, or to the P-State with the highest
//                         possible performance if no higher performance P-State is found.
//                         If FALLBACK_LOWER_PERF is specified, the function would fallback
//                         to a lower performance P-State, or to the P-State with the lowest
//                         possible performance if no lower performance P-State is found.
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_NOT_SUPPORTED - P-States is not supported on this setup
//    NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetForcePstate(NvPhysicalGpuHandle hPhysicalGpu,
                                         NV_GPU_PERF_PSTATE_ID forcePstate,
                                         NV_GPU_PERF_PSTATE_FALLBACK fallback);

//  SUPPORTED OS: Mac OS X, Windows XP and higher
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_SetForcePstateEx
//
// DESCRIPTION:     Forces the GPU into the specified performance state (P-State).
//
// PARAMETERS:      hPhysicalGPU(IN) - GPU selection.
//                  forcePstate(IN)  - The ID of the P-State to force the GPU into.
//                                     Specify NV_GPU_PERF_PSTATE_UNDEFINED to stop
//                                     forcing to any P-State, and allow the driver to
//                                     dynamically determine the optimal P-State.
//                  fallback(IN)     - The fallback strategy when the specified P-State
//                                     is not available.
//                    e.g. If FALLBACK_RETURN_ERROR is specified, the function would just return
//                         error when the P-State specified by forcePstate is not available.
//                         If FALLBACK_HIGHER_PERF is specified, the function would fallback
//                         to a higher performance P-State, or to the P-State with the highest
//                         possible performance if no higher performance P-State is found.
//                         If FALLBACK_LOWER_PERF is specified, the function would fallback
//                         to a lower performance P-State, or to the P-State with the lowest
//                         possible performance if no lower performance P-State is found.
//                 flags(IN)         - Options that control the behavior of the P-State
//                                     change.
//                   Valid flags:
//                   NV_GPU_PERF_SET_FORCE_PSTATE_FLAGS_ASYNC - Change the p-state asynchronously.
//                         The p-state change may not complete before the function returns.
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_NOT_SUPPORTED - P-States is not supported on this setup
//    NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetForcePstateEx(NvPhysicalGpuHandle hPhysicalGpu,
                                           NV_GPU_PERF_PSTATE_ID forcePstate,
                                           NV_GPU_PERF_PSTATE_FALLBACK fallback,
                                           NvU32 flags);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_SetPerfClockControl
//
// DESCRIPTION: Sets GPU perf controls - graphics, memory, and thermal. The
//              changes for each of graphics, memory, and thermal controls
//              will be enabled/disabled according to the parameters passed in.
//              1 = enabled, 0 = disabled.
//              For testing only.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: handle is invalid
//                NVAPI_OK: GPU perf clock control is successfully set
//                NVAPI_ERROR: failed to set GPU perf clock control
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetPerfClockControl(NvPhysicalGpuHandle hPhysicalGpu,
                                              NvU32 graphicsEnable,
                                              NvU32 memoryEnable,
                                              NvU32 thermalEnable);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetPerfClockControl
//
// DESCRIPTION: Retrieves dynamic performance clock controls status. On success,
//              'graphicsEnabled' describes whether or not dynamic graphics clock
//              changes are enabled; 'memoryEnabled' describes whether or not
//              dynamic memory clock changes are enabled; 'thermalEnabled'
//              describes whether or not thermal changes are enabled. If a NULL
//              pointer is passed in, it is ignored and no status is returned.
//              1 = enabled, 0 = disabled.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: handle is invalid
//                NVAPI_OK: got GPU perf clock control successfully
//                NVAPI_ERROR: failed to get GPU perf clock control
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPerfClockControl(NvPhysicalGpuHandle hPhysicalGpu,
                                              NvU32 *graphicsEnabled,
                                              NvU32 *memoryEnabled,
                                              NvU32 *thermalEnabled);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetCoreVoltage
//
// DESCRIPTION: Gets sampled GPU voltage in millivolts.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: handle is invalid
//                NVAPI_OK: successfully retrieved voltage value
//                NVAPI_ERROR: failed to get voltage value
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetCoreVoltage(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *voltage);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_SetCoreVoltageControl
//
// DESCRIPTION: Sets GPU core voltage control (enable/disable)
//              On success, the core voltage change feature is enabled/disabled.
//              For testing only.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: handle is invalid
//                NVAPI_OK: successfully set voltage control
//                NVAPI_ERROR: failed to set voltage control
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetCoreVoltageControl(NvPhysicalGpuHandle hPhysicalGpu, NvU32 enable);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetCoreVoltageControl
//
// DESCRIPTION: Gets GPU core voltage control (enabled/disabled)
//              On success, 'enabled' describes whether or not the core
//              voltage change feature is enabled.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: handle is invalid
//                NVAPI_OK: successfully got voltage control
//                NVAPI_ERROR: failed to get voltage control
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetCoreVoltageControl(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *enabled);



typedef struct
{
    NvU32 version;                      // structure version
    NvU16 bufferSize;                   // input/output data size
    NvU8 buffer[NV_MXM_BLOCK_SIZE];     // input/output data buffer
} NV_ACPI_METHOD_DATA_SET;
#define NV_ACPI_METHOD_DATA_SET_VER MAKE_NVAPI_VERSION(NV_ACPI_METHOD_DATA_SET, 1)

typedef enum _NV_ACPI_METHOD_ID
{
    NVAPI_ACPI_METHOD_MXM2X_MXMI = 0,       // MXM 2.x: Return Spec Support Level
    NVAPI_ACPI_METHOD_MXM2X_MXMS,           // MXM 2.x: Return the MXM Structure (SIS)
    NVAPI_ACPI_METHOD_DSM_MXM3X_MXSS,       // MXM 3.x: Supported Sub-Functions
    NVAPI_ACPI_METHOD_DSM_MXM3X_MXMI,       // MXM 3.x: Platform MXM Capabilities
    NVAPI_ACPI_METHOD_DSM_MXM3X_MXMS,       // MXM 3.x: Get the MXM Structure (SIS)
    NVAPI_ACPI_METHOD_DSM_MXM3X_MXPP,       // MXM 3.x: Get/Set Platform Policies
    NVAPI_ACPI_METHOD_DSM_MXM3X_MXDP,       // MXM 3.x: Get/Set Display Config
    NVAPI_ACPI_METHOD_DSM_MXM3X_MDTL,       // MXM 3.x: Get Display Toggle List
    NVAPI_ACPI_METHOD_DSM_MXM3X_MXCB,       // MXM 3.x: Query/Call System Callbacks
    NVAPI_ACPI_METHOD_DOD,                  // Get DOD ID List
    NVAPI_ACPI_METHOD_MXMX,                 // Select Display Data Channel
    NVAPI_ACPI_METHOD_MXDS,                 // Select Display Output Channel
    NVAPI_ACPI_METHOD_DSM_MXM3X_EVENTLIST,  // MXM 3.x: Get flexible notifiers list

    // MUST BE THE LAST ONE!!!  Don't add any new ID after this!!!
    NVAPI_ACPI_NUM_SUPPORTED_METHODS        // # of ACPI methods exported to NVAPI
} NV_ACPI_METHOD_ID;

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_SYS_ACPI_GetValues
//
//   DESCRIPTION: Execute ACPI methods and get returned data.  ACPI stands for Advanced
//                Configuration and Power Interface.
//
//    PARAMETERS: hPhysicalGpu(IN) - GPU selection.
//                acpiMethod(IN) - ACPI method ID.
//                pBuf(OUT) - contains one or more data returned by the ACPI
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_OK: execution succeeded
//                NVAPI_NOT_SUPPORTED: queried ACPI method is NOT supported
//                NVAPI_INVALID_ARGUMENT: method ID not recognized
//                NVAPI_ERROR: failed to retrieve supported info
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_ACPI_GetValues(NvPhysicalGpuHandle hPhysicalGpu, NV_ACPI_METHOD_ID acpiMethod, NV_ACPI_METHOD_DATA_SET *pBuf);



typedef enum _NV_ACPI_EVENT_TYPE
{
    NVAPI_ACPI_EVENT_TYPE_LID_STATE,
    NVAPI_ACPI_EVENT_TYPE_POWER_SOURCE,
    NVAPI_ACPI_EVENT_TYPE_DOCK_STATE,
    NVAPI_ACPI_EVENT_TYPE_TRUST_LID,
    NVAPI_ACPI_EVENT_TYPE_TRUST_DOCK,
} NV_ACPI_EVENT_TYPE;

typedef enum _NV_ACPI_EVENT_DATA
{
    NVAPI_ACPI_EVENT_DATA_LID_OPEN,
    NVAPI_ACPI_EVENT_DATA_LID_CLOSED,
    NVAPI_ACPI_EVENT_DATA_POWER_BATTERY,
    NVAPI_ACPI_EVENT_DATA_POWER_AC,
    NVAPI_ACPI_EVENT_DATA_DOCK_UNDOCKED,
    NVAPI_ACPI_EVENT_DATA_DOCK_DOCKED,
    NVAPI_ACPI_EVENT_DATA_TRUST_LID_DCS,
    NVAPI_ACPI_EVENT_DATA_TRUST_LID_NVIF,
    NVAPI_ACPI_EVENT_DATA_TRUST_LID_ACPI,
    NVAPI_ACPI_EVENT_DATA_TRUST_LID_POLL,
    NVAPI_ACPI_EVENT_DATA_TRUST_DOCK_DCS,
    NVAPI_ACPI_EVENT_DATA_TRUST_DOCK_NVIF,
    NVAPI_ACPI_EVENT_DATA_TRUST_DOCK_ACPI,
    NVAPI_ACPI_EVENT_DATA_TRUST_DOCK_POLL,
} NV_ACPI_EVENT_DATA;

typedef enum _NV_ACPI_EVENT_FORCED_DATA
{
    NVAPI_ACPI_EVENT_FORCED_DATA_NO,
    NVAPI_ACPI_EVENT_FORCED_DATA_YES
} NV_ACPI_EVENT_FORCED_DATA;

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_SYS_ACPI_NotifyEvent
//
//   DESCRIPTION: This call is used to trigger mobile related systems events in RM.
//                (lid open/close, dock/undock and power plug/unplug (ac/battery))
//                This events should be triggered by OS and this is a backdoor to
//                trigger them during testing.
//
//    PARAMETERS: eventType(IN) - type of event (see enum _NV_ACPI_EVENT_TYPE)
//                eventData(IN) - event specific data (see enum _NV_ACPI_EVENT_DATA)
//                dataForced(IN) - used to specify whether to trust Lid/Dock state
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_OK: execution succeeded
//                NVAPI_NOT_SUPPORTED: required notification is NOT supported
//                NVAPI_INVALID_ARGUMENT: event type or data are incorrect
//                NVAPI_INVALID_HANDLE: invalid GPU handle
//                NVAPI_ERROR: miscellaneous error
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_ACPI_NotifyEvent(NvPhysicalGpuHandle hPhysicalGpu, NV_ACPI_EVENT_TYPE eventType, NV_ACPI_EVENT_DATA eventData, NV_ACPI_EVENT_FORCED_DATA dataForced);


typedef enum _NV_NVIF_FUNC_ID
{
    NVAPI_NVIF_FUNC_LID_STATUS = 0,      // Get lid status
    NVAPI_NVIF_FUNC_DOCKING_STATUS,      // Get docking status
    NVAPI_NVIF_FUNC_THERMAL_MONITOR,     // GPU thermal monitor
    NVAPI_NVIF_FUNC_BRIGHTNESS_CONTROL,  // LCD backlight brightness control
    NVAPI_NVIF_FUNC_POWERMIZER_LIMIT,    // PowerMizer level limit
    NVAPI_NVIF_FUNC_DISPLAY_ATTRIBUTES,  // Display device hotplug detection
    NVAPI_NVIF_FUNC_HDCP,                // Get HDCP keys (High bandwidth Digital Content Protection)
    NVAPI_NVIF_FUNC_DISPLAY_GET_VALUE,   //  Query for display device attribute preferences
    NVAPI_NVIF_FUNC_DISPLAY_SET_VALUE,   //  Set display device attribute preferences
    NVAPI_NVIF_FUNC_PLATFORM_CONFIG,     // Get system memory bandwidth and latency information
    NVAPI_NVIF_FUNC_NUM,                 // # of possible func ID's
} NV_NVIF_FUNC_ID;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SYS_NVIF_QuerySupport
//
// DESCRIPTION: Queries if an NVIF method is supported by SBIOS. NVIF is an
//              NVIDIA extension of ACPI that OEMs can choose to implement in
//              their SBIOS. ACPI stands for Advanced Configuration and Power
//              Interface.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_OK: queried NVIF method is supported
//                NVAPI_NOT_SUPPORTED: queried NVIF method is NOT supported
//                NVAPI_INVALID_ARGUMENT: function ID not recognized
//                NVAPI_ERROR: failed to retrieve support info
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_NVIF_QuerySupport(NV_NVIF_FUNC_ID func);

typedef struct
{
    NvU32   version;
    struct
    {
        NvU32   displayOutputId;        //display output Id
        NvU32   data;                  //contains one or more data whose type depend on the NVIF_FUNC_REQUEST_ID
    }
    displayData[NVAPI_MAX_DISPLAYS];

    NvU32   validDataSize;    //valid number of entries in displayData array.
} NVIF_FUNC_DATA_SET;

#define NVIF_FUNC_DATA_SET_VER  MAKE_NVAPI_VERSION(NVIF_FUNC_DATA_SET,1)

typedef enum
{
    NVIF_FUNC_REQUEST_SCALING  = 0,  //return data set contains one more display scaling of data type NV_SCALING
    NVIF_FUNC_REQUEST_TVFORMAT = 1,  //return data set contains one more display tv format of data type NV_DISPLAY_TV_FORMAT
    NVIF_FUNC_REQUEST_NUM,
} NVIF_FUNC_REQUEST_ID;
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SYS_NVIF_GetValues
//
// DESCRIPTION: Get Disp Attributes from SBIOS. NVIF is an
//              NVIDIA extension of ACPI that OEMs can choose to implement in
//              their SBIOS. ACPI stands for Advanced Configuration and Power
//              Interface.
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:      func(IN) - NVIF fun ID.
//                  dataReqId(IN) - Structure which return array of supported scaling and TV formats by SBIOS
//                  data(OUT) - contains one or more data whose type depend on the NVIF_FUNC_REQUEST_ID
// RETURN STATUS: NVAPI_OK: queried NVIF method is supported
//                NVAPI_NOT_SUPPORTED: queried NVIF method is NOT supported
//                NVAPI_INVALID_ARGUMENT: function ID not recognized
//                NVAPI_ERROR: failed to retrieve support info
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_NVIF_GetValues(NV_NVIF_FUNC_ID func, NVIF_FUNC_REQUEST_ID dataReqId, NVIF_FUNC_DATA_SET *data);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SYS_NVIF_SetValues
//
// DESCRIPTION: Set Disp Attributes to SBIOS. NVIF is an
//              NVIDIA extension of ACPI that OEMs can choose to implement in
//              their SBIOS. ACPI stands for Advanced Configuration and Power
//              Interface.
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:      func(IN) - NVIF fun ID.
//                  dataReqId(IN) - Structure which sets array of supported scaling and TV formats by SBIOS
//                  data(OUT) - contains one or more data whose type depends on the NVIF_FUNC_REQUEST_ID
// RETURN STATUS: NVAPI_OK: queried NVIF method is supported
//                NVAPI_NOT_SUPPORTED: queried NVIF method is NOT supported
//                NVAPI_INVALID_ARGUMENT: function ID not recognized
//                NVAPI_ERROR: failed to retrieve support info
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_NVIF_SetValues(NV_NVIF_FUNC_ID func, NVIF_FUNC_REQUEST_ID dataReqId, NVIF_FUNC_DATA_SET data);

#define NVAPI_MEM_DATA_SIZE 128

typedef struct
{
    NvU32    version;
    NvU32    dataBlob[NVAPI_MEM_DATA_SIZE];
    NvU32    dataSize; // size in bytes.

}NVIF_FUNC_MEM_BW_INFO;

#define NVIF_FUNC_MEM_BW_INFO_VER  MAKE_NVAPI_VERSION(NVIF_FUNC_MEM_BW_INFO,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SYS_NVIF_PlatformConfig
//
// DESCRIPTION: Get system memory bandwidth and latency information from SBIOS. NVIF is an
//              NVIDIA extension of ACPI that OEMs can choose to implement in
//              their SBIOS. ACPI stands for Advanced Configuration and Power
//              Interface.
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:      func(IN) - NVIF fun ID.
//                  data(OUT) - contains the return data
// RETURN STATUS: NVAPI_OK: queried NVIF method is supported
//                NVAPI_NOT_SUPPORTED: queried NVIF method is NOT supported
//                NVAPI_INVALID_ARGUMENT: function ID not recognized
//                NVAPI_ERROR: failed to retrieve support info
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_NVIF_PlatformConfig(NV_NVIF_FUNC_ID func, NVIF_FUNC_MEM_BW_INFO *data);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_QueryGpuCap
//
//   DESCRIPTION: Get capability info from a logical GPU.
//
//   PARAMETERS:  hLogicalGPU(IN) - logical GPU selection.
//                capToQuery(IN)  - GPU cap to query
//                pVal(OUT)       - Returned value
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_OK: query succeeded
//                NVAPI_INVALID_ARGUMENT: pVal is NULL or capToQuery is invalid
//                NVAPI_EXPECTED_LOGICAL_GPU_HANDLE: hLogicalGPU is not a valid handle.
//                NVAPI_HANDLE_INVALIDATED: hLogicalGPU has been invalidated
//                NVAPI_ERROR: miscellaneous error occurred
//
///////////////////////////////////////////////////////////////////////////////

typedef enum
{
    NVAPI_GPU_CAP_UNDEFINED                                    = 0,
    NVAPI_GPU_CAP_GAMMA_CORRECT_AA_SUPPORTED                   = 1,
    NVAPI_GPU_CAP_TRANSPARENCY_AA_SUPPORTED                    = 2,
    NVAPI_GPU_CAP_SLI_RENDERING_DISABLED_DUE_TO_INTERLACE_MODE = 3,
    NVAPI_GPU_CAP_STEREO_DIN_AVAILABLE                         = 4,
    NVAPI_GPU_CAP_STEREO_CAPS                                  = 5,
    NVAPI_GPU_CAP_STEREO_DEFAULT                               = 6,
    NVAPI_GPU_CAP_ROTATION_COMPATIBLE_STEREO_CAPS              = 7,
    NVAPI_GPU_CAP_ROTATION_COMPATIBLE_STEREO_DEFAULT           = 8,
    NVAPI_GPU_CAP_SWAPGROUP_FOR_ALL_APPS_SUPPORTED             = 9,
    NVAPI_GPU_CAP_DEEP_COLOR_CAPS                              = 10,
    NVAPI_GPU_CAP_COUNT
} NVAPI_GPU_CAP;

// Possible return value of queries to NVAPI_GPU_CAP_STEREO_CAPS and
// NVAPI_GPU_CAP_STEREO_DEFAULT
typedef enum 
{
    NVAPI_GPU_CAP_STEREO_CAP_DIN_AVAILABLE                = 0x00000001,
    NVAPI_GPU_CAP_STEREO_CAP_VERTICAL_INTERLACED          = 0x00000002,
    NVAPI_GPU_CAP_STEREO_CAP_TWINVIEW                     = 0x00000004,
    NVAPI_GPU_CAP_STEREO_CAP_DDC_AVAILABLE                = 0x00000008,
    NVAPI_GPU_CAP_STEREO_CAP_COLOR_LINE                   = 0x00000010,
    NVAPI_GPU_CAP_STEREO_CAP_COLOR_INTERLEAVED            = 0x00000020,
    NVAPI_GPU_CAP_STEREO_CAP_ANAGLYPH                     = 0x00000040,
    NVAPI_GPU_CAP_STEREO_CAP_HORIZONTAL_INTERLACED        = 0x00000080,
    NVAPI_GPU_CAP_STEREO_CAP_SIDE_FIELD                   = 0x00000100,
    NVAPI_GPU_CAP_STEREO_CAP_SUB_FIELD                    = 0x00000200,
    NVAPI_GPU_CAP_STEREO_CAP_CHECKERBOARD                 = 0x00000400,
    NVAPI_GPU_CAP_STEREO_CAP_INVERSE_CHECKERBOARD         = 0x00000800,
    NVAPI_GPU_CAP_STEREO_CAP_TRIDELITY_SL                 = 0x00001000,
    NVAPI_GPU_CAP_STEREO_CAP_TRIDELITY_MV                 = 0x00002000,
    NVAPI_GPU_CAP_STEREO_CAP_SEEFRONT                     = 0x00004000,
    NVAPI_GPU_CAP_STEREO_CAP_STEREO_MIRROR                = 0x00008000,
    NVAPI_GPU_CAP_STEREO_CAP_FRAME_SEQUENTIAL             = 0x00010000,
    NVAPI_GPU_CAP_STEREO_CAP_USB_EMITTER                  = 0x00020000,
} NVAPI_GPU_CAP_STEREO_CAP;

// Possible return value of queries to NVAPI_GPU_CAP_DEEP_COLOR_CAPS
typedef enum 
{
    NVAPI_GPU_CAP_DEEP_COLOR_CAP_SUPPORTED_BY_GPU          = 0x00000001,
    NVAPI_GPU_CAP_DEEP_COLOR_CAP_SUPPORTED_BY_DISPLAY      = 0x00000002,
    NVAPI_GPU_CAP_DEEP_COLOR_CAP_SUPPORTED_BY_DISPLAY_MODE = 0x00000004,
} NVAPI_GPU_CAP_DEEP_COLOR_CAP;

NVAPI_INTERFACE NvAPI_QueryGpuCap(NvLogicalGpuHandle hLogicalGPU, NVAPI_GPU_CAP capToQuery, NvU32 *pVal);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_NVPM_GetExportSetting
//
//   DESCRIPTION: This will return the U32 value for the current NVPMAPI export
//                setting.  This is usually stored in the registry and include
//                info on if NVPMAPI is enabled, what the debug level is, etc.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_NVPM_GetExportSetting(NvDisplayHandle hNvDisplay, NvU32 *pReturn);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAMES: NvAPI_NVPM_CreateGPUMapping
//                 NvAPI_NVPM_DestroyGPUMapping
//                 NvAPI_NVPM_CreateSharedMemory
//                 NvAPI_NVPM_DestroySharedMemory
//                 NvAPI_NVPM_ReservePerfmonHW
//                 NvAPI_NVPM_ReleasePerfmonHW
//                 NvAPI_NVPM_SetPMTriggerInsert
//
//   DESCRIPTION: Used by NVPMAPI for setting up management of the data segment
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////
typedef struct
{
    NvU32              version;    // Structure version, constructed from macro below
    NvU32              gpuCount;   // Number of mapped GPU memory spaces
    NvU64              hClient[NVAPI_MAX_PHYSICAL_GPUS];
    NvU64              hDevice[NVAPI_MAX_PHYSICAL_GPUS];
    void*             pMapping[NVAPI_MAX_PHYSICAL_GPUS];
} NV_NVPM_GPU_MAPPING;
#define NV_NVPM_GPU_MAPPING_VER  MAKE_NVAPI_VERSION(NV_NVPM_GPU_MAPPING,1)

//  SUPPORTED OS: Windows XP and higher
NVAPI_INTERFACE NvAPI_NVPM_CreateGPUMapping(NV_NVPM_GPU_MAPPING *pMapping);

//  SUPPORTED OS: Windows XP and higher
NVAPI_INTERFACE NvAPI_NVPM_DestroyGPUMapping(NV_NVPM_GPU_MAPPING *pMapping);

//  SUPPORTED OS: Windows XP and higher
NVAPI_INTERFACE NvAPI_NVPM_CreateSharedMemory();

//  SUPPORTED OS: Windows XP and higher
NVAPI_INTERFACE NvAPI_NVPM_DestroySharedMemory();

//  SUPPORTED OS: Windows XP and higher
NVAPI_INTERFACE NvAPI_NVPM_ReservePerfmonHW(NV_NVPM_GPU_MAPPING *pMapping);

//  SUPPORTED OS: Windows XP and higher
NVAPI_INTERFACE NvAPI_NVPM_ReleasePerfmonHW(NV_NVPM_GPU_MAPPING *pMapping);

//  SUPPORTED OS: Windows XP and higher
NVAPI_INTERFACE NvAPI_NVPM_SetPMTriggerInsert(NvDisplayHandle hNvDisplay, NvU32 value);



typedef enum _NV_CPU_TYPE
{
    NV_CPU_TYPE_UNKNOWN         = 0x00000000,
    NV_CPU_TYPE_P5              = 0x00000001, // Intel types
    NV_CPU_TYPE_P55             = 0x00000002,
    NV_CPU_TYPE_P6              = 0x00000003,
    NV_CPU_TYPE_P2              = 0x00000004,
    NV_CPU_TYPE_P2XC            = 0x00000005,
    NV_CPU_TYPE_CELA            = 0x00000006,
    NV_CPU_TYPE_P3              = 0x00000007,
    NV_CPU_TYPE_P3_INTL2        = 0x00000008,
    NV_CPU_TYPE_P4              = 0x00000009,
    NV_CPU_TYPE_CORE2           = 0x00000010,
    NV_CPU_TYPE_CELN_M16H       = 0x00000011,
    NV_CPU_TYPE_CORE2_EXTRM     = 0x00000012,

    NV_CPU_TYPE_IA64            = 0x00000020,

    NV_CPU_TYPE_K5              = 0x00000030, // AMD types
    NV_CPU_TYPE_K6              = 0x00000031,
    NV_CPU_TYPE_K62             = 0x00000032,
    NV_CPU_TYPE_K63             = 0x00000033,
    NV_CPU_TYPE_K7              = 0x00000034,
    NV_CPU_TYPE_K8              = 0x00000035,
    NV_CPU_TYPE_K10             = 0x00000036,
    NV_CPU_TYPE_K11             = 0x00000037,
    NV_CPU_TYPE_C6              = 0x00000060, // IDT/Centaur types
    NV_CPU_TYPE_C62             = 0x00000061,
    NV_CPU_TYPE_GX              = 0x00000070, // Cyrix types
    NV_CPU_TYPE_M1              = 0x00000071,
    NV_CPU_TYPE_M2              = 0x00000072,
    NV_CPU_TYPE_MGX             = 0x00000073,
    NV_CPU_TYPE_TM_CRUSOE       = 0x00000080, // Transmeta types
    NV_CPU_TYPE_PPC603          = 0x00000090, // PowerPC types
    NV_CPU_TYPE_PPC604          = 0x00000091,
    NV_CPU_TYPE_PPC750          = 0x00000092,
} NV_CPU_TYPE;

typedef enum _NV_CPU_CAPABILITIES
{
  NV_CPU_CAP_MMX                    = 0x00000001,
  NV_CPU_CAP_SSE                    = 0x00000002,
  NV_CPU_CAP_3DNOW                  = 0x00000004,
  NV_CPU_CAP_SSE2                   = 0x00000008,
  NV_CPU_CAP_SFENCE                 = 0x00000010,
  NV_CPU_CAP_WRITE_COMBINING        = 0x00000020,
  NV_CPU_CAP_ALTIVEC                = 0x00000040,
  NV_CPU_CAP_PUT_NEEDS_IO           = 0x00000080,
  NV_CPU_CAP_NEEDS_WC_WORKAROUND    = 0x00000100,
  NV_CPU_CAP_3DNOW_EXT              = 0x00000200,
  NV_CPU_CAP_MMX_EXT                = 0x00000400,
  NV_CPU_CAP_CMOV                   = 0x00000800,
  NV_CPU_CAP_CLFLUSH                = 0x00001000,
  NV_CPU_CAP_NEEDS_WAR_190854       = 0x00002000,
  NV_CPU_CAP_SSE3                   = 0x00004000,
  NV_CPU_CAP_NEEDS_WAR_124888       = 0x00008000,
  NV_CPU_CAP_HT_CAPABLE             = 0x00010000,
} NV_CPU_CAPABILITIES;

typedef struct
{
    NvU32 version;                            // Structure version

    NV_CPU_TYPE         type;                 // processor type
    NV_CPU_CAPABILITIES capabilities;         // processor capability flags
    NvU32               clock;                // processor speed (MHz)
    NvU32               L1DataCacheSize;      // L1 dcache size (KB)
    NvU32               L2DataCacheSize;      // L2 dcache size (KB)
    NvU32               dataCacheLineSize;    // L1 dcache bytes/line
    NvU32               numLogicalCpus;       // logial processor count
    NvU32               numPhysicalCpus;      // physical processor count
    NvU32               numCoresOnDie;        // number of CPU cores on die
    NvAPI_ShortString   szEmbeddedName;       // embedded cpu name
} NV_CPU_INFO;
#define NV_CPU_INFO_VER  MAKE_NVAPI_VERSION(NV_CPU_INFO,2)

typedef struct
{
    NvU32 version;                            // Structure version

    NV_CPU_TYPE         type;                 // processor type
    NV_CPU_CAPABILITIES capabilities;         // processor capability flags
    NvU32               clock;                // processor speed (MHz)
    NvU32               L1DataCacheSize;      // L1 dcache size (KB)
    NvU32               L2DataCacheSize;      // L2 dcache size (KB)
    NvU32               dataCacheLineSize;    // L1 dcache bytes/line
    NvU32               numLogicalCpus;       // logial processor count
    NvU32               numPhysicalCpus;      // physical processor count
    NvAPI_ShortString   szEmbeddedName;       // embedded cpu name
} NV_CPU_INFO_v1;
#define NV_CPU_INFO_VER_1  MAKE_NVAPI_VERSION(NV_CPU_INFO_v1,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SYS_GetCpuInfo
//
//   DESCRIPTION: Returns information about the CPU(s) in the system.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: argument is NULL
//                NVAPI_OK: *pInfo is now set
//                NVAPI_INCOMPATIBLE_STRUCT_VERSION - NV_CPU_INFO version not compatible with driver
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_GetCpuInfo(NV_CPU_INFO *pInfo);


typedef struct
{
    NvU32               version;            //structure version
    NvU32               vendorId;           //vendorId
    NvU32               deviceId;           //deviceId
    NvAPI_ShortString   szVendorName;       //vendor Name
    NvAPI_ShortString   szChipsetName;      //device Name
    NvU32               flags;              //Chipset info flags - obsolete
    NvU32               subSysVendorId;     //subsystem vendorId
    NvU32               subSysDeviceId;     //subsystem deviceId
    NvAPI_ShortString   szSubSysVendorName; //subsystem vendor Name
} NV_CHIPSET_INFO;

#define NV_CHIPSET_INFO_VER     MAKE_NVAPI_VERSION(NV_CHIPSET_INFO,3)

typedef enum
{
    NV_CHIPSET_INFO_HYBRID          = 0x00000001,
} NV_CHIPSET_INFO_FLAGS;

typedef struct
{
    NvU32               version;        //structure version
    NvU32               vendorId;       //vendorId
    NvU32               deviceId;       //deviceId
    NvAPI_ShortString   szVendorName;   //vendor Name
    NvAPI_ShortString   szChipsetName;  //device Name
    NvU32               flags;          //Chipset info flags
} NV_CHIPSET_INFO_v2;

#define NV_CHIPSET_INFO_VER_2   MAKE_NVAPI_VERSION(NV_CHIPSET_INFO_v2,2)

typedef struct
{
    NvU32               version;        //structure version
    NvU32               vendorId;       //vendorId
    NvU32               deviceId;       //deviceId
    NvAPI_ShortString   szVendorName;   //vendor Name
    NvAPI_ShortString   szChipsetName;  //device Name
} NV_CHIPSET_INFO_v1;

#define NV_CHIPSET_INFO_VER_1  MAKE_NVAPI_VERSION(NV_CHIPSET_INFO_v1,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SYS_GetChipSetInfo
//
//   DESCRIPTION: Returns information about the System's ChipSet
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pChipSetInfo is NULL
//                NVAPI_OK: *pChipSetInfo is now set
//                NVAPI_INCOMPATIBLE_STRUCT_VERSION - NV_CHIPSET_INFO version not compatible with driver
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_GetChipSetInfo(NV_CHIPSET_INFO *pChipSetInfo);

typedef struct
{
    NvU32 version;    // Structure version, constructed from macro below
    NvU32 currentLidState;
    NvU32 currentDockState;
    NvU32 currentLidPolicy;
    NvU32 currentDockPolicy;
    NvU32 forcedLidMechanismPresent;
    NvU32 forcedDockMechanismPresent;
}NV_LID_DOCK_PARAMS;

#define NV_LID_DOCK_PARAMS_VER  MAKE_NVAPI_VERSION(NV_LID_DOCK_PARAMS,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetLidDockInfo
//
// DESCRIPTION: Returns current lid and dock information.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_OK: now *pLidAndDock contains the returned lid and dock information.
//                NVAPI_ERROR:If any way call is not success.
//                NVAPI_NOT_SUPPORTED:If any way call is not success.
//                NVAPI_HANDLE_INVALIDATED:If nvapi escape result handle is invalid.
//                NVAPI_API_NOT_INTIALIZED:If NVAPI is not initialized.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_GetLidAndDockInfo(NV_LID_DOCK_PARAMS *pLidAndDock);


typedef struct
{
    NvU32               version;        //structure version
    NvU32               sliBondId;
    NvAPI_ShortString   szSliBondName;
} NV_CHIPSET_SLI_BOND_INFO;

#define NV_CHIPSET_SLI_BOND_INFO_VER  MAKE_NVAPI_VERSION(NV_CHIPSET_SLI_BOND_INFO,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SYS_GetChipSetSliBondInfo
//
//   DESCRIPTION: Returns information about the System's ChipSet SLI bond
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pChipSetSliBondInfo is NULL
//                NVAPI_OK: *pChipSetSliBondInfo is now set
//                NVAPI_INCOMPATIBLE_STRUCT_VERSION - NV_CHIPSET_SLI_BOND_INFO version not compatible with driver
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_GetChipSetSliBondInfo(NV_CHIPSET_SLI_BOND_INFO *pChipSetSliBondInfo);



// Video post-processing and color control APIs for private clients
// These add more information and include a device choices

typedef enum _NVAPI_VIDEO_STATE_DEVICE_KIND
{
    NVAPI_VIDEO_DEVICE_KIND_NONE      = -1,
    NVAPI_VIDEO_DEVICE_GLOBAL_DEFAULT     ,        // default         // there is one of default and each mask
    NVAPI_VIDEO_DEVICE_MASK               ,        // by displayId
    NVAPI_VIDEO_DEVICE_EDID               ,        // edid specified  // there can be multiple EDID
    NVAPI_VIDEO_DEVICE_CONNECTOR_TYPE     ,        // GPU connector type
    NVAPI_VIDEO_DEVICE_KIND_LAST
} NVAPI_VIDEO_STATE_DEVICE_KIND;

#define VIDEO_DEVICE_DESCRIPTION_LENGTH     40
#define VIDEO_DEVICE_REG_PREFIX_LENGTH      32

typedef struct _NVAPI_VIDEO_GET_DEVICE_INFO
{
    NvU32   version;                // (IN)  structure version
    NvU32   deviceIndex;            // (IN)  select device
    NvU32   deviceType;             // (OUT) specify what kind of device, one of NVAPI_VIDEO_STATE_DEVICE_KIND
    NvU32   deviceID;               // (OUT) device id (deviceMask, connector type, etc)
    NvU8    deviceDescription[VIDEO_DEVICE_DESCRIPTION_LENGTH];     // (OUT) what is the device
    NvU8    deviceRegistryPrefix[VIDEO_DEVICE_REG_PREFIX_LENGTH];   // (OUT) what is the device
    NvU32   bDefaultGammaCompIdx;   // (OUT) specifies the default gamma (Y/RGB) being used by this video device
    NvU8    reserved[4];            // (OUT) reserved for expansion
} NVAPI_VIDEO_GET_DEVICE_INFO;

#define NVAPI_VIDEO_GET_DEVICE_INFO_VER  MAKE_NVAPI_VERSION(NVAPI_VIDEO_GET_DEVICE_INFO,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetVideoDeviceCount
//
//   DESCRIPTION: Return the number of devices available
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_OK, NVAPI_ERROR
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetVideoDeviceCount(NvDisplayHandle hNvDisplay, NvU32 *pParms);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetVideoDeviceInfo
//
//   DESCRIPTION: return info on the device selected by the index
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_OK, NVAPI_NOT_SUPPORTED, NVAPI_INVALID_ARGUMENT, NVAPI_ERROR
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetVideoDeviceInfo(NvDisplayHandle hNvDisplay, NVAPI_VIDEO_GET_DEVICE_INFO *pParms);

// active video device(s) related enum/struct

typedef enum _NVAPI_ACTIVE_VIDEO_DEVICE
{
    NVAPI_ACTIVE_VIDEO_DEVICE_USER_CHOICE =0, // The accompanying deviceIndex field determines the active device
    NVAPI_ACTIVE_VIDEO_DEVICE_PER_DISPLAY   , // Per-display settings are currently active, deviceIndex is irrelevant
    NVAPI_ACTIVE_VIDEO_DEVICE_LAST
} NVAPI_ACTIVE_VIDEO_DEVICE;

typedef struct _NVAPI_ACTIVE_VIDEO_DEVICE_INFO
{
    NvU32   version;        // (IN)     structure version
    NvU32   activeDevice;   // (IN/OUT) one of NVAPI_ACTIVE_VIDEO_DEVICE, denotes setting choice
    NvU32   deviceIndex;    // (IN/OUT) select device to be set active
    NvU32   reserved[5];    // (IN/OUT) reserved for expansion
} NVAPI_ACTIVE_VIDEO_DEVICE_INFO;

#define NVAPI_ACTIVE_VIDEO_DEVICE_INFO_VER  MAKE_NVAPI_VERSION(NVAPI_ACTIVE_VIDEO_DEVICE_INFO,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetActiveVideoDevice
//
//   DESCRIPTION: Gets the active video device information that is currently being
//                used. The active device being used could correspond to a single
//                video device if the _USER_CHOICE enum is returned. It could also
//                correspond to multiple video devices if the _PER_DISPLAY enum
//                is returned.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_OK, NVAPI_NOT_SUPPORTED, NVAPI_INVALID_ARGUMENT, NVAPI_ERROR
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetActiveVideoDevice(NvDisplayHandle hNvDisplay, NVAPI_ACTIVE_VIDEO_DEVICE_INFO *pActiveVideoDevice);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SetActiveVideoDevice
//
//   DESCRIPTION: Set the active video device to be used. The active device selected
//                could either be specified as a single video device (only _GLOBAL_DEFAULT
//                or _DEVICE_MASK video devices can be set active); or could be
//                dynamically handled by the driver if per-display settings are
//                requested by the client.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_OK, NVAPI_NOT_SUPPORTED, NVAPI_INVALID_ARGUMENT, NVAPI_ERROR
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetActiveVideoDevice(NvDisplayHandle hNvDisplay, NVAPI_ACTIVE_VIDEO_DEVICE_INFO *pActiveVideoDevice);

typedef struct _NVAPI_GET_VIDEO_STATE_COMPONENT_EX
{
    NvU32   version;                            // (IN)  structure version
    NvU32   componentID;                        // (IN)  identify the individual component
    NvU32   deviceIndex;                        // (IN)  select device
    NvU32   bIsSupported                : 1;    // (OUT) set if component is supported by driver
    NvU32   bIsHigherPriorityThanApp    : 1;    // (OUT) flag to indicate priority of control panel setting vs app-nvapi setting
    NvU32   bOverrideAppDefault         : 1;    // (OUT) flag to indicate default priority of CPL setting vs app-nvapi setting
    NvU32   reserved1                   : 29;   // (OUT) reserved for future usage
    NvU32   isEnabled;                          // (OUT) set if component is enabled by the cpl, one or more of NVAPI_VIDEO_COMPONENT_ENABLE bitmasks
    NvU32   defaultEnabledState;                // (OUT) indicates the default enabled state for the cpl setting of this component
    NvU32   minValue;                           // (OUT) min valid value
    NvU32   maxValue;                           // (OUT) max valid value
    NvU32   totalSteps;                         // (OUT) number of steps between min and max
    NvU32   defaultValue;                       // (OUT) defaultNV value
    NvU32   unityValue;                         // (OUT) value prescribed for unity (disabled state)
    NvU32   currentValueActive;                 // (OUT) value in use, if it equals unity, operation can be skipped
    NvU64   defaultAlgo;                        // (OUT) default algo
    NvU64   currentAlgoActive;                  // (OUT) algo in use
    NvU32   appValueInUse  : 1;                 // (OUT) let cpl know if app value is set
    NvU32   appAlgoInUse   : 1;                 // (OUT) let cpl know if app algo is set
    NvU32   reserved2      : 30;                // (OUT) reserved for future usage
    NvU32   appValue;                           // (OUT) app value
    NvU64   appAlgo;                            // (OUT) app algo
    NvU64   lastAlgoSet;                        // (OUT) last cpl algo set - may be different than currentAlgoActive
    NvU32   lastValueSet;                       // (OUT) last cpl value set - may be different than currentActiveValue
    NvU32   reserved3;                          // (OUT) reserved for expansion
    NvU64   reserved4[4];                       // (OUT) reserved for later use
} NVAPI_GET_VIDEO_STATE_COMPONENT_EX;

#define NVAPI_GET_VIDEO_STATE_COMPONENT_EX_VER  MAKE_NVAPI_VERSION(NVAPI_GET_VIDEO_STATE_COMPONENT_EX,1)

typedef struct _NVAPI_SET_VIDEO_STATE_COMPONENT_EX
{
    NvU32   version;                            // (IN) structure version
    NvU32   componentID;                        // (IN) identify the individual state
    NvU32   deviceIndex;                        // (IN) select device
    NvU32   bIsTopPriority  :1;                 // (IN) flag to indicate priority of control panel setting vs app-nvapi setting
    NvU32   reserved1       :31;                // (IN) reserved for expansion
    NvU32   enable;                             // (IN) flag to enable cpl setting of component, one or more of NVAPI_VIDEO_COMPONENT_ENABLE bitmasks
    NvU32   setToValue;                         // (IN) value to use
    NvU64   setToAlgo;                          // (IN) algo to use
    NvU32   retStatus;                          // (OUT) result of video-component-set operation; a combination of VIDEO_COMP_STATUS_xxx bitmasks
    NvU32   reserved2;
    NvU64   reserved3[3];                       // (IN) reserved for later use
} NVAPI_SET_VIDEO_STATE_COMPONENT_EX;

#define NVAPI_SET_VIDEO_STATE_COMPONENT_EX_VER  MAKE_NVAPI_VERSION(NVAPI_SET_VIDEO_STATE_COMPONENT_EX,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetVideoStateEx
//
//   DESCRIPTION: Return the video state component for the control panel
//                for the componentID passed in. Clients may use this call to
//                retrieve the component state for any video device (eg. global,
//                displayId-specific, etc.) by specifying the appropriate device
//                index that has been enumerated using NvAPI_GetVideoDeviceInfo.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_OK, NVAPI_INVALID_ARGUMENT, NVAPI_ERROR
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetVideoStateEx(NvDisplayHandle hNvDisplay, NVAPI_GET_VIDEO_STATE_COMPONENT_EX *pParms);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SetVideoStateEx
//
//   DESCRIPTION: Set the video state component by the control panel. Clients
//                may use this call to set the value/algorithm of a video component
//                for any video device by supplying the device index. Please note
//                that simply setting a value/algorithm for a particular video
//                component on a specific video device does not necessarily mean
//                that this setting will be immediately applied to the video.
//                The setting will be immediately applied only if the current active
//                device corresponds to the requested video device using this API.
//                Clients may inquire about the current active video devices using
//                the NvAPI_GetActiveVideoDevice.
//
//                The video component setting will be determined by choice of following flags
//
//                bIsTopPriority    bEnableXXX      Value used
//                0                 0               if present, App NVAPI value; else defaultNV value
//                0                 1               if present, App NVAPI value; else CPL value
//                1                 0               if present, App NVAPI value; else defaultNV value
//                1                 1               CPL value
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_OK, NVAPI_INVALID_ARGUMENT, NVAPI_ERROR
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetVideoStateEx(NvDisplayHandle hNvDisplay, NVAPI_SET_VIDEO_STATE_COMPONENT_EX *pParms);

///////////////////////////////////////////////////////////////////////////////

// Let the control panel retrieve info on the various streams

typedef enum _NVAPI_VIDEO_FORMAT_LAYOUT
{
    NVAPI_VIDEO_FMT_NONE          = 0,
    NVAPI_VIDEO_FMT_INTERLACED       ,
    NVAPI_VIDEO_FMT_PROGRESSIVE      ,
    NVAPI_VIDEO_FMT_FIELD            ,
    NVAPI_VIDEO_FMT_LAST
} NVAPI_VIDEO_FORMAT_LAYOUT;

#define APP_NAME_LENGTH 64

typedef struct _NVAPI_VIDEO_GET_STREAM_INFO
{
    NvU32   version;                        // (IN)  structure version
    NvU32   streamIndex;                    // (IN)  select stream
    NvU32   deviceIndex;                    // (OUT) specify which device is being applied to the stream
    NvU32   processID;                      // (OUT) app process id
    NvU8    processName[APP_NAME_LENGTH];   // (OUT) app name
    NvU32   streamSrcWidth;                 // (OUT) width
    NvU32   streamSrcHeight;                // (OUT) height
    NvU32   streamSrcFormat;                // (OUT) fourCC
    NvU32   streamFormatLayout;             // (OUT) interlaced or progressive, one of NVAPI_VIDEO_FORMAT_LAYOUT
    NvU32   streamSrcColorSpace;            // (OUT) colorspace of source, one of VIDEO_COMP_ALGO_COLOR_SPACE_xxx bitmask
    NvU32   streamDstWidth;                 // (OUT) width
    NvU32   streamDstHeight;                // (OUT) height
    NvU32   streamDstFormat;                // (OUT) fourCC
    NvU32   streamDstColorSpace;            // (OUT) colorspace of dst, one of VIDEO_COMP_ALGO_COLOR_SPACE_xxx bitmask
    NvU32   streamDstColorRange;            // (OUT) color range of dst, one of VIDEO_COMP_ALGO_COLOR_RANGE_xxx bitmask
    double  streamFreq;                     // (OUT) the video stream freq reported by app, not usable right now = 0
    double  streamFreqDetected;             // (OUT) the video stream freq detected from driver
    double  streamFreqPlayback;             // (OUT) the actual play back freq
    NvU32   curPState;                      // (OUT) the current pstate
    NvU32   curPstateTuningAction;          // (OUT) the status of p-state tuning
    NvU64   lastUpdateTime;                 // (OUT) the last time that the stream is updated, use performance count/frequency
    NvU64   reserved;                       // (OUT) reserved for future use
} NVAPI_VIDEO_GET_STREAM_INFO;

#define NVAPI_VIDEO_GET_STREAM_INFO_VER  MAKE_NVAPI_VERSION(NVAPI_VIDEO_GET_STREAM_INFO,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetVideoStreamCount
//
//   DESCRIPTION: Return the number of streams active
//
//  SUPPORTED OS: Windows Vista and higher
//
// RETURN STATUS: NVAPI_OK, NVAPI_ERROR
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetVideoStreamCount(NvDisplayHandle hNvDisplay, NvU32 *pParms);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetVideoStreamInfo
//
//   DESCRIPTION: Get the stream info by video context by the control panel
//
//  SUPPORTED OS: Windows Vista and higher
//
// RETURN STATUS: NVAPI_OK, NVAPI_INVALID_ARGUMENT, NVAPI_ERROR
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetVideoStreamInfo(NvDisplayHandle hNvDisplay, NVAPI_VIDEO_GET_STREAM_INFO *pParms);

// Let the control panel retrieve info on the various streams
typedef enum {
    NVAPI_AELPG_OPCODE_GET_ELPGINFO  = 0,
    NVAPI_AELPG_OPCODE_GET_AELPGINFO = 1,
    NVAPI_AELPG_OPCODE_HOLDOFF_AELPG = 2,
    NVAPI_AELPG_OPCODE_GET_VIDEOELPGINFO = 3,
}NVAPI_AELPG_OPCODE;

typedef struct _NVAPI_ELPG_INFO
{
    NvU8  initialized;
    NvU8  enabled;
    NvU8  aelpgEnabled;
    NvU32 idleThreshold;
    NvU32 postPowerupThreshold;
    NvU8  powerStateEngine;
    NvU32 gatingCount;
    NvU32 denyCount;
}NVAPI_ELPG_INFO;

typedef NVAPI_ELPG_INFO NVAPI_VIDEO_ELPG_INFO;

#define NVAPI_AELPG_HISTOGRAM_SIZE 16
typedef struct _NVAPI_AELPG_INFO
{
    NvU8  enabled;
    NvU8  active;
    NvU32 holdTimeInSec;
    NvU32 badDecisionCount;
    NvU32 idleFilter;
    NvU32 powerSaving;
    NvU32 gatingCount;
    NvU32 denyCount;
    NvU32 inefficientGatingCount;
    NvU32 avgGatingtimeUs;
    NvU8  histogramBin[NVAPI_AELPG_HISTOGRAM_SIZE];
}NVAPI_AELPG_INFO;

typedef struct _NVAPI_AELPG_REQUEST
{
    NvU32                  version;            // (IN)  structure version
    NVAPI_AELPG_OPCODE     opCode;             // (IN)  opcode: getELPGInfo, getAElpgInfo, holdOffAELPG
    union
    {
        NVAPI_ELPG_INFO    elpgInfo;           // (OUT) elpg info
        NVAPI_AELPG_INFO   aelpgInfo;          // (OUT) aelpg info
        NvU32              aelpgHoldTimeInSec; // (IN)  hold off aelpg for given number of seconds, only valid for opcode NVAPI_AELPG_OPCODE_HOLDOFF_AELPG
    }data;
    NvU64 reserved;
} NVAPI_AELPG_REQUEST;

#define NVAPI_HANDLE_AELPG_VER  MAKE_NVAPI_VERSION(NVAPI_AELPG_REQUEST,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_HandleAELPG
//
//   DESCRIPTION: Get/Set the AELPG by video context by the control panel
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_OK
//                NVAPI_INVALID_ARGUMENT
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE
//                NVAPI_NOT_SUPPORTED
//                NVAPI_INCOMPATIBLE_STRUCT_VERSION
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_HandleAELPG(NvPhysicalGpuHandle hPhysicalGpu, NVAPI_AELPG_REQUEST *pParms);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_OGL_ExpertModeSet[Get]
//
//   DESCRIPTION: Configure OpenGL Expert Mode, an API usage feedback and
//                advice reporting mechanism. The effects of this call are
//                applied only to the current context, and are reset to the
//                defaults when the context is destroyed.
//
//                Note: This feature is valid at runtime only when GLExpert
//                      functionality has been built into the OpenGL driver
//                      installed on the system. All Windows Vista OpenGL
//                      drivers provided by NVIDIA have this instrumentation
//                      included by default. Windows XP, however, requires a
//                      special display driver available with the NVIDIA
//                      PerfSDK found at developer.nvidia.com.
//
//                Note: These functions are valid only for the current OpenGL
//                      context. Calling these functions prior to creating a
//                      context and calling MakeCurrent with it will result
//                      in errors and undefined behavior.
//
//    PARAMETERS: expertDetailMask  Mask made up of NVAPI_OGLEXPERT_DETAIL bits,
//                                  this parameter specifies the detail level in
//                                  the feedback stream.
//
//                expertReportMask  Mask made up of NVAPI_OGLEXPERT_REPORT bits,
//                                  this parameter specifies the areas of
//                                  functional interest.
//
//                expertOutputMask  Mask made up of NVAPI_OGLEXPERT_OUTPUT bits,
//                                  this parameter specifies the feedback output
//                                  location.
//
//                expertCallback    Used in conjunction with OUTPUT_TO_CALLBACK,
//                                  this is a simple callback function the user
//                                  may use to obtain the feedback stream. The
//                                  function will be called once per fully
//                                  qualified feedback stream entry.
//
// RETURN STATUS: NVAPI_API_NOT_INTIALIZED         : NVAPI not initialized
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND    : no NVIDIA GPU found
//                NVAPI_OPENGL_CONTEXT_NOT_CURRENT : no NVIDIA OpenGL context
//                                                   which supports GLExpert
//                                                   has been made current
//                NVAPI_ERROR : OpenGL driver failed to load properly
//                NVAPI_OK    : success
//
///////////////////////////////////////////////////////////////////////////////
#define NVAPI_OGLEXPERT_DETAIL_NONE                 0x00000000
#define NVAPI_OGLEXPERT_DETAIL_ERROR                0x00000001
#define NVAPI_OGLEXPERT_DETAIL_SWFALLBACK           0x00000002
#define NVAPI_OGLEXPERT_DETAIL_BASIC_INFO           0x00000004
#define NVAPI_OGLEXPERT_DETAIL_DETAILED_INFO        0x00000008
#define NVAPI_OGLEXPERT_DETAIL_PERFORMANCE_WARNING  0x00000010
#define NVAPI_OGLEXPERT_DETAIL_QUALITY_WARNING      0x00000020
#define NVAPI_OGLEXPERT_DETAIL_USAGE_WARNING        0x00000040
#define NVAPI_OGLEXPERT_DETAIL_ALL                  0xFFFFFFFF

#define NVAPI_OGLEXPERT_REPORT_NONE                 0x00000000
#define NVAPI_OGLEXPERT_REPORT_ERROR                0x00000001
#define NVAPI_OGLEXPERT_REPORT_SWFALLBACK           0x00000002
#define NVAPI_OGLEXPERT_REPORT_PIPELINE_VERTEX      0x00000004
#define NVAPI_OGLEXPERT_REPORT_PIPELINE_GEOMETRY    0x00000008
#define NVAPI_OGLEXPERT_REPORT_PIPELINE_XFB         0x00000010
#define NVAPI_OGLEXPERT_REPORT_PIPELINE_RASTER      0x00000020
#define NVAPI_OGLEXPERT_REPORT_PIPELINE_FRAGMENT    0x00000040
#define NVAPI_OGLEXPERT_REPORT_PIPELINE_ROP         0x00000080
#define NVAPI_OGLEXPERT_REPORT_PIPELINE_FRAMEBUFFER 0x00000100
#define NVAPI_OGLEXPERT_REPORT_PIPELINE_PIXEL       0x00000200
#define NVAPI_OGLEXPERT_REPORT_PIPELINE_TEXTURE     0x00000400
#define NVAPI_OGLEXPERT_REPORT_OBJECT_BUFFEROBJECT  0x00000800
#define NVAPI_OGLEXPERT_REPORT_OBJECT_TEXTURE       0x00001000
#define NVAPI_OGLEXPERT_REPORT_OBJECT_PROGRAM       0x00002000
#define NVAPI_OGLEXPERT_REPORT_OBJECT_FBO           0x00004000
#define NVAPI_OGLEXPERT_REPORT_FEATURE_SLI          0x00008000
#define NVAPI_OGLEXPERT_REPORT_ALL                  0xFFFFFFFF

#define NVAPI_OGLEXPERT_OUTPUT_TO_NONE              0x00000000
#define NVAPI_OGLEXPERT_OUTPUT_TO_CONSOLE           0x00000001
#define NVAPI_OGLEXPERT_OUTPUT_TO_DEBUGGER          0x00000004
#define NVAPI_OGLEXPERT_OUTPUT_TO_CALLBACK          0x00000008
#define NVAPI_OGLEXPERT_OUTPUT_TO_ALL               0xFFFFFFFF

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION TYPE: NVAPI_OGLEXPERT_CALLBACK
//
//   DESCRIPTION: Used in conjunction with OUTPUT_TO_CALLBACK, this is a simple
//                callback function the user may use to obtain the feedback
//                stream. The function will be called once per fully qualified
//                feedback stream entry.
//
//    PARAMETERS: categoryId   Contains the bit from the NVAPI_OGLEXPERT_REPORT
//                             mask that corresponds to the current message
//                messageId    Unique Id for the current message
//                detailLevel  Contains the bit from the NVAPI_OGLEXPERT_DETAIL
//                             mask that corresponds to the current message
//                objectId     Unique Id of the object that corresponds to the
//                             current message
//                messageStr   Text string from the current message
//
///////////////////////////////////////////////////////////////////////////////
typedef void (* NVAPI_OGLEXPERT_CALLBACK) (unsigned int categoryId, unsigned int messageId, unsigned int detailLevel, int objectId, const char *messageStr);

//  SUPPORTED OS: Windows XP and higher
NVAPI_INTERFACE NvAPI_OGL_ExpertModeSet(NvU32 expertDetailLevel,
                                        NvU32 expertReportMask,
                                        NvU32 expertOutputMask,
                     NVAPI_OGLEXPERT_CALLBACK expertCallback);


//  SUPPORTED OS: Windows XP and higher
NVAPI_INTERFACE NvAPI_OGL_ExpertModeGet(NvU32 *pExpertDetailLevel,
                                        NvU32 *pExpertReportMask,
                                        NvU32 *pExpertOutputMask,
                     NVAPI_OGLEXPERT_CALLBACK *pExpertCallback);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_OGL_ExpertModeDefaultsSet[Get]
//
//   DESCRIPTION: Configure OpenGL Expert Mode global defaults. These settings
//                apply to any OpenGL application which starts up after these
//                values are applied (i.e. these settings *do not* apply to
//                currently running applications).
//
//    PARAMETERS: expertDetailLevel Value which specifies the detail level in
//                                  the feedback stream. This is a mask made up
//                                  of NVAPI_OGLEXPERT_LEVEL bits.
//
//                expertReportMask  Mask made up of NVAPI_OGLEXPERT_REPORT bits,
//                                  this parameter specifies the areas of
//                                  functional interest.
//
//                expertOutputMask  Mask made up of NVAPI_OGLEXPERT_OUTPUT bits,
//                                  this parameter specifies the feedback output
//                                  location. Note that using OUTPUT_TO_CALLBACK
//                                  here is meaningless and has no effect, but
//                                  using it will not cause an error.
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////

//  SUPPORTED OS: Windows XP and higher
NVAPI_INTERFACE NvAPI_OGL_ExpertModeDefaultsSet(NvU32 expertDetailLevel,
                                                NvU32 expertReportMask,
                                                NvU32 expertOutputMask);

//  SUPPORTED OS: Windows XP and higher
NVAPI_INTERFACE NvAPI_OGL_ExpertModeDefaultsGet(NvU32 *pExpertDetailLevel,
                                                NvU32 *pExpertReportMask,
                                                NvU32 *pExpertOutputMask);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetGFAHandle()
//
//   DESCRIPTION: Used by driver security tools.  Not for export outside NVIDIA.
//                Contact Andrei Osnovich regarding this API.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetGFAHandle(void **GFAHandle);

#define NVAPI_MAX_VIEW_TARGET  2

typedef enum _NV_TARGET_VIEW_MODE
{
    NV_VIEW_MODE_STANDARD  = 0,
    NV_VIEW_MODE_CLONE     = 1,
    NV_VIEW_MODE_HSPAN     = 2,
    NV_VIEW_MODE_VSPAN     = 3,
    NV_VIEW_MODE_DUALVIEW  = 4,
    NV_VIEW_MODE_MULTIVIEW = 5,
} NV_TARGET_VIEW_MODE;


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_GetPersistenceData [Set]
//   DESCRIPTION: Retrieves, saves, and finds persist data stored in the persist file
//
//         INPUT: hPhysicalGpu - unused (reserved for later)
//
//                pData - Detailed persistnce data structure.
//
//                flags - Persistence find flags (see defines for description)
//
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hNvDisplay is invalid
//                NVAPI_OK: the persist operation succeed
//                NVAPI_ERROR: the persist operation failed
//
///////////////////////////////////////////////////////////////////////////////

// Persistence find flags

// Inputs: for the GetPersistenceData call
#define NV_PERSIST_FIND_LAST_MODE     0x00000001            //find last mode configuration
// activeMask: required [index 0 is GDI primary display]
// connectedMasks: optional
// hPhysicalGpu: optional

#define NV_PERSIST_FIND_LAST_ACTIVE   0x00000002            //find last active configuration
// connectedMasks: optional
// hPhysicalGpu: optional

// The following is a flag which must be ORed with an NV_PERSIST_FIND_ method
//  This flag is used when the EDIDs of the connected devices are already known, and
//  a lookup for persistence is needed based on this information.
#define NV_PERSIST_EDID_SUPPLIED      0x80000000            //EDID is supplied in the structure

#define NV_PERSIST_FIND_CURRENT       0x00000003            //find current active configuration
// activeMask: required [index 0 is GDI primary display]
// connectedMasks: optional
// hPhysicalGpu: optional

// The following is a flag which must be ORed with an NV_PERSIST_FIND_ method
//  This flag is used when the EDIDs of the connected devices are already known, and
//  a lookup for persistence is needed based on this information.
#define NV_PERSIST_EDID_SUPPLIED      0x80000000            //EDID is supplied in the structure
// connectedMasks: required [EDIDs are ordered from rightmost bit to left]
// activeMask: based on NV_PERSIST_FIND_ method selected
// hPhysicalGpu: ignored
//  NOTE: Not supported for NV_PERSIST_FIND_CURRENT


// Defines to support backward compatibility (to be removed once integration completed)
#define MAX_PERSIST_DEVICES 8

typedef struct
{
    NvU32 width;                                // (IN/OUT) gdi width
    NvU32 height;                               // (IN/OUT) gdi height
    NvU32 depth;                                // (IN/OUT) gdi color depth
    NvU32 refresh;                              // (IN/OUT) gdi refresh rate
    NvU32 interlaced;                           // (IN/OUT) interlaced mode
    NvU32 primary:1;                            // (IN/OUT) desktop primary
    NvU32 posx;                                 // (IN/OUT) gdi x position
    NvU32 posy;                                 // (IN/OUT) gdi y position
} NV_PERSIST_MODE;

typedef struct
{
    NvU32 activeMask;                           // (IN/OUT)active device mask
    NV_TARGET_VIEW_MODE state;                  // (IN/OUT) nview state
    NvU32 rotation;                             // (IN/OUT) nview rotation
    NvU32 scaling;                              // (IN/OUT) nview scaling
    NvU32 tvFormat;                             // (IN/OUT) tv format
    NV_PERSIST_MODE physicalMode;               // (IN/OUT) physical mode
    NV_PERSIST_MODE virtualMode;                // (IN/OUT) virtual mode
} NV_PERSIST_DATA;

typedef struct
{
    NvU32                   version;                        // (IN) structure version
    NvAPI_LongString        lookupKey;                      // (IN/OUT) lookupKey strings
    NvU32                   connectedMasks;                 // (IN/OUT) connected device mask
    NvU32                   count;                          // (IN/OUT) target count
    NV_PERSIST_DATA         target[NVAPI_MAX_VIEW_TARGET];  // (IN/OUT) persist data
} NV_PERSIST_DATA_INFO1;

typedef struct
{
    NvU32                   version;                        // (IN) structure version
    NvAPI_LongString        lookupKey;                      // (IN/OUT) lookupKey strings
    NvU32                   connectedMasks;                 // (IN/OUT) connected device mask
    NvU32                   count;                          // (IN/OUT) target count
    NV_PERSIST_DATA         target[NVAPI_MAX_VIEW_TARGET];  // (IN/OUT) persist data
    NV_EDID                 connectedEDIDs[NVAPI_MAX_HEADS_PER_GPU];      // (IN) Connected EDID list, based on connectedMask from right to left
} NV_PERSIST_DATA_INFO2;

typedef NV_PERSIST_DATA_INFO2  NV_PERSIST_DATA_INFO;

#define NV_PERSIST_DATA_INFO_VER1  MAKE_NVAPI_VERSION(NV_PERSIST_DATA_INFO1,1)
#define NV_PERSIST_DATA_INFO_VER2  MAKE_NVAPI_VERSION(NV_PERSIST_DATA_INFO2,2)
#define NV_PERSIST_DATA_INFO_VER   NV_PERSIST_DATA_INFO_VER2

//  SUPPORTED OS: Windows XP and higher
NVAPI_INTERFACE NvAPI_GetPersistenceData(NvPhysicalGpuHandle hPhysicalGpu, NV_PERSIST_DATA_INFO *pData, NvU32 flags);

//  SUPPORTED OS: Windows XP and higher
NVAPI_INTERFACE NvAPI_SetPersistenceData(NvPhysicalGpuHandle hPhysicalGpu, NV_PERSIST_DATA_INFO *pData);


// Following definitions are used in NvAPI_SetViewEx.
// Scaling modes
typedef enum _NV_SCALING
{
    NV_SCALING_DEFAULT          = 0,        // No change
    NV_SCALING_MONITOR_SCALING  = 1,
    NV_SCALING_ADAPTER_SCALING  = 2,
    NV_SCALING_CENTERED         = 3,
    NV_SCALING_ASPECT_SCALING   = 5,
    NV_SCALING_CUSTOMIZED       = 255       // For future use
} NV_SCALING;

// Rotate modes
typedef enum _NV_ROTATE
{
    NV_ROTATE_0           = 0,
    NV_ROTATE_90          = 1,
    NV_ROTATE_180         = 2,
    NV_ROTATE_270         = 3,
    NV_ROTATE_IGNORED     = 4,
} NV_ROTATE;

// Color formats
typedef enum _NV_FORMAT
{
    NV_FORMAT_UNKNOWN       =  0,       // unknown. Driver will choose one as following value.
    NV_FORMAT_P8            = 41,       // for 8bpp mode
    NV_FORMAT_R5G6B5        = 23,       // for 16bpp mode
    NV_FORMAT_A8R8G8B8      = 21,       // for 32bpp mode
    NV_FORMAT_A16B16G16R16F = 113       // for 64bpp(floating point) mode.
} NV_FORMAT;

// TV standard


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SetDisplaySettings
//
// DESCRIPTION:     This API caller set the display settings for a selected display source.
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      hNvDisplay(IN) - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                  pPaths(IN) - Detailed target display arrangement for clone, span and edge blending display modes.
//                  pathCount(IN) - Count of targets for the selected display source.
//                  Note: Display PATH with this API is limited to single GPU. DUALVIEW across GPUs cannot be enabled with this API. 
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT: Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////

// the connector is not support yet, must be set to _AUTO
typedef enum _NV_CONNECTOR
{
    NV_CONN_AUTO = 0,
}NV_CONNECTOR;

// the timing override is not support yet, must be set to _AUTO
// Make sure to keep this in sync with NVL_TIMING_OVERRIDE from drivers/common/inc/nvlEscDef.h
typedef enum _NV_TIMING_OVERRIDE
{
    NV_TIMING_OVERRIDE_CURRENT = 0,          // get the current timing
    NV_TIMING_OVERRIDE_AUTO,                 // the timing the driver will use based the current policy
    NV_TIMING_OVERRIDE_EDID,                 // EDID timing
    NV_TIMING_OVERRIDE_DMT,                  // VESA DMT timing
    NV_TIMING_OVERRIDE_DMT_RB,               // VESA DMT timing with reduced blanking
    NV_TIMING_OVERRIDE_CVT,                  // VESA CVT timing
    NV_TIMING_OVERRIDE_CVT_RB,               // VESA CVT timing with reduced blanking
    NV_TIMING_OVERRIDE_GTF,                  // VESA GTF timing
    NV_TIMING_OVERRIDE_EIA861,               // EIA 861x pre-defined timing
    NV_TIMING_OVERRIDE_ANALOG_TV,            // analog SD/HDTV timing
    NV_TIMING_OVERRIDE_CUST,                 // NV custom timings
    NV_TIMING_OVERRIDE_NV_PREDEFINED,        // NV pre-defined timing (basically the PsF timings)
    NV_TIMING_OVERRIDE_NV_PSF                = NV_TIMING_OVERRIDE_NV_PREDEFINED,

    NV_TIMING_OVERRIDE_NV_ASPR,

    NV_TIMING_OVRRIDE_MAX,
}NV_TIMING_OVERRIDE;

typedef struct
{
    float x;    //the x-coordinate of the viewport top-left point
    float y;    //the y-coordinate of the viewport top-left point
    float w;    //the width of the viewport
    float h;    //the height of the viewport
} NV_VIEWPORTF;

//***********************
// The Timing Structure
//***********************
//
// NVIDIA specific timing extras
typedef struct tagNV_TIMINGEXT
{
    NvU32   flag;          // reserve for NV h/w based enhancement like double-scan.
    NvU16   rr;            // the logical refresh rate to present
    NvU32   rrx1k;         // the physical vertical refresh rate in 0.001Hz
    NvU32   aspect;        // the display aspect ratio Hi(aspect):horizontal-aspect, Low(aspect):vertical-aspect
    NvU16   rep;           // bit wised pixel repetition factor: 0x1:no pixel repetition; 0x2:each pixel repeats twice horizontally,..
    NvU32   status;        // the timing standard being used
    NvU8    name[40];      // the name of the timing
}NV_TIMINGEXT;

//
//
//The very basic timing structure based on the VESA standard:
//
//           |<----------------------------htotal--------------------------->|
//            ---------"active" video-------->|<-------blanking------>|<-----
//           |<-------hvisible-------->|<-hb->|<-hfp->|<-hsw->|<-hbp->|<-hb->|
// ----------+-------------------------+      |       |       |       |      |
//   A     A |                         |      |       |       |       |      |
//   :     : |                         |      |       |       |       |      |
//   :     : |                         |      |       |       |       |      |
//   :verical|    addressable video    |      |       |       |       |      |
//   :visible|                         |      |       |       |       |      |
//   :     : |                         |      |       |       |       |      |
//   :     : |                         |      |       |       |       |      |
// verical V |                         |      |       |       |       |      |
//  total  --+-------------------------+      |       |       |       |      |
//   :     vb         border                  |       |       |       |      |
//   :     -----------------------------------+       |       |       |      |
//   :     vfp        front porch                     |       |       |      |
//   :     -------------------------------------------+       |       |      |
//   :     vsw        sync width                              |       |      |
//   :     ---------------------------------------------------+       |      |
//   :     vbp        back porch                                      |      |
//   :     -----------------------------------------------------------+      |
//   V     vb         border                                                 |
// --------------------------------------------------------------------------+
//
typedef struct tagNV_TIMING
{
    // VESA scan out timing parameters:
    NvU16 HVisible;         //horizontal visible
    NvU16 HBorder;          //horizontal border
    NvU16 HFrontPorch;      //horizontal front porch
    NvU16 HSyncWidth;       //horizontal sync width
    NvU16 HTotal;           //horizontal totel
    NvU8  HSyncPol;         //horizontal sync polarity: 1-negative, 0-positive

    NvU16 VVisible;         //vertical visible
    NvU16 VBorder;          //vertical border
    NvU16 VFrontPorch;      //vertical front porch
    NvU16 VSyncWidth;       //vertical sync width
    NvU16 VTotal;           //vertical total
    NvU8  VSyncPol;         //vertical sync polarity: 1-negative, 0-positive

    NvU16 interlaced;       //1-interlaced, 0-progressive
    NvU32 pclk;             //pixel clock in 10KHz

    //other timing related extras
    NV_TIMINGEXT etc;
}NV_TIMING;

// timing related constants:
#define NV_TIMING_H_SYNC_POSITIVE                             0
#define NV_TIMING_H_SYNC_NEGATIVE                             1
#define NV_TIMING_H_SYNC_DEFAULT                              NV_TIMING_H_SYNC_NEGATIVE
//
#define NV_TIMING_V_SYNC_POSITIVE                             0
#define NV_TIMING_V_SYNC_NEGATIVE                             1
#define NV_TIMING_V_SYNC_DEFAULT                              NV_TIMING_V_SYNC_POSITIVE
//
#define NV_TIMING_PROGRESSIVE                                 0
#define NV_TIMING_INTERLACED                                  1
#define NV_TIMING_INTERLACED_EXTRA_VBLANK_ON_FIELD2           1
#define NV_TIMING_INTERLACED_NO_EXTRA_VBLANK_ON_FIELD2        2

typedef enum _NVAPI_TIMING_TYPE
{
    NV_TIMING_TYPE_DMT = 1,                                 // DMT
    NV_TIMING_TYPE_GTF,                                     // GTF
    NV_TIMING_TYPE_ASPR,                                    // wide aspect ratio timing, for legacy support only
    NV_TIMING_TYPE_NTSC_TV,                                 // NTSC TV timing. for legacy support only
    NV_TIMING_TYPE_PAL_TV,                                  // PAL TV timing, legacy support only
    NV_TIMING_TYPE_CVT,                                     // CVT timing
    NV_TIMING_TYPE_CVT_RB,                                  // CVT timing with reduced blanking
    NV_TIMING_TYPE_CUST,                                    // Customized timing
    NV_TIMING_TYPE_EDID_DTD,                                // EDID detailed timing
    NV_TIMING_TYPE_EDID_STD,                                // EDID standard timing
    NV_TIMING_TYPE_EDID_EST,                                // EDID established timing
    NV_TIMING_TYPE_EDID_CVT,                                // EDID defined CVT timing (EDID 1.4)
    NV_TIMING_TYPE_EDID_861ST,                              // EDID defined CEA/EIA 861 timing (in the EDID 861 extension)
    NV_TIMING_TYPE_NV_PREDEFINED,                           // NV pre-defined timings (PsF timings)
    NV_TIMING_TYPE_DMT_RB,                                  // DMT timing with reduced blanking
    NV_TIMING_TYPE_EDID_EXT_DTD,                            // EDID detailed timing in the extension
    NV_TIMING_TYPE_SDTV,                                    // SDTV timing (including NTSC, PAL etc)
    NV_TIMING_TYPE_HDTV,                                    // HDTV timing (480p,480i,720p, 1080i etc)
}NVAPI_TIMING_TYPE;


// config on specified display is not supported yet
#define NV_DISP_INDEX_AUTO 0

// the generic display target config info which is independent of any specific mode
typedef struct
{
    NvU32                   version;    // Structure version

    NvU32                   device;     // target display ids or target device mask
    NV_GPU_CONNECTOR_TYPE   connector;

    // the source display index
    NvU32                   srcID;

    // the source importance
    NvU32                   srcImportance; //(OUT) Indicates if this is the GPU's primary view target. This is not the desktop GDI primary.
                                           //NvAPI_SetDisplaySettings automatically selects the first target in NV_DISP_PATH index 0 as the GPU's primary view.
    // the source mode information
    NvU32                   width;
    NvU32                   height;
    NvU32                   depth;
    NV_ROTATE               rotation;
    NV_FORMAT               colorFormat;       // color format. Not used now.

    // the section of the source surface for scan out, defined in normalized desktop coordinates
    NV_VIEWPORTF            srcPartition;      // not used now

    // the scan out viewport in (at the front end, i.e. the compositor/CRTC).
    // defined in the normalized desktop coordinates
    NV_VIEWPORTF            viewportIn ;       // not used now

    // the scaling mode
    NV_SCALING              scaling;

    // the scan out viewport out (at the front end, i.e. the compositor/CRTC).
    // this is for the future arbitrary scaling support (not supported by any the current GPUs)
    // defined in the normalized raster/backend timing coordinates
    // viewportOut is not supported yet, must be set to {0.0, 0.0, 0.0, 0.0}
    NV_VIEWPORTF            viewportOut;       // not used now

    // the backend (raster) timing standard
    NV_TIMING_OVERRIDE      timingOverride;

    NvU32                   refreshRate;        // only used for backward compatible when NV_DISP_PATH_VER1 is specified
    NvU32                   interlaced    :1;   // only used for backward compatible when NV_DISP_PATH_VER1 is specified
    NvU32                   hwModeSetOnly :1;   // if this flag is set, the modeset is a pure h/w modeset without OS update. Only used with NV_DISP_PATH_VER;
    NvU32                   SelectCustomTiming:1;    // For HD modes over DVI to select custom timings
    NvU32                   needNullModeset   :1;    // for read only - indicating a NULL modeset is needed on this monitor (for internal DP link training)
    NvU32                   need6x4Modeset    :1;    // for read only - indicating a 640x480x32bppx60Hz modeset is needed (for DP bad EDID fallback)
    NvU32                   forceModeSet      :1;    // Used only on Win7 and higher during a call to NvAPI_SetDisplaySettings. Turns off optimization & forces OS to set supplied mode.
    NvU32                   gpuId             :24;   // the display/target physical Gpu id which is the owner of the scan out (for SLI multimon, display from the slave Gpu)
    NvU32                   isSliFocusDisplay :1;    // this display path is the sli focus (so far it's read only)

    NV_DISPLAY_TV_FORMAT    tvFormat;           // Valid only on TV device. set to 0 for Other devices.

    NV_TIMING               timing;             // the scan out timing, NV_DISP_PATH_VER2 only, ignored it's on analog TV.

} NV_DISP_PATH;

#define NV_DISP_PATH_VER  NV_DISP_PATH_VER3
#define NV_DISP_PATH_VER3 MAKE_NVAPI_VERSION(NV_DISP_PATH,3)
#define NV_DISP_PATH_VER2 MAKE_NVAPI_VERSION(NV_DISP_PATH,2)
#define NV_DISP_PATH_VER1 MAKE_NVAPI_VERSION(NV_DISP_PATH,1)

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SetDisplaySettings
//
// DESCRIPTION:     This API caller set the display settings for selected display sources.
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      hNvDisplay(IN) - NVIDIA Display selection. NVAPI_DEFAULT_HANDLE not allowed, it has to be a handle enumerated with NvAPI_EnumNVidiaDisplayHandle().
//                  pPaths(IN) - Detailed target display arrangement for clone, span and edge blending display modes.
//                  pathCount(IN) - Count of targets for the selected display source.
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT: Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetDisplaySettings(NvDisplayHandle hNvDisplay, NV_DISP_PATH *paths, NvU32 pathCount);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetDisplaySettings
//
// DESCRIPTION:     This API lets caller retrieve the target display arrangement for a selected display source.
//                  Note: Display PATH with this API is limited to single GPU. DUALVIEW across GPUs will be returned as STANDARD VIEW. 
//                        Please use NvAPI_SYS_GetDisplayTopologies to query views across GPUs.
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      hNvDisplay(IN) - NVIDIA Display selection. NVAPI_DEFAULT_HANDLE not allowed, it has to be a handle enumerated with NvAPI_EnumNVidiaDisplayHandle().
//                  pPaths(OUT) - Target display informatiom.
//                  pPathCount(OUT) - Count of targets on the selected display source.
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT: Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetDisplaySettings(NvDisplayHandle hNvDisplay, NV_DISP_PATH *pPaths, NvU32 *pPathCount);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetTiming
//
// DESCRIPTION:     Calculate the timing from the visible width/height/refresh-rate and timing type info
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:      hNvDisplay(IN) - NVIDIA Display selection. NVAPI_DEFAULT_HANDLE not allowed, it has to be a handle enumerated with NvAPI_EnumNVidiaDisplayHandle().
//                  width    - the horizontal visible size
//                  heigth   - the veritical visible size
//                  rr       - the refresh rate of the timing
//                  flag     - the flag to pass in addtional info for timing calculation.
//                  outputId - the monitor Id(mask), only used to get EDID timing or custom timing or NV policy related timing(NV_TIMING_OVERRIDE_AUTO).
//                  type     - the timing type(formula) to use to calculate the timing
//                  pT(OUT)  - the pointer to the NV_TIMING structure
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT: Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////
typedef struct
{
    NvU32                   isInterlaced   : 4;  // to retrieve interlaced/progressive timing
    NvU32                   reserved0      : 12;
    union
    {
        NvU32               tvFormat       : 8;  // the actual analog HD/SDTV format. Used when the timing type is NV_TIMING_OVERRIDE_ANALOG_TV and
                                                 // and width==height==rr==0;
        NvU32               ceaId          : 8;  // the EIA/CEA 861B/D predefined short timing descriptor ID. Used when the timing type is  NV_TIMING_OVERRIDE_EIA861;
                                                 // and width==height==rr==0;
        NvU32               nvPsfId        : 8;  // the NV predefined PsF format Id. Used when the timing type is NV_TIMING_OVERRIDE_NV_PREDEFINED.
    };
    NvU32                   scaling        : 8;  // define prefered scaling
}NV_TIMING_FLAG;

#define NV_GET_CEA_FORMAT(n) (((n)&0x3F800000)>>23)     // Get CEA format (digital TV format) from NV_TIMING(::etc.status)
#define NV_GET_ANALOG_TV_FORMAT(n) ((((n)&0x0FF00)==0x1100||((n)&0x0FF00)==0x1200)?((n)&0x0FF):0)   // Get the analog TV format from NV_TIMING(::etc.status)
#define NV_IS_ANALOG_TV_FORMAT(n)  ((((n)&0x0FF00)==0x1100||((n)&0x0FF00)==0x1200)?1:0)             // Check if the timing(NV_TIMING::etc.status) is an analog TV format

NVAPI_INTERFACE NvAPI_GetTiming(NvDisplayHandle hNvDisplay, NvU32 width, NvU32 height, float rr, NV_TIMING_FLAG flag, NvU32 outputId, NV_TIMING_OVERRIDE type, NV_TIMING *pT);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_EnumCustomDisplay
//
// DESCRIPTION:     Calculate the timing from the visible width/height/refresh-rate and timing type info
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:      hNvDisplay(IN) - NVIDIA Display selection. NVAPI_DEFAULT_HANDLE not allowed, it has to be a handle enumerated with NvAPI_EnumNVidiaDisplayHandle().
//                  index - the enum index
//                  outputId - the monitor Id only which the custom display config should be applied. "-1" is to enum all custom display config
//                  pC(OUT)  - the pointer to the NV_CUSTOM_DISPLAY structure
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT: Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////

typedef struct
{
    NvU32                   version;

    // the source mode information
    NvU32                   width;                   // source surface(source mode) width
    NvU32                   height;                  // source surface(source mode) height
    NvU32                   depth;                   // source surface color depth."0" means all 8/16/32bpp
    NV_FORMAT               colorFormat;             // color format. (optional)

    NV_VIEWPORTF            srcPartition;            // for multimon support, should be set to (0,0,1.0,1.0) for now.

    float                   xRatio;                  // the horizontal scaling ratio
    float                   yRatio;                  // the vertical scaling ratio

    NV_TIMING               timing;                  // the timing used to program TMDS/DAC/LVDS/HDMI/TVEncoder etc
    NvU32                   hwModeSetOnly : 1;         // if set, it means a h/w modeset without OS update

}NV_CUSTOM_DISPLAY;

#define NV_CUSTOM_DISPLAY_VER  MAKE_NVAPI_VERSION(NV_CUSTOM_DISPLAY,1)
NVAPI_INTERFACE NvAPI_EnumCustomDisplay(NvDisplayHandle hNvDisplay, NvU32 index, NvU32 outputId, NV_CUSTOM_DISPLAY *pC);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_TryCustomDisplay
//
// DESCRIPTION:     This API is a wrapper function of NvAPI_SetDisplaySettings to setup a custom display without saving the config.
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:      hNvDisplay(IN) - NVIDIA Display selection. NVAPI_DEFAULT_HANDLE not allowed, it has to be a handle enumerated with NvAPI_EnumNVidiaDisplayHandle().
//                  pDispOutId(IN) - the array of the target monitor output Ids
//                  pCustDisp(IN) - a pointer to the NV_CUSTOM_DISPLAY structure.
//                  count(IN) - the total number of the incoming NV_CUSTOM_DISPLAY structure. This is for the multi-head support
//                  hwModeSetOnly(IN) - the option to let the user flush the timing without OS update
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT: Invalid input parameter.
//                  NVAPI_NO_IMPLEMENTATION:Not implemented.
//                  NVAPI_INCOMPATIBLE_STRUCT_VERSION:the version of NV_CUSTOM_DISPLAY is not supported
//
// NOTES :          In clone mode the timings can applied to both the target monitors but only one target at a time.
//                  For the secondary target the applied timings works under the following conditions:
//                  1. if the secondary monitor EDID supports the selected timing OR
//                  2. if the selected custom timings can be scaled by the secondary monitor for the selected source resolution on the primary OR
//                  3. if the selected custom timings matches the existing source resolution on the primary.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_TryCustomDisplay(NvDisplayHandle hNvDisplay, NvU32 *pDispOutputId, NV_CUSTOM_DISPLAY *pCustDisp, NvU32 count, NvU32 hwModeSetOnly);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_RevertCustomDisplayTrial
//
// DESCRIPTION:     This API is used to restore the old display config before NvAPI_TryCustomDisplay is called. This function
//                  can only be called after custom display config is tried on the h/w (i.e. NvAPI_TryCustomDisplay() is called).
//                  Otherwise this function won't take any action.
//                  In XP, it is not supported so it will return NVAPI_NO_IMPLEMENTATION.
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      hNvDisplay(IN) - NVIDIA Display selection. NVAPI_DEFAULT_HANDLE not allowed, it has to be a handle enumerated with NvAPI_EnumNVidiaDisplayHandle().
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT: Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_RevertCustomDisplayTrial(NvDisplayHandle hNvDisplay);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DeleteCustomDisplay
//
// DESCRIPTION:     Delete the index specified custom display configuration from registry.
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:      hNvDisplay(IN) - NVIDIA Display selection. NVAPI_DEFAULT_HANDLE not allowed, it has to be a handle enumerated with NvAPI_EnumNVidiaDisplayHandle().
//                  displayOutputId(IN) - 1. the display Id on which the underscan config is to apply. It has to be a legal display Id (one bit set)
//                                        2. "0" is allowed meaning the default display used by the hNvDisplay handle.
//                                        3. "-1" is also allowed meaning "index" is the absolute index and not displayOutputId related
//                  index - the index of the custom display
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT: Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DeleteCustomDisplay(NvDisplayHandle hNvDisplay, NvU32 displayOutputId, NvU32 index);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SaveCustomDisplay
//
// DESCRIPTION:     Save the current h/w display config on the specified output ID as a custom display configuration
//                  This function should be called right after NvAPI_TryCustomDisplay() to save custom display from the current
//                  h/w context. This function will not do anything if the custom display config is not tried on the h/w.
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:      hNvDisplay(IN)      - NVIDIA Display selection. NVAPI_DEFAULT_HANDLE not allowed, it has to be a handle enumerated with NvAPI_EnumNVidiaDisplayHandle().
//                  isThisOutputIdOnly  - if set, the saved custom display will only be applied on the monitor with the same outputId
//                  isThisMonitorIdOnly - if set, the saved custom display will only be applied on the monitor with the same EDID ID or
//                                        the same TV connector in case of analog TV.
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT: Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_SaveCustomDisplay(NvDisplayHandle hNvDisplay, NvU32 isThisOutputIdOnly, NvU32 isThisMonitorIdOnly);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_QueryUnderscanCap
//
// DESCRIPTION:     Get the max underscan/overscan ratio and the support type(s) of underscan.
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      hNvDisplay(IN)      - NVIDIA Display selection. NVAPI_DEFAULT_HANDLE not allowed, it has to be a handle enumerated with NvAPI_EnumNVidiaDisplayHandle().
//
//                  displayOutputId(IN) - 1. the display Id on which the underscan config is to apply. It has to be a legal display Id (one bit set)
//                                        2. "0" is allowed meaning the default display used by the hNvDisplay handle.
//
//                  cap(OUT)            - the output pointer of the NV_UNDERSCAN_CAP structure
//
// RETURN STATUS:
//                  NVAPI_OK               - completed request
//                  NVAPI_ERROR            - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////
typedef struct
{
    NvU32 version;                           // the structure version

    float xRatioMin;                         // the supported min horizontal underscan ratio (e.g. 0.75 ~ 1.25 etc)
    float xRatioMax;                         // the supoorted max horizontal underscan ratio
    float yRatioMin;                         // the supported min vertical underscan ratio (e.g. 0.75 ~ 1.25)
    float yRatioMax;                         // the supported min veritcal underscan ratio

    NvU32 supportSourceUnderscan       : 1;  // indicate if source underscan is supported
    NvU32 supportScalerUnderscan       : 1;  // indicate if the scaler based underscan is supported
    NvU32 supportMonitorIdMatch        : 1;  // indicate if the underscan configuration can be set for the monitors with the same EDID
    NvU32 supportDisplayOutputIdMatch  : 1;  // indicate if the underscan configuration can be set for monitors connected to the same display output Id
    NvU32 supportXYIndependentCtrl     : 1;  // indicate if we can independently control on X- and Y- direction

                                             // Note 1:
                                             //------------------------+--------------------+-------------------------------------------------------------------------------------------
                                             //          GPU           |    DisplayOutput   |  Available Underscan option
                                             //------------------------+--------------------+-------------------------------------------------------------------------------------------
                                             // GeForce8/post-GeForce8 |   CRT/TV/DFP/HDMI  |  source and scaler underscan
                                             // GeForce7/pre-GeForce7  |      TV/DFP/HDMI   |  source under only, the API will automatically fall back if scaler underscan is specified
                                             // GeForce7/pre-GeForce7  |         CRT        |  no underscan option yet, the API will return failure
                                             //------------------------+--------------------+-------------------------------------------------------------------------------------------

                                             // Note 2:
                                             //-------------------+-----------------------------+--------------------------------------------------------------------
                                             // supportEdidMatch  | supportDisplayOutputIdMatch |                        behavior
                                             //-------------------+-----------------------------+--------------------------------------------------------------------
                                             //       0           |        0                    |  no Edid check, apply to all devices (not recommended)
                                             //       0           |        1                    |  no Edid check, apply to a specified device only (the old XP style)
                                             //       1           |        0                    |  apply to the specified Edid regardless of the device mask (new)
                                             //       1           |        1                    |  apply to the specified Edid on a specified device (new)
                                             //-------------------+-----------------------------+--------------------------------------------------------------------
                                             
    NvU32 isSourceUnderscanRecommended : 1;  // indicate if source underscan is recommended under the current display context
    NvU32 isScalerUnderscanRecommended : 1;  // indicate if the scaler based underscan is recommended under the current display context
} NV_UNDERSCAN_CAP;
#define NV_UNDERSCAN_CAP_VER  MAKE_NVAPI_VERSION(NV_UNDERSCAN_CAP,1)
NVAPI_INTERFACE NvAPI_QueryUnderscanCap(NvDisplayHandle hNvDisplay, NvU32 displayOutputId, NV_UNDERSCAN_CAP* cap);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_EnumUnderscanConfig
//
// DESCRIPTION:     Enumerates the user customized underscan configurations on the given device
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      hNvDisplay(IN)      - NVIDIA Display selection. NVAPI_DEFAULT_HANDLE not allowed, it has to be a handle enumerated with NvAPI_EnumNVidiaDisplayHandle().
//
//                  displayOutputId(IN) - 1. the display Id on which the underscan config is to apply. It has to be a legal display Id (one bit set)
//                                        2. "0" is allowed meaning the default display used by the hNvDisplay handle.
//                                        3. "-1" is allowed to enum all saved underscan configurations regardless of the target display
//
//                  index(IN)           - 1. the regular the enum index.
//                                        2. "-1"(0xFFFFFFFF) is allowed to enum the current active underscan config on the display uniquely indicated by displayOutId
//
//                  config(OUT)         - the output pointer for the API to populate the underscan config info.
//
// RETURN STATUS:
//                  NVAPI_OK               - completed request
//                  NVAPI_ERROR            - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////
typedef struct
{
    NvU32 version;                           // the structure version

    float xRatio;                            // the horizontal underscan ratio
    float yRatio;                            // the vertical undercan ratio

                                             // NOTE:
                                             // the API may modify the client passed in config due to the h/w restrictions. For example the xRatio/yRatio may be
                                             // fine tuned so that they're aligned on a certain number because of the tiled memory restriction. Also "isSrcUnderscan"
                                             // may also be changed if the h/w can't do backend underscan.

    NvU32 nativeWidth;                       // the width of the native mode
    NvU32 nativeHeight;                      // the height of the native mode
    NvU32 nativeRR;                          // the refresh rate of the native mode
    NvU32 isInterlaced                 : 1;  // the native timing is interlaced or not

    NvU32 isScalerUnderscan            : 1;  // scaler based underscan or source based underscan
    NvU32 isOnThisMonitorOnly          : 1;  // whether this config is only applied to this specific monitor (EDID) only
    NvU32 isOnThisDisplayOutputIdOnly  : 1;  // whether this underscan config is only applied to this display output Id only

} NV_UNDERSCAN_CONFIG;
#define NV_UNDERSCAN_CONFIG_VER  MAKE_NVAPI_VERSION(NV_UNDERSCAN_CONFIG,1)
NVAPI_INTERFACE NvAPI_EnumUnderscanConfig(NvDisplayHandle hNvDisplay, NvU32 displayOutputId, NvU32 index, NV_UNDERSCAN_CONFIG* config);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DeleteUnderscanConfig
//
// DESCRIPTION:     Delete the specified underscan config entry
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      hNvDisplay(IN)      - NVIDIA Display selection. NVAPI_DEFAULT_HANDLE not allowed, it has to be a handle enumerated with NvAPI_EnumNVidiaDisplayHandle().
//
//                  displayOutputId(IN) - 1. the display Id on which the underscan config is to apply. It has to be a legal display Id (one bit set)
//                                        2. "0" is allowed meaning the default display used by the hNvDisplay handle.
//                                        3. "-1" is also allowed meaning "index" is the absolute index and not displayOutputId related
////
//                  index(IN)           - 1. the config index enumerated from NvAPI_EnumUnderScanConfig
//                                        2. "-1" is allowed for the current active underscan config being applied on the specified display output Id
//
// RETURN STATUS:
//                  NVAPI_OK                       - completed request
//                  NVAPI_ERROR                    - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT         - invalid input parameter.
//                  NVAPI_UNKNOWN_UNDERSCAN_CONFIG - the current active underscan config is from an unknown source and can't be deleted.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DeleteUnderscanConfig(NvDisplayHandle hNvDisplay, NvU32 displayOutputId, NvU32 index);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SetUnderscanConfig
//
// DESCRIPTION:     Add and set a custom underscan config on the give device
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      hNvDisplay(IN)      - NVIDIA Display selection. NVAPI_DEFAULT_HANDLE not allowed, it has to be a handle enumerated with NvAPI_EnumNVidiaDisplayHandle().
//
//                  displayOutputId(IN) - 1. the display Id on which the underscan config is to apply. It has to be a legal display Id (one bit set)
//                                        2. "0" is allowed meaning the default display used by the hNvDisplay handle.
//                                        NOTE: 0xFFFFFFFF(-1) is not allowed in NvAPI_SetUnderScanConfig()
//
//                  config(IN/OUT)      - the underscan config to set
//
//                  setDeferred         - "0": apply the setup immediately.
//                                        "1":  apply refresh at next OS modeset.

// RETURN STATUS:
//                  NVAPI_OK               - completed request
//                  NVAPI_ERROR            - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetUnderscanConfig(NvDisplayHandle hNvDisplay, NvU32 displayOutputId, NV_UNDERSCAN_CONFIG* config, NvU32 setDeferred);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetDisplayFeatureConfig
//
// DESCRIPTION:     Return the current display feature configuration.
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      hNvDisplay(IN)      - NVIDIA Display selection. NVAPI_DEFAULT_HANDLE not allowed, it has to be a handle enumerated with NvAPI_EnumNVidiaDisplayHandle().
//
//                  feature (IN/OUT)    - a pointer to NV_DISPLAY_FEATURE structure to retrieve the current feature configuration.
// RETURN STATUS:
//                  NVAPI_OK               - completed request
//                  NVAPI_ERROR            - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////
typedef struct _NV_DISPLAY_FEATURE
{
    NvU32      enableScalerUnderscan  : 1;          // enable/disable HDTV scaler based resizing
    NvU32      enableCEoverHDMI       : 1;          // enable/disable the Feature To Force CE timings over HDMI.
                                                    //If this feature is enabled then, CE timings will only be used for HDMI displays
    NvU32      reservedOEM            : 1;          // Reserved bit for OEM configuration
    NvU32      reserved               : 29;
    
} NV_DISPLAY_FEATURE;
NVAPI_INTERFACE NvAPI_GetDisplayFeatureConfig(NvDisplayHandle hNvDisplay, NV_DISPLAY_FEATURE* pFeature);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SetDisplayFeatureConfig
//
// DESCRIPTION:     Set display feature configuration.
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      hNvDisplay(IN)      - NVIDIA Display selection. NVAPI_DEFAULT_HANDLE not allowed, it has to be a handle enumerated with NvAPI_EnumNVidiaDisplayHandle().
//
//                  feature (IN/OUT)    - a copy NV_DISPLAY_FEATURE structure to setup the new feature configuration
// RETURN STATUS:
//                  NVAPI_OK               - completed request
//                  NVAPI_ERROR            - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetDisplayFeatureConfig(NvDisplayHandle hNvDisplay, NV_DISPLAY_FEATURE feature);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetDisplayFeatureConfigDefaults
//
// DESCRIPTION:     Return the Default display feature configuration.
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      hNvDisplay(IN)      - NVIDIA Display selection. NVAPI_DEFAULT_HANDLE not allowed, it has to be a handle enumerated with NvAPI_EnumNVidiaDisplayHandle().
//
//                  feature (IN/OUT)    - a copy NV_DISPLAY_FEATURE structure to setup the Default feature configuration
// RETURN STATUS:
//                  NVAPI_OK               - completed request
//                  NVAPI_ERROR            - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetDisplayFeatureConfigDefaults(NvDisplayHandle hNvDisplay, NV_DISPLAY_FEATURE* pFeature);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SetView
//
// DESCRIPTION:     This API lets caller to modify target display arrangement for selected source display handle in any of the nview modes.
//                  It also allows to modify or extend the source display in dualview mode.
//                  Note: Maps the selected source to the associated target Ids.
//                  Note: Display PATH with this API is limited to single GPU. DUALVIEW across GPUs cannot be enabled with this API. 
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      hNvDisplay(IN) - NVIDIA Display selection. NVAPI_DEFAULT_HANDLE not allowed, it has to be a handle enumerated with NvAPI_EnumNVidiaDisplayHandle().
//                  pTargetInfo(IN) - Pointer to array of NV_VIEW_TARGET_INFO, specifying device properties in this view.
//                                    The first device entry in the array is the physical primary.
//                                    The device entry with the lowest source id is the desktop primary.
//                  targetCount(IN) - Count of target devices specified in pTargetInfo.
//                  targetView(IN) - Target view selected from NV_TARGET_VIEW_MODE.
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT: Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////

typedef struct
{
    NvU32 version;     // (IN) structure version
    NvU32 count;       // (IN) target count
    struct
    {
        NvU32 deviceMask;   // (IN/OUT) device mask
        NvU32 sourceId;     // (IN/OUT) Values will be based on the number of heads exposed per GPU(0, 1?).
        NvU32 bPrimary:1;   // (OUT) Indicates if this is the GPU's primary view target. This is not the desktop GDI primary.
                            // NvAPI_SetView automatically selects the first target in NV_VIEW_TARGET_INFO index 0 as the GPU's primary view.
        NvU32 bInterlaced:1;// (IN/OUT) Indicates if the timing being used on this monitor is interlaced
        NvU32 bGDIPrimary:1;// (IN/OUT) Indicates if this is the desktop GDI primary.
        NvU32 bForceModeSet:1;// (IN) Used only on Win7 and higher during a call to NvAPI_SetView. Turns off optimization & forces OS to set supplied mode.
    } target[NVAPI_MAX_VIEW_TARGET];
} NV_VIEW_TARGET_INFO;

#define NV_VIEW_TARGET_INFO_VER  MAKE_NVAPI_VERSION(NV_VIEW_TARGET_INFO,2)

NVAPI_INTERFACE NvAPI_SetView(NvDisplayHandle hNvDisplay, NV_VIEW_TARGET_INFO *pTargetInfo, NV_TARGET_VIEW_MODE targetView);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetView
//
// DESCRIPTION:     This API lets caller retrieve the target display arrangement for selected source display handle.
//                  Note: Display PATH with this API is limited to single GPU. DUALVIEW across GPUs will be returned as STANDARD VIEW. 
//                        Please use NvAPI_SYS_GetDisplayTopologies to query views across GPUs.
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      hNvDisplay(IN) - NVIDIA Display selection. NVAPI_DEFAULT_HANDLE not allowed, it has to be a handle enumerated with NvAPI_EnumNVidiaDisplayHandle().
//                  pTargetInfo(OUT) - User allocated storage to retrieve an array of  NV_VIEW_TARGET_INFO. Can be NULL to retrieve the targetCount.
//                  targetMaskCount(IN/OUT) - Count of target device mask specified in pTargetMask.
//                  targetView(OUT) - Target view selected from NV_TARGET_VIEW_MODE.
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT: Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetView(NvDisplayHandle hNvDisplay, NV_VIEW_TARGET_INFO *pTargets, NvU32 *pTargetMaskCount, NV_TARGET_VIEW_MODE *pTargetView);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SetViewEx
//
// DESCRIPTION:     This API lets caller to modify the display arrangement for selected source display handle in any of the nview modes.
//                  It also allows to modify or extend the source display in dualview mode.
//                  Note: Maps the selected source to the associated target Ids.
//                  Note: Display PATH with this API is limited to single GPU. DUALVIEW across GPUs cannot be enabled with this API. 
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      hNvDisplay(IN) - NVIDIA Display selection. NVAPI_DEFAULT_HANDLE not allowed, it has to be a handle enumerated with NvAPI_EnumNVidiaDisplayHandle().
//                  pPathInfo(IN)  - Pointer to array of NV_VIEW_PATH_INFO, specifying device properties in this view.
//                                    The first device entry in the array is the physical primary.
//                                    The device entry with the lowest source id is the desktop primary.
//                  pathCount(IN)  - Count of paths specified in pPathInfo.
//                  displayView(IN)- Display view selected from NV_TARGET_VIEW_MODE.
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT: Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////

#define NVAPI_MAX_DISPLAY_PATH  NVAPI_MAX_VIEW_TARGET

typedef struct
{
    NvU32                   deviceMask;     // (IN) device mask
    NvU32                   sourceId;       // (IN) Values will be based on the number of heads exposed per GPU(0, 1?)
    NvU32                   bPrimary:1;     // (IN/OUT) Indicates if this is the GPU's primary view target. This is not the desktop GDI primary.
                                            // NvAPI_SetViewEx automatically selects the first target in NV_DISPLAY_PATH_INFO index 0 as the GPU's primary view.
    NV_GPU_CONNECTOR_TYPE   connector;      // (IN) Specify connector type. For TV only.

    // source mode information
    NvU32                   width;          // (IN) width of the mode
    NvU32                   height;         // (IN) height of the mode
    NvU32                   depth;          // (IN) depth of the mode
    NV_FORMAT               colorFormat;    //      color format if needs to specify. Not used now.

    //rotation setting of the mode
    NV_ROTATE               rotation;       // (IN) rotation setting.

    // the scaling mode
    NV_SCALING              scaling;        // (IN) scaling setting

    // Timing info
    NvU32                   refreshRate;    // (IN) refresh rate of the mode
    NvU32                   interlaced:1;   // (IN) interlaced mode flag

    NV_DISPLAY_TV_FORMAT    tvFormat;       // (IN) to choose the last TV format set this value to NV_DISPLAY_TV_FORMAT_NONE

    // Windows desktop position
    NvU32                   posx;           // (IN/OUT) x offset of this display on the Windows desktop
    NvU32                   posy;           // (IN/OUT) y offset of this display on the Windows desktop
    NvU32                   bGDIPrimary:1;  // (IN/OUT) Indicates if this is the desktop GDI primary.

    NvU32                   bForceModeSet:1;// (IN) Used only on Win7 and higher during a call to NvAPI_SetViewEx. Turns off optimization & forces OS to set supplied mode.
    NvU32                   bFocusDisplay:1;// (IN) If set, this display path should have the focus after the GPU topology change
    NvU32                   gpuId:24;       // (IN) the physical display/target Gpu id which is the owner of the scan out (for SLI multimon, display from the slave Gpu)

} NV_DISPLAY_PATH;

typedef struct
{
    NvU32 version;     // (IN) structure version
    NvU32 count;       // (IN) path count
    NV_DISPLAY_PATH path[NVAPI_MAX_DISPLAY_PATH];
} NV_DISPLAY_PATH_INFO;

#define NV_DISPLAY_PATH_INFO_VER  NV_DISPLAY_PATH_INFO_VER3
#define NV_DISPLAY_PATH_INFO_VER3 MAKE_NVAPI_VERSION(NV_DISPLAY_PATH_INFO,3)
#define NV_DISPLAY_PATH_INFO_VER2 MAKE_NVAPI_VERSION(NV_DISPLAY_PATH_INFO,2)
#define NV_DISPLAY_PATH_INFO_VER1 MAKE_NVAPI_VERSION(NV_DISPLAY_PATH_INFO,1)

NVAPI_INTERFACE NvAPI_SetViewEx(NvDisplayHandle hNvDisplay, NV_DISPLAY_PATH_INFO *pPathInfo, NV_TARGET_VIEW_MODE displayView);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetViewEx
//
// DESCRIPTION:     This API lets caller retrieve the target display arrangement for selected source display handle.
//                  Note: Display PATH with this API is limited to single GPU. DUALVIEW across GPUs will be returned as STANDARD VIEW. 
//                        Please use NvAPI_SYS_GetDisplayTopologies to query views across GPUs.
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      hNvDisplay(IN) - NVIDIA Display selection. NVAPI_DEFAULT_HANDLE not allowed, it has to be a handle enumerated with NvAPI_EnumNVidiaDisplayHandle().
//                  pPathInfo(IN/OUT) - count field should be set to NVAPI_MAX_DISPLAY_PATH. Can be NULL to retrieve just the pathCount.
//                  pPathCount(IN/OUT) - Number of elements in array pPathInfo->path.
//                  pTargetViewMode(OUT)- Display view selected from NV_TARGET_VIEW_MODE.
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_API_NOT_INTIALIZED - NVAPI not initialized
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter.
//                  NVAPI_EXPECTED_DISPLAY_HANDLE - hNvDisplay is not a valid display handle.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetViewEx(NvDisplayHandle hNvDisplay, NV_DISPLAY_PATH_INFO *pPathInfo, NvU32 *pPathCount, NV_TARGET_VIEW_MODE *pTargetViewMode);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetSupportedViews
//
// DESCRIPTION:     This API lets caller enumerate all the supported NVIDIA display views - nview and dualview modes.
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:      hNvDisplay(IN) - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                  pTargetViews(OUT) - Array of supported views. Can be NULL to retrieve the pViewCount first.
//                  pViewCount(IN/OUT) - Count of supported views.
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT: Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetSupportedViews(NvDisplayHandle hNvDisplay, NV_TARGET_VIEW_MODE *pTargetViews, NvU32 *pViewCount);



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetSupportedViewsEx
//
// DESCRIPTION:     This API lets caller enumerate all the supported NVIDIA display views - nview and dualview modes.
//                  Same as NvAPI_GetSupportedViews except takes a flag to return cached or uncached connections.
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      hNvDisplay(IN) - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                  pTargetViews(OUT) - Array of supported views. Can be NULL to retrieve the pViewCount first.
//                  pViewCount(IN/OUT) - Count of supported views.
//                  flag - Uncached (re-scanned) connected devices or cached connected devices
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT: Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetSupportedViewsEx(NvDisplayHandle hNvDisplay, NV_TARGET_VIEW_MODE *pTargetViews, NvU32 *pViewCount, NvU32 flag);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SetViewExInternal
//
// DESCRIPTION:     Description and usage same as NvAPI_SetViewEx. Only Sedona to use this. This API does not check for inhibit state.
//                  Note: Display PATH with this API is limited to single GPU. DUALVIEW across GPUs cannot be enabled with this API. 
//
//  SUPPORTED OS: Windows Vista and higher
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetViewExInternal(NvDisplayHandle hNvDisplay, NV_DISPLAY_PATH_INFO *pPathInfo, NV_TARGET_VIEW_MODE displayView);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_DISP_IsFullscreenAppRunning
//
//   DESCRIPTION:  Query whether app is running in fullscreen mode or not.
//
//  SUPPORTED OS: Windows Vista and higher
//
//    PARAMETERS: hNvDisplay(IN) - hNvDisplay(IN) - NVIDIA Display selection. NVAPI_DEFAULT_HANDLE not allowed, it has to be a handle enumerated with NvAPI_EnumNVidiaDisplayHandle().
//                pFullScreenApp(IN) - Pointer to pFullScreenApp.
//                                 
//
// RETURN STATUS: NVAPI_OK: call successful.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found.
//                NVAPI_EXPECTED_DISPLAY_HANDLE: hNvDisplay is not a valid display handle.
//                NVAPI_INVALID_ARGUMENT: pFullScreenApp is NULL.
//                NVAPI_NO_IMPLEMENTATION - This API is not implemented.
//                NVAPI_ERROR - miscellaneous error occurred.
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_IsFullscreenAppRunning(NvDisplayHandle hNvDisplay, NvU32 *pFullScreenApp);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetHDCPLinkParameters
//
// DESCRIPTION:     This API lets caller enumerate fields within the NV_HDCP_INFO.
//
//                  The API provides support for the HDCP Upstream Protocol. The caller is responsible to fill the input fields
//                  within NV_HDCP_PACKET to ensure that the specified HDCP_COMMANDS can be fulfilled. Different HDCP_COMMANDS will
//                  enumerate different fields inside NV_HDCP_INFO. The following are the HDCP_COMMANDS supported
//
//                  (A) HDCP_CMD_QUERY_HEAD_CONFIG  : Enumerates ports attached to a head.
//                  (B) HDCP_CMD_READ_LINK_STATUS   : Reads the Status of the cipher returning a signed status and connection state.
//                  (C) HDCP_CMD_VALIDATE_LINK      : Returns the parameters necessary to validate the links for the specified attach-point.
//                  (D) HDCP_CMD_RENEGOTIATE        : Forced renegotiation of the link.
//
//  SUPPORTED OS: Windows XP and higher
//
//
// PARAMETERS:      hNvDisplay(IN) - NVIDIA Display selection. It should be a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                  pNvHdcpInfo(IN) - Pointer to NV_HDCP_INFO that contains the requested command and input parameters.
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - pNvHdcpPacket is NULL
//                  NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of NV_HDCP_INFO struct is not supported
//
///////////////////////////////////////////////////////////////////////////////

#define NVAPI_MAX_NUM_AP        16      // Max number of ports / attach points supported in HDCP Connection State
#define NVAPI_MAX_DEVICES       127     // Max number of Receiver & Repeater devices

typedef struct
{
    union
    {
        NvU32  data1;
        struct
        {
            NvU8    revMin;
            NvU8    revMaj;
            NvU8    verMin;
            NvU8    verMaj;
        } ver;
    };
    NvU16 data2;
    NvU16 data3;
    NvU8  data4[8];
} NV_UID;

typedef struct
{
#pragma pack(1)
    NvU64 uSessionID    : 37;   // [36:0] Random number
    NvU64 uDisplay      : 3;    // [39:37] O/S level display device
    NvU64 uReserved     : 24;   // [63:40] Reserved
#pragma pack()
} NV_HDCP_CN;

typedef struct
{
    union
    {
        NvU64   quadWord;
        struct
        {
            NvU64 hugePart      : 40; // lower 40 in little endian
            NvU64 unusedPart    : 24;
        } parts;
    };
} NV_U40;

typedef struct
{
    union
    {
        NvU64   quadWord;
        struct
        {
            NvU64 hugePart      : 56; // lower 56 in little endian
            NvU64 unusedPart    : 8;
        } parts;
    };
} NV_U56;


// Structure of data returned from monitor - as defined in HDCP Spec
typedef struct
{
#pragma pack(1)
    NvU32 ucDeviceCount         : 7;    // [6:0] Total Receivers (except rep)
    NvU32 bMaxDevicesExceeded   : 1;    // [7] Topology Error > 127 devices
    NvU32 bRepeaterDepth        : 3;    // [10:8] Repeater depth
    NvU32 bMaxCascadeExceeded   : 1;    // [11] Topology Error > 7 levels repeater
    NvU32 bHDMImode             : 1;    // [12] HDCP Receiver in HDMI mode
    NvU32 bReserved             : 19;   // [31:13] Reserved for future expansion
#pragma pack()
} NV_HDCP_BSTATUS;

// The Connection State
typedef struct
{
#pragma pack(1)
    NvU64 uAttachPoints         : 16;       // [15:0] Transmitting Attach Point
    NvU64 bNonHDCP              : 1;        // [16] Transmitting Attach Point
    NvU64 uHeadIndex            : 4;        // [20:17] Index of Head
    NvU64 uRFUPlanes            : 8;        // [28:21] *NOT* yet supported
    NvU64 uNumberOfActiveHeads  : 2;        // [30:29] Number of Heads - 1
    NvU64 uReserved2            : 9;        // [39:31] Reserved for future use
    NvU64 uAttachedPlanes       : 8;        // [47:40] Will be moved to 28:21 in future chips
    NvU64 bCloneMode            : 1;        // [48] Dual-Display Clone Mode *NOT* yet supported
    NvU64 bSpanMode             : 1;        // [49] Dual-Display Span Mode *NOT* yet supported
    NvU64 uPadding              : 14;       // [63:50] To fill up qword
#pragma pack()
} NV_HDCP_CS;

// The Status of the Attach-Point (HDCP-capable or other)
typedef struct
{
#pragma pack(1)
    NvU64 bEncrypting           : 1;        // [0] This Attach Point is Transmitting and has Output Encryption Enabled
    NvU64 bRepeater             : 1;        // [1] This Attach Point is Transmitting to a Repeater
    NvU64 bUserAccessible       : 1;        // [2] This Attach Point is Transmitting on a user-accessible external digital port
    NvU64 bExtUnprotected       : 1;        // [3] This Attach-point is Transmitting externally and is unprotected
    NvU64 uPortIndex            : 4;        // [7:4] Port/Attach-point index
    NvU64 uNumPorts             : 4;        // [11:8] Number of Connectable
    NvU64 bInternalPanel        : 1;        // [12] Compliant Internal / Non-User accessible Port Panel without HDCP Encryption
    NvU64 bWideScope            : 1;        // [13] Cs:16 is not enough to determine presence of non-compliant outputs+ (always ??
    NvU64 bHasCs                : 1;        // [14] Supports Connection State (always ??
    NvU64 bReadZ                : 1;        // [15] Supports ReadZ (always ??
    NvU64 uReserved             : 24;       // [39:16] Reserved for Future Expansion
    NvU64 bDualLinkEven         : 1;        // [40] The Even half of a Dual-Link (0x74)
    NvU64 bDualLinkOdd          : 1;        // [41] The Odd half of a Dual-Link (0x76)
    NvU64 bDualLinkCapable      : 1;        // [42] This Attach Point has Dual-Link capability
    NvU64 uPadding              : 21;       // [63:43] To fill up qword
    NvU32 DisplayId;                        // ID of the Display on this attach point
#pragma pack()
} NV_HDCP_STATUS;

// Flags used for indicating active member elements
typedef enum
{
    NV_HDCP_FLAGS_NULL          = 0x00000000, // Get AP Status
    NV_HDCP_FLAGS_APINDEX       = 0x00000001, // Index of Attach Point
    NV_HDCP_FLAGS_AN            = 0x00000010, // Downstream Session ID
    NV_HDCP_FLAGS_AKSV          = 0x00000020, // Downstream/Xmtr KSV
    NV_HDCP_FLAGS_BKSV          = 0x00000040, // Downstream/Rcvr KSV
    NV_HDCP_FLAGS_BSTATUS       = 0x00000080, // Link/Repeater Status
    NV_HDCP_FLAGS_CN            = 0x00000100, // Upstream Session ID
    NV_HDCP_FLAGS_CKSV          = 0x00000200, // Upstream ClientApp KSV
    NV_HDCP_FLAGS_DKSV          = 0x00000400, // Upstream/Xmtr KSV
    NV_HDCP_FLAGS_KP            = 0x00001000, // Signature
    NV_HDCP_FLAGS_S             = 0x00002000, // Status
    NV_HDCP_FLAGS_CS            = 0x00004000, // Connection State
    NV_HDCP_FLAGS_V             = 0x00010000, // V of the KSVList
    NV_HDCP_FLAGS_MP            = 0x00020000, // Encrypted initializer for KSV List
    NV_HDCP_FLAGS_BKSVLIST      = 0x00040000, // NumKsvs & BksvList[NumKsvs]
    NV_HDCP_FLAGS_DUAL_LINK     = 0x00100000, // Two sets of An, Aksv, Kp, Bksv, Dksv
    NV_HDCP_FLAGS_ALWAYS_AUTH   = 0x00200000, // Always authenticate
    NV_HDCP_FLAGS_ON_BY_DEMAND  = 0x00000000, // Authenticate on demand
    NV_HDCP_FLAGS_ABORT_UNTRUST = 0x00400000, // Abort, Kp didnt match
    NV_HDCP_FLAGS_ABORT_UNRELBL = 0x00800000, // Abort, Repeated Link Failures
    NV_HDCP_FLAGS_ABORT_KSV_LEN = 0x01000000, // Abort, incorrect KSV Length
    NV_HDCP_FLAGS_ABORT_KSV_SIG = 0x02000000, // Abort, bad KSV Signature
    NV_HDCP_FLAGS_ABORT_SRM_SIG = 0x04000000, // Abort, bad SRM Signature
    NV_HDCP_FLAGS_ABORT_SRM_REV = 0x08000000, // Abort due to SRM Revocation
    NV_HDCP_FLAGS_ABORT_NORDY   = 0x10000000, // Abort, Repeater Not Ready
    NV_HDCP_FLAGS_ABORT_KSVTOP  = 0x20000000, // Abort, KSV Topology Error
    NV_HDCP_FLAGS_ABORT_BADBKSV = 0x40000000, // Abort due to invalid Bksv
} NV_HDCP_FLAGS;

// HDCP Commands
typedef enum
{
    NV_HDCP_CMD_NULL               = 0x00, // Null command
    NV_HDCP_CMD_QUERY_HEAD_CONFIG  = 0x01, // Status of the head attach-points
    NV_HDCP_CMD_READ_LINK_STATUS   = 0x02, // Get the Status
    NV_HDCP_CMD_VALIDATE_LINK      = 0x03, // Gets M & V
    NV_HDCP_CMD_RENEGOTIATE        = 0x04, // Forced renegotiation of the link
    NV_HDCP_CMD_ABORTAUTHENTICATION= 0x05, // Abort authentication protocol
    NV_HDCP_CMD_SETLINKPOLICY      = 0x06, // Set the link policy
} NV_HDCP_COMMANDS;

// HDCP Return Status
typedef enum
{
    NV_HDCP_STATUS_SUCCESS                 = (0x00000000L), // Function completed successfully
    NV_HDCP_STATUS_UNSUCCESSFUL            = (0xC0000001L), // Function failed
    NV_HDCP_STATUS_PENDING                 = (0x00000103L), // Renegotiation is not complete, check status later
    NV_HDCP_STATUS_LINK_FAILED             = (0xC000013EL), // Renegotiation could not complete
    NV_HDCP_STATUS_INVALID_PARAMETER       = (0xC000000DL), // One or more of the calling parameters was invalid
    NV_HDCP_STATUS_INVALID_PARAMETER_MIX   = (0xC0000030L), // The combination of flFlags was invalid
    NV_HDCP_STATUS_NO_MEMORY               = (0xC0000017L), // Insufficient buffer space was allocated. Re-allocate using the size returned in the dwSize member
    NV_HDCP_STATUS_BAD_TOKEN_TYPE          = (0xC00000A8L), // The Session ID &/or KSV supplied were rejected
} NV_HDCP_RET_STATUS;

// HDCP Packet
typedef struct
{
#pragma pack(4)
    NV_UID              uidHDCP;                        // (IN)
    NvU32               packetSize;                     // (IN/OUT)
    NvU32               hDisplayContext;                // (IN/OUT)
    NV_HDCP_COMMANDS    cmdCommand;                     // (IN)
    NV_HDCP_FLAGS       flFlags;                        // (IN/OUT)
    NV_HDCP_RET_STATUS  hdcpPacketStatus;               // (OUT)

    NvU32               apIndex;                        // (IN) Attach point index
    NV_HDCP_CN          cN;                             // (IN) Client Session ID
    NV_U40              cKsv;                           // (IN)

    NV_HDCP_BSTATUS     bStatus[NVAPI_MAX_NUM_AP];      // (OUT)
    NV_HDCP_STATUS      hdcpStatus[NVAPI_MAX_NUM_AP];   // (OUT)
    NV_HDCP_CS          cS;                             // (OUT) Connection State

    NV_U56              kP[2];                          // (OUT) KPRIME value
    NV_U40              aN[2];                          // (OUT)
    NV_U40              aKsv[2];                        // (OUT)
    NV_U40              dKsv[2];                        // (OUT)
    NvU8                vP[20];                         // (OUT) VPRIME value
    NvU64               mP;                             // (OUT) MPRIME value
    NvU32               numBKSVs;                       // (OUT) Valid KSVs in the bKsvList. Maximum is 127 devices
    NV_U40              bKsvList[NVAPI_MAX_DEVICES];    // (OUT) Up to 127 receivers & repeaters
#pragma pack()
} NV_HDCP_PACKET;

typedef struct
{
    NvU32 version;
    NV_HDCP_PACKET nvHdcpPacket;
} NV_HDCP_INFO;

#define NV_HDCP_INFO_VER  MAKE_NVAPI_VERSION(NV_HDCP_INFO,1)

NVAPI_INTERFACE NvAPI_GetHDCPLinkParameters(NvDisplayHandle hNvDisplay, NV_HDCP_INFO *pNvHdcpInfo);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SetHDMIAudioStreamMute
//
// DESCRIPTION:     This API signals the driver to mute on/off the HDMI audio stream
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:      hNvDisplay(IN)  - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated
//                                    from NvAPI_EnumNVidiaDisplayHandle().
//                  outputId(IN)    - The display output id for the HDMI display. If it's "0" then the default
//                                    outputId from NvAPI_GetAssociatedDisplayOutputId() will be used.
//                  muteStatus(IN)  - The audio stream mute value for the HDMI display.
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_NOT_SUPPORTED - display output id is for non-active HDMI display
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////

// HDMI Audio Stream Mute
typedef enum _NV_HDMI_AUDIO_STREAM_MUTE_STATUS
{
    NV_SET_HDMI_AUDIO_STREAM_MUTE_OFF  = 0x00, // Set mute off
    NV_SET_HDMI_AUDIO_STREAM_MUTE_ON   = 0x01, // Set mute on
} NV_HDMI_AUDIO_STREAM_MUTE_STATUS;

typedef struct
{
    NvU32 version;
    NV_HDMI_AUDIO_STREAM_MUTE_STATUS nvHdmiAudioMute;
} NV_HDMI_AUDIO_INFO;

#define NV_HDMI_AUDIO_INFO_VER  MAKE_NVAPI_VERSION(NV_HDMI_AUDIO_INFO,1)

NVAPI_INTERFACE NvAPI_SetHDMIAudioStreamMute(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_HDMI_AUDIO_INFO* pNvHdmiAudioInfo);


/////////////////////////////////////////////////////////////////////////////////

 /*************** NVIDIA MOBILE SOFTWARE INSTRUMENTATION API ******************\
 * Instrumentation API provides an interface for the user to collect power,    *
 * performance statistics from the various sensor locations on the board.      *
 * Since each board (E415, E417,...) will have different measurement locations,*
 * the user first has to  query what is available. The  list of locations,     *
 * measurements and sample rates will be passed as part of the capture settings*
 * to open the session. When session was started the measurements are taken at *
 * sample rates specified, at all the locations and samples are in kernel.     *
 * After stop/ session timout, data collected is retrived and session is closed*
 * for reuse. Only one client and one session were supported.                  *
 * For more information see                                                    *
 *   https://engwiki/index.php/Mobile_Software_Instrumentation_API             *
 \*****************************************************************************/

/////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SwInstr_GetInterfaceRevision
//
//   DESCRIPTION: Returns the Interface Revision
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hPhysicalGpu or pNvSwInstrRev is NULL
//                NVAPI_OK: *pNvSwInstrRev is now set
//                NVAPI_INCOMPATIBLE_STRUCT_VERSION - NV_SWINSTR_REVISION version not compatible with driver
//
///////////////////////////////////////////////////////////////////////////////

typedef struct
{
    NvU32  version;         // structure version
    NvU8   revMin;
    NvU8   revMaj;
    NvU8   verMin;
    NvU8   verMaj;
} NV_SWINSTR_REVISION;

#define NV_SWINSTR_REVISION_VER MAKE_NVAPI_VERSION(NV_SWINSTR_REVISION,1)
NVAPI_INTERFACE NvAPI_SwInstr_GetInterfaceRevision(NV_SWINSTR_REVISION *pNvSwInstrRev);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SwInstr_GetSensorPoints
//
//   DESCRIPTION: Returns the sensor points for the board.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pNvSwInstrSensorPoints is NULL
//                NVAPI_OK: *pNvSwInstrSensorPoints is now set
//                NVAPI_INCOMPATIBLE_STRUCT_VERSION - NV_SWINSTR_SENSOR_POINTS version not compatible with driver

///////////////////////////////////////////////////////////////////////////////


//Describes valid subsystems for sensor points.
typedef enum _NV_SWINSTR_SENSOR_SUBSYSTEM
{
    NV_SENSOR_SUBSYSTEM_CPU         = 0x01,
    NV_SENSOR_SUBSYSTEM_GPU         = 0x02,
    NV_SENSOR_SUBSYSTEM_CHIPSET     = 0x04,
    NV_SENSOR_SUBSYSTEM_MEMORY      = 0x08,
    NV_SENSOR_SUBSYSTEM_DISPLAY     = 0x10,
    NV_SENSOR_SUBSYSTEM_NETWORK     = 0x20,
    NV_SENSOR_SUBSYSTEM_PS          = 0x40,
    NV_SENSOR_SUBSYSTEM_SKIN        = 0x80,
    NV_SENSOR_SUBSYSTEM_ALL         = 0xFFFFFFFF,
} NV_SWINSTR_SENSOR_SUBSYSTEM;

// Describes valid component values
typedef enum _NV_SWINSTR_SENSOR_COMPONENT
{
    NV_SENSOR_COMPONENT_CORE        = 0x01,
    NV_SENSOR_COMPONENT_MEMORY      = 0x02,
    NV_SENSOR_COMPONENT_BUS         = 0x04,
    NV_SENSOR_COMPONENT_PS          = 0x08,
    NV_SENSOR_COMPONENT_ALL         = 0xFFFFFFFF,
} NV_SWINSTR_SENSOR_COMPONENT;

// Describes valid GPU subsystem/core partition values
typedef enum _NV_SWINSTR_SENSOR_GPU_CORE_PARTITION
{
    NV_SENSOR_PARTITION_GPU_FB         = 0x01,
    NV_SENSOR_PARTITION_GPU_RENDER     = 0x02,
    NV_SENSOR_PARTITION_GPU_HOST       = 0x04,
    NV_SENSOR_PARTITION_GPU_DISPLAY    = 0x08,
    NV_SENSOR_PARTITION_GPU_VIDEO      = 0x10,
    NV_SENSOR_PARTITION_GPU_ALL        = 0xFFFFFFFF,
} NV_SWINSTR_SENSOR_GPU_CORE_PARTITION;

// Describe valid GPU subsystem/Local Memory component partition values
typedef enum _NV_SWINSTR_SENSOR_GFX_LM_PARTITION
{
    NV_SENSOR_PARTITION_GFX_LM_LOGIC    = 0x01,
    NV_SENSOR_PARTITION_GFX_LM_DATA     = 0x02,
    NV_SENSOR_PARTITION_GFX_LM_TOTAL    = 0xFFFFFFFF,
} NV_SWINSTR_SENSOR_GFX_LM_PARTITION;

// Describe valid GPU subsystem/Bus component partition values
typedef enum _NV_SWINSTR_SENSOR_GFX_BUS_PARTITION
{
    NV_SENSOR_PARTITION_GFX_BUS_PCIE    = 0x01,
    NV_SENSOR_PARTITION_GFX_BUS_MEMORY  = 0x02,
    NV_SENSOR_PARTITION_GFX_BUS_MIO     = 0x04,
    NV_SENSOR_PARTITION_GFX_BUS_TOTAL   = 0xFFFFFFFF,
} NV_SWINSTR_SENSOR_GFX_BUS_PARTITION;

// Describes valid measurement values
typedef enum _NV_SWINSTR_MEASUREMENT_TYPE
{
    NV_SENSOR_MEASURE_UNKNOWN           = 0x00,
    NV_SENSOR_MEASURE_ALTRSVD           = 0x01,
    NV_SENSOR_MEASURE_UTIL              = 0x02,
    NV_SENSOR_MEASURE_PERF_STATE        = 0x04,
    NV_SENSOR_MEASURE_ABS_POWER         = 0x08,
    NV_SENSOR_MEASURE_TEMP              = 0x10,
    NV_SENSOR_MEASURE_REL_POWER         = 0x20,
} NV_SWINSTR_MEASUREMENT_TYPE;

// Defines the sensor location structure.
typedef struct
{
    NvU32 subSystem;          // of type NV_SWINSTR_SENSOR_SUBSYSTEM
    NvU32 component;          // of type NV_SWINSTR_SENSOR_COMPONENT
    NvU32 partition;          // of type NV_SWINSTR_SENSOR_GPU_CORE_PARTITION
                              // or NV_SWINSTR_SENSOR_GFX_LM_PARTITION
                              // or NV_SWINSTR_SENSOR_GFX_BUS_PARTITION

    NvU32 instance;           // specifies bitmask for gpu s to be used
} NV_SWINSTR_SENSOR_LOCATION;

// Defines a sensor point
typedef struct
{
    NV_SWINSTR_SENSOR_LOCATION sensorLocation;
    NvU32 measurementType;     // of type NV_SWINSTR_MEASUREMENT_TYPE
} NV_SWINSTR_SENSOR_POINT;


#define NV_SWINSTR_MAX_SENSOR_POINTS                     (0x00000020)

typedef struct
{   NvU32 version;              // structure version
    NvU32 numPoints;            // number of sensor points.
    NV_SWINSTR_SENSOR_POINT sensorPoints[NV_SWINSTR_MAX_SENSOR_POINTS];
} NV_SWINSTR_SENSOR_POINTS;

#define NV_SWINSTR_SENSOR_POINTS_VER MAKE_NVAPI_VERSION(NV_SWINSTR_SENSOR_POINTS,1)
NVAPI_INTERFACE NvAPI_SwInstr_GetSensorPoints(NV_SWINSTR_SENSOR_POINTS *pNvSwInstrSensorPoints);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SwInstr_GetCapabilities
//
//   DESCRIPTION: Returns the performance instrumentation engine information for
//                the associated GPU.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT:  pNvSwInstrCapabilities is NULL
//                NVAPI_OK: *pNvSwInstrCapabilities is now set
//                NVAPI_INCOMPATIBLE_STRUCT_VERSION - NV_SWINSTR_CAPTURE_CAPS version not compatible with driver
//
///////////////////////////////////////////////////////////////////////////////

typedef struct
{
    NvU32 version;
    struct
    {
        unsigned    bMovingAverage  : 1;    // Supports a Moving Average
        unsigned    bMASampleWindow : 1;    // Programmable Sample Window
        unsigned    bMAWindowSamples: 1;    // Measured in Samples | Time
        unsigned    powerPosErr     : 7;    // max pos deviation %
        unsigned    powerNegErr     : 7;    // max neg deviation %
        unsigned    tempPosErr      : 7;    // max pos deviation %
        unsigned    tempNegErr      : 7;    // max neg deviation %

    } caps;
    NvU32 maxSamples;                // Buffers size limit, 0 = no limit
    NvU32 minMovingAverageWindow;    // As per bMAWindowSamples
    NvU32 maxMovingAverageWindow;
    NvU32 minSampleRate;            // min Sample rate in 1/1000 Hz
    NvU32 maxPerfSampleRate;
    NvU32 maxPowerSampleRate;
    NvU32 maxTempSampleRate;
    NvU32 maxUtilSampleRate;
} NV_SWINSTR_CAPTURE_CAPS;

#define NV_SWINSTR_CAPTURE_CAPS_VER MAKE_NVAPI_VERSION(NV_SWINSTR_CAPTURE_CAPS,1)
NVAPI_INTERFACE NvAPI_SwInstr_GetCapabilities(NV_SWINSTR_CAPTURE_CAPS *pNvSwInstrCapabilities);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SwInstr_OpenCaptureSession
//
//   DESCRIPTION: Initiate a capture session. Only one session can be
//                opened at a time.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pNvSwInstrCapSets is NULL
//                NVAPI_OK: session is now open using *pNvSwInstrCapSets
//                NVAPI_INCOMPATIBLE_STRUCT_VERSION - NV_SWINSTR_CAPTURE_SETTINGS version not compatible with driver
//
///////////////////////////////////////////////////////////////////////////////
typedef struct
{
    NvU32 version;              // structure version

    NvU32 bufferSize;           // size of capture settings buffer
    NvU8  bCapturebyTime;       // True = byTime else bycount
    NvU8  powerMode;            // True = power sample gives power else voltage current
    NvU32 value;                // if byTime = True, value = total time in ms for instrumentation data capture
                                // else value = number of instrumentation data samples
    NvU32 powerSampleRate;      // specifies sample rate for power capture
    NvU32 perfSampleRate;       // specifies sample rate for perf capture
    NvU32 tempSampleRate;       // specifies sample rate for temp capture
    NvU32 utilSampleRate;       // specifies sample rate for util capture
    NvU32 numPoints;            // total number of sensor points on which data is to be measured.
    NV_SWINSTR_SENSOR_POINT sensorPoints[NV_SWINSTR_MAX_SENSOR_POINTS];
}NV_SWINSTR_CAPTURE_SETTINGS;

#define NV_SWINSTR_CAPTURE_SETTINGS_VER MAKE_NVAPI_VERSION(NV_SWINSTR_CAPTURE_SETTINGS, 1)
NVAPI_INTERFACE NvAPI_SwInstr_OpenCaptureSession(NV_SWINSTR_CAPTURE_SETTINGS *pNvSwInstrCapSets);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SwInstr_CloseCaptureSession
//
//   DESCRIPTION: Shutdown a capture session. A session must have been
//                initiated with a call to NvAPI_SwInstr_OpenCaptureSession
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_OK: Capture session is now closed
//                NVAPI_ERROR: General error
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SwInstr_CloseCaptureSession();

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SwInstr_StartCaptureSession
//
//   DESCRIPTION: start the capture of software instrumentation data
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_OK: Capture is started
//                NVAPI_ERROR: General error
//
///////////////////////////////////////////////////////////////////////////////


NVAPI_INTERFACE NvAPI_SwInstr_StartCaptureSession();


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SwInstr_StopCaptureSession
//
//   DESCRIPTION: stop the capture of software instrumentation data
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_OK: Capture now stopped
//                NVAPI_ERROR: General error
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SwInstr_StopCaptureSession();


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SwInstr_GetCaptureData
//
//   DESCRIPTION: retrieve performance instrumentation data
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pNvSwInstrCaptureData or pSize is NULL
//                NVAPI_OK: *pNvSwInstrCaptureData now set
//                NVAPI_INCOMPATIBLE_STRUCT_VERSION - NV_SWINSTR_CAPTURE_BUFFER version not compatible with driver
//
///////////////////////////////////////////////////////////////////////////////

typedef struct
{
    NvU32 currPerfState;     // current performance state
    NvU32 totalPerfStates;   // total performance states supported
} NV_SWINSTR_PERF_SAMPLE;

typedef struct
{
    NvU16 voltage;           // voltage value at the sensor location
    NvU16 current;           // current value at the sensor location
} NV_SWINSTR_VOLTAGE_CURRENT;

typedef struct
{
    union
    {
        NvU32 power;         // power value at the sensor location
        NV_SWINSTR_VOLTAGE_CURRENT voltageCurrent;
    } data;
    NvU64 timeStamp;         // Time at which measurement is taken
} NV_SWINSTR_POWER_SAMPLE;

typedef struct
{
    NvS32 temp;             // Temperature at sensor location
    NvU64 timeStamp;        // Time when measurement is taken
} NV_SWINSTR_TEMP_SAMPLE;

typedef struct
{
    NvU32 utilization;      // Utilization value at sensor location
    NvU64 timeStamp;        // Time when measurement is taken
} NV_SWINSTR_UTIL_SAMPLE;

typedef struct
{
    NV_SWINSTR_SENSOR_POINT sensor;   // specifies where measurement is taken
    union
    {
        NV_SWINSTR_PERF_SAMPLE perfSample;
        NV_SWINSTR_POWER_SAMPLE powerSample;
        NV_SWINSTR_TEMP_SAMPLE tempSample;
        NV_SWINSTR_UTIL_SAMPLE utilSample;
    } sample;                         // measured data
} NV_SWINSTR_SAMPLE;

typedef struct
{
    NvU32 version;
    NvU32 numSamples;                // number of samples collected
    NV_SWINSTR_SAMPLE *pSamples;     // pointer to the sample buffer
} NV_SWINSTR_CAPTURE_BUFFER;

#define NV_SWINSTR_CAPTURE_BUFFER_VER MAKE_NVAPI_VERSION(NV_SWINSTR_CAPTURE_BUFFER,1)
NVAPI_INTERFACE NvAPI_SwInstr_GetCaptureData(NV_SWINSTR_CAPTURE_BUFFER *pNvSwInstrCaptureData,
                                             NvU32 *pSize);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SwInstr_GetSnapshot
//
//   DESCRIPTION: retrieve a snapshot of instrumentation data
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: pNvSwInstrCaptureData or pSize is NULL
//                NVAPI_OK: *pNvSwInstrCaptureData now set
//                NVAPI_INCOMPATIBLE_STRUCT_VERSION - NV_SWINSTR_SNAPSHOT_DATA version not compatible with driver
//
///////////////////////////////////////////////////////////////////////////////

#define NV_SWINSTR_SNAPSHOT_DATA_VER MAKE_NVAPI_VERSION(NV_SWINSTR_SNAPSHOT_DATA,1)
NVAPI_INTERFACE NvAPI_SwInstr_GetSnapshot(NV_SWINSTR_CAPTURE_SETTINGS *pCaptureSettings,
                                          NV_SWINSTR_CAPTURE_BUFFER* pNvSwInstrSnapshotData,
                                          NvU32 *pSize);

typedef struct
{
    NvU32 version;
    void *list;     // Pointer to an array of NV_SOURCE_MODE or NV_TARGET_MODE
                    //  defined in nvapiescape.h.  Currently, there is no need
                    //  to mirror those structures here.
} NV_ENUM_MODES;

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetNumTargetModes
//
// DESCRIPTION:     Get the number of target modes.
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      numTargetModes (OUT) - the number of target modes
//
// RETURN STATUS:
//                  NVAPI_OK - completed error
//                  NVAPI_API_NOT_INTIALIZED - NVAPI not initialized
//                  NVAPI_NO_IMPLEMENTATION - only implemented for Vista
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetNumTargetModes(NvU32 *numTargetModes);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetNumSourceModes
//
// DESCRIPTION:     Get the number of source modes.
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      numSourceModes (OUT) - the number of source modes
//
// RETURN STATUS:
//                  NVAPI_OK - completed error
//                  NVAPI_API_NOT_INTIALIZED - NVAPI not initialized
//                  NVAPI_NO_IMPLEMENTATION - only implemented for Vista
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetNumSourceModes(NvU32 *numSourceModes);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_EnumSourceModes
//
// DESCRIPTION:     Retrieve information for all source modes.
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      pSourceModes(OUT) - @list pointer is an array of type
//                                      NV_SOURCE_MODE with length equal to
//                                      value from NvAPI_GetNumSourceModes
//
// RETURN STATUS:
//                  NVAPI_OK - completed error
//                  NVAPI_API_NOT_INTIALIZED - NVAPI not initialized
//                  NVAPI_NO_IMPLEMENTATION - only implemented for Vista
//                  NVAPI_INVALID_ARGUMENT - user didn't allocate array
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_EnumSourceModes(NV_ENUM_MODES *pSourceModes);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_EnumTargetModes
//
// DESCRIPTION:     Retrieve information for all target modes of the
//                  current source mode.
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      pTargetModes(OUT) - @list pointer is an array of type
//                                      NV_TARGET_MODE with length equal to
//                                      value from NvAPI_GetNumTargetModes
//
// RETURN STATUS:
//                  NVAPI_OK - completed error
//                  NVAPI_API_NOT_INTIALIZED - NVAPI not initialized
//                  NVAPI_NO_IMPLEMENTATION - only implemented for Vista
//                  NVAPI_INVALID_ARGUMENT - user didn't allocate array
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_EnumTargetModes(NV_ENUM_MODES *pTargetModes);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Diag_DP_ASSR
//
//   DESCRIPTION: Makes a control call to RM to get ASSR status/disable ASSR
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK or NVAPI_NOT_SUPPORTED or
//                NVAPI_INVALID_ARGUMENT or NVAPI_API_NOT_INTIALIZED
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Diag_DP_ASSR(NvPhysicalGpuHandle nvGPUHandle, NvU32 outputID, NvU32 disable, NvU32 *enabled, NvU32 *err);



#define NVAPI_DPCD_MAX_DATA_SIZE 16

typedef enum _NV_DPCD_CMD
{
    NV_DP_AUXCH_CMD_REQ_TYPE_WRITE = 0,             // DP Aux Channel write
    NV_DP_AUXCH_CMD_REQ_TYPE_READ,                  // DP Aux Channel read	
    NV_DP_AUXCH_CMD_REQ_TYPE_I2C_WRITE,             // I2C write request
    NV_DP_AUXCH_CMD_REQ_TYPE_I2C_READ,              // I2C read request
    NV_DP_AUXCH_CMD_REQ_TYPE_I2C_WRITE_STATUS,      // I2C write status request
    NV_DP_AUXCH_CMD_REQ_TYPE_MOT_I2C_WRITE,         // I2C write request in middle of transaction 	
    NV_DP_AUXCH_CMD_REQ_TYPE_MOT_I2C_READ           // I2C read request in middle of transaction 

} NV_DPCD_CMD;

typedef enum _NV_DPCD_REPLY_TYPE
{
    NV_DP_AUXCH_REPLYTYPE_ACK = 0,                  // For write: transaction completed and all data bytes written.
                                                    // For read: ACK indicates it is ready for another read request.
    NV_DP_AUXCH_REPLYTYPE_NACK,                     // For write: first return size bytes have been written.
                                                    // For read: implies does not have requested data for the read request transaction.
    NV_DP_AUXCH_REPLYTYPE_DEFER,                    // Not ready for the write/read request and client should retry later.	
    
    NV_DP_AUXCH_REPLYTYPE_TIMEOUT = 0xFF            // The receiver did not respond within the timeout period defined in the DisplayPort 1.1a specification.
} NV_DPCD_REPLY_TYPE;

typedef struct _NV_DPCD_PARAMS
{
    NvU32                version;                        // Structure version
    NvU32                displayId;                      // displayId of DP 
    NV_DPCD_CMD          cmd;                            // NV_DPCD_CMD
    NvU32                addr;                           // addr for read/write
    NvU8                 data[NVAPI_DPCD_MAX_DATA_SIZE]; // data for the read/write cmd
    NvU32                size;                           // number of bytes to read/write. The input size value should be indexed from 0. On return 
                                                         // this parameter returns total number of data bytes successfully read/written, indexed from 1
    NV_DPCD_REPLY_TYPE   replyType;                      // NV_DPCD_REPLY_TYPE
} NV_DPCD_PARAMS;

#define NV_DPCD_PARAMS_VER  MAKE_NVAPI_VERSION(NV_DPCD_PARAMS,1)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Disp_DpAuxChannelControl
//
// DESCRIPTION:   Read/write to DP Aux Channel 
//                The DP display needs to be active to make this NvAPI call.
//
// PARAMETERS:    hNvDisplay (IN)      - Display handle associated with the 
//                                       attached DP monitor
//                pDpcdParams (IN/OUT) - pointer to NV_DPCD_PARAMS structure
//                                       for input/output parameters
//                size (IN)            - length of the pDpcdParams struct 
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK or NVAPI_NOT_SUPPORTED or 
//                NVAPI_INVALID_ARGUMENT or NVAPI_API_NOT_INTIALIZED
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Disp_DpAuxChannelControl(NvDisplayHandle hNvDisplay, NV_DPCD_PARAMS *pDpcdParams, NvU32 size);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Diag_DPCD
//
//   DESCRIPTION: Makes a control call to RM to set/get DPCD
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK or NVAPI_NOT_SUPPORTED or
//                NVAPI_INVALID_ARGUMENT or NVAPI_API_NOT_INTIALIZED
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Diag_DPCD(NvPhysicalGpuHandle nvGPUHandle, void *pDpcdParams, NvU32 size);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Diag_DP_TestPattern
//
//   DESCRIPTION: Makes a control call to RM to set/get(set if BOOL variable
//                set is 1, get otherwise) Physical Test Pattern on DisplayPort.
//                Test patterns that can currently be set include PRBS, D10.2,
//                Symbol Error Rate Measurement(SERM). To stop the test pattern,
//                a test pattern of "None" needs to be set.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK or NVAPI_NOT_SUPPORTED or
//                NVAPI_INVALID_ARGUMENT or NVAPI_API_NOT_INTIALIZED
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Diag_DP_TestPattern(NvPhysicalGpuHandle nvGPUHandle, NvU32 set, void *pTestPatternParams, NvU32 size);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Diag_DP_VideoInfo
//
//   DESCRIPTION: Makes a control call to RM to set/get(set if BOOL variable set
//                is 1, get otherwise) the color format on DisplayPort.
//                Color format includes the bits per component value(6, 8, 10,
//                12, 16), the color space being used (RGB, YCbCr4:2:2,
//                YCbCr4:4:4), the dynamic range (VESA, CEA) and the
//                colorimetry (ITU 601/709).
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK or NVAPI_NOT_SUPPORTED or
//                NVAPI_INVALID_ARGUMENT or NVAPI_API_NOT_INTIALIZED
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Diag_DP_VideoInfo(NvPhysicalGpuHandle nvGPUHandle, NvU32 set, void *pVideoInfoParams, NvU32 size);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Diag_DP_LaneData
//
//   DESCRIPTION: Makes an RM control call to Set/Get(set if BOOL variable set
//                is 1, get otherwise) the Pre-Emphasis/DriveCurrent Level for
//                each lane on DisplayPort
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK or NVAPI_NOT_SUPPORTED or
//                NVAPI_INVALID_ARGUMENT or NVAPI_API_NOT_INTIALIZED
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Diag_DP_LaneData(NvPhysicalGpuHandle nvGPUHandle, NvU32 set, void *pLaneDataParams, NvU32 size);



typedef enum _NV_SET_HYBIRD_DIAG_FUNCTION_ID
{
    NVAPI_SET_HYBRID_DIAG_FUNCTION_ACPI_EVAL_METHOD = 0,        // Submit ACPI Eval Input Buffer to ACPI
    NVAPI_SET_HYBRID_DIAG_FUNCTION_QUERY_CHILD_RELATIONS,       // Ouery ACPIID and ChilduIDs of GPU child devices

    // MUST BE THE LAST ONE!!!  Don't add any new ID after this!!!
    NVAPI_SET_HYBRID_DIAG_NUM_SUPPORTED_FUNCTIONS               // # of SET_HYBRID_DIAG functions exported to NVAPI
} NV_SET_HYBRID_DIAG_FUNCTION_ID;

typedef enum _NV_SET_HYBRID_DIAG_MODE_ID
{
    NVAPI_SET_HYBRID_DIAG_MODE_USE_IGPU = 0,           // Execute diag function on IGPU escape
    NVAPI_SET_HYBRID_DIAG_MODE_USE_DGPU,               // Execute diag function on DGPU escape
    NVAPI_SET_HYBRID_DIAG_MODE_USE_MVIGPU,             // Execute diag function on MVIGPU escape
    NVAPI_SET_HYBRID_DIAG_MODE_USE_MVDGPU,             // Execute diag function on MVDGPU escape

    // MUST BE THE LAST ONE!!!  Don't add any new ID after this!!!
    NVAPI_SET_HYBRID_DIAG_NUM_SUPPORTED_FUNCTION_MODES          // # of SET_HYBRID_DIAG function modes exported to NVAPI
} NV_SET_HYBRID_DIAG_MODE_ID;


#define NV_SET_HYBRID_DIAG_BLOCK_SIZE (64*1024)

typedef struct
{
    NvU32   version;                                    // structure version

    NvU32   ulAcpiID;                                   // ACPI ID associated with diag function
    NvU32    ulDGPU;                                    // DGPU ID asscoiated with diag function
    NV_SET_HYBRID_DIAG_MODE_ID	modeID;                 // Desired Hybrid Escape handler for diag function

    NvU32   bufferSize;
    NvU8    buffer[NV_SET_HYBRID_DIAG_BLOCK_SIZE];      // Buffer for diag data
} NV_SET_HYBRID_DIAG_BLOCK;
#define NV_SET_HYBRID_DIAG_BLOCK_VER MAKE_NVAPI_VERSION(NV_SET_HYBRID_DIAG_BLOCK,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Diag_SetHybridDiag
//
//   DESCRIPTION: Execute a Hybrid Diagnostic function
//
//    PARAMETERS: hPhysicalGpu(IN) - GPU selection.
//                diagFunction(IN) - Hybird Set Diag Function ID.
//                pDiagBLock(IN/OUT) - pointer to Hybird Set Diag Block
//
//
//  SUPPORTED OS: Windows Vista and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hPhysicalGpu or pDiagBlock is null
//                NVAPI_OK: *pDiagBlock is set
//                NVAPI_INCOMPATIBLE_STRUCT_VERSION: NV_SET_HYBRID_DIAG_BLOCK version not compatible with driver
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//                NVAPI_INVALID_HYBRID_MODE: hybrid mode required by NV_SET_HYBRID_DIAG_BLOCK modeID not available
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Diag_SetHybridDiag(NvPhysicalGpuHandle hPhysicalGpu, NV_SET_HYBRID_DIAG_FUNCTION_ID diagFunction, NV_SET_HYBRID_DIAG_BLOCK *pDiagBlock);



// Event IDs    (NOTE: This must be kept in sync with the equivalent enum in nvlEventTypes.h)
typedef enum
{
    NV_EVENT_ID_DIAG,
    NV_EVENT_ID_ACPI_HOTKEY,
    NV_EVENT_ID_POWER_CONNECTOR,
    NV_EVENT_ID_THERMAL,
    NV_EVENT_ID_DRIVER_RECONNECTED,
    NV_EVENT_ID_HYBRID_DUALVIEW_FAIL_ATTACH,
    NV_EVENT_ID_HYBRID_CHANGE_STATE,
    NV_EVENT_ID_HYBRID_NOTIFY_TRIGGER_RECOMMANDVIDPN,
    NV_EVENT_ID_HYBRID_NOTIFY_TRIGGER_POLL_CHILD_CONNECT,
    NV_EVENT_ID_HYBRID_NEXTDISPLAY_STATE,
    NV_EVENT_ID_HYBRID_NOTIFY_TRIGGER_GET_DGPU_EDIDS,
    NV_EVENT_ID_HYBRID_NOTIFY_LIGHTWEIGHT_STATE,
    NV_EVENT_ID_HYBRID_NOTIFY_HIDE_HEADS,
    NV_EVENT_ID_HYBRID_MUX_DEVICE_HOTPLUG,
    NV_EVENT_ID_NULL_MODESET,
    NV_EVENT_ID_BAD_EDID_MODESET,
    NV_EVENT_ID_SLI_SWAP_MASTER_GPU,
    NV_EVENT_ID_PSTATE_CHANGE,
    NV_EVENT_ID_HYBRID_WIN7_HOTPLUG_POWERUP_DGPU,         // Win7 hotplug of dgpu monitor on montevina hybrid when no other external monitor is connected.
                                                          // CCD always lights up the hotplugged monitor. Hence always transition to perf mode in this
                                                          // scenario. No topology or resolution is specified.
    NV_EVENT_ID_HYBRID_WIN7_HOTKEY_TOPOLOGY_POWERUP_DGPU, // Win7 hotkey switches on montevina hybrid. Power up dgpu if needed and switch to specifed topology.
    NV_EVENT_ID_OVERLAY_FAILURE,
    NV_EVENT_ID_GSYNC,
    NV_EVENT_ID_HYBRID_WIN7_FULL_TOPOLOGY_POWERUP_DGPU,   // Win7 MSPanel switches with DGPU monitors. Also used for CCD induced modesets for hotplug when
                                                          // there is atleast one other external monitor already connected. The topology and 
                                                          // resolution+depth+refresh rate is specified.
                                                          
    NV_EVENT_ID_PINNED_SURFACE_ALLOC,                     // Requests nvsvc to create or free an allocation on behalf of KMD		
    NV_EVENT_ID_PINNED_SURFACE_FREE,
    NV_EVENT_ID_COPROC_POWER_REF_COUNT,                   // For Coproc/Gplex/Carlsbad - broadcast when safe/unsafe to power down this adapter.
} NV_EVENT_ID;

// Additional Information Block IDs
typedef enum
{
    NV_EVENT_BLOCK_ID_NONE,       // No associated data block for this event
    NV_EVENT_BLOCK_ID_ACPI,       // ACPI hotkey display change event block
    NV_EVENT_BLOCK_ID_HYBRID_CHANGE_STATE ,   // ACPI hybrid transition
    NV_EVENT_BLOCK_ID_HYBRID_NEXTDISPLAY_STATE,  // Hot key toggle sequence
    NV_EVENT_BLOCK_ID_HYBRID_NOTIFY_LIGHTWEIGHT_STATE,  // Notify state of lightweight startup
    NV_EVENT_BLOCK_ID_HYBRID_DIAG_NOTIFY,        // ACPI Diag notification
    NV_EVENT_BLOCK_ID_HYBRID_CHANGE_STATE_V2,    // ACPI hybrid transition
    NV_EVENT_BLOCK_ID_HYBRID_MUX_DEVICE_HOTPLUG_NOTIFY,     // Device hotplug notifications
    NV_EVENT_BLOCK_ID_PSTATE_CHANGE,    // Pstate change event block
    NV_EVENT_BLOCK_ID_HYBRID_WIN7_HOTKEY_TOPOLOGY_POWERUP_DGPU,  
    NV_EVENT_BLOCK_ID_OVERLAY_FAILURE, // KMD overlay creation failure due to IMP etc.
    NV_EVENT_BLOCK_ID_GSYNC,    // Gsync notifications
    NV_EVENT_BLOCK_ID_HYBRID_WIN7_FULL_TOPOLOGY_POWERUP_DGPU,
    NV_EVENT_BLOCK_ID_PINNED_SURFACE_ALLOC, // Request for a pinned surface from KMD
    NV_EVENT_BLOCK_ID_PINNED_SURFACE_FREE,    
    NV_EVENT_BLOCK_ID_COPROC_POWER_REF_COUNT,
} NV_EVENT_BLOCK_ID;

// Core NV_EVENT structure declaration
typedef struct
{
    NvU32 cbSize;                 // Size of the buffer, include both header and extra data
    NvU32 version;                // Version field to ensure minimum version compatibility
    NvU32 cbBlockOffset;          // Offset from beginning of NV_EVENT to NV_EVENT_BLOCK, in bytes
    NV_EVENT_ID EventId;          // ID of the event being sent
    NV_EVENT_BLOCK_ID BlockId;    // Type ID for NV_EVENT_BLOCK structure
    union
    {
        NvPhysicalGpuHandle PhysicalGpu;  // This field will become Physical GPU handle during the PopEvent
                                          // by NvApiEscape.cpp
        NvU32 Reserved32;         // This field is to ensure proper sizing with the driver
        NvU64 Reserved64;         // This field is to ensure proper sizing with the driver
    };
} NV_EVENT, *PNV_EVENT;
#define NV_EVENT_VERSION        MAKE_NVAPI_VERSION(NV_EVENT,1)

// ACPI hotkey NV_EVENT structure declaration
typedef struct
{
    NvU32    ulInvalidatedDeviceMask;  // The display devices that were connected before hotkey event
    NvU32    ulConnectedDeviceMask;    // The display devices that are to be connected after event
} NV_EVENT_BLOCK_ACPI, *PNV_EVENT_BLOCK_ACPI;

typedef struct _NV_EVENT_BLOCK_HYBRID_CHANGE_STATE
{
    NvU32    hybridState;     // Hybrid Transition state requested from SBios
                              //   1 means iGPU mode
                              //   2 means dGPU mode
} NV_EVENT_BLOCK_HYBRID_CHANGE_STATE, *PNV_EVENT_BLOCK_HYBRID_CHANGE_STATE;

typedef struct _NV_EVENT_BLOCK_HYBRID_CHANGE_STATE_V2
{
    NvU32    hybridState;     // Hybrid Transition state requested from SBios
                              //   0 means adaptive (Follow Power Policy, if available)
                              //   1 means iGPU mode
                              //   2 means dGPU mode
                              //   3 means Multi-Adapter
    NvU32    flags;           // Request Flags Bits, starting with LSB (0)
                              //  bit 0: Prevent Vista Power Policy Override
                              //  bit 1: Override non-migratable
} NV_EVENT_BLOCK_HYBRID_CHANGE_STATE_V2, *PNV_EVENT_BLOCK_HYBRID_CHANGE_STATE_V2;



typedef struct _NV_EVENT_BLOCK_HYBRID_NEXT_DISPLAY
{
    NvU8  transitionRequest;        // It will indicate if there is need of policy transition 
                                    // bit 0 for transition, bit 1 for passing DeviceMask instead of ACPIId.
    union {
        NvU32 ulACPIId1;                 // ACPI Id of Display 1
        NvU32 ulDeviceMask;              // or device mask for all the devices
    };
    NvU32 ulACPIId2;                 // ACPI Id of Display 2
} NV_EVENT_HYBRID_NEXT_DISPLAY, *PNV_EVENT_HYBRID_NEXT_DISPLAY;

typedef struct _NV_EVENT_BLOCK_PINNED_SURFACE_ALLOC
{
    NvU64 hKmHandle;                // adapter identifier
    NvU32 dwPinnedMemId;            // unique identifier for this allocation request
    NvU32 size;                     // size in bytes
}NV_EVENT_BLOCK_PINNED_SURFACE_ALLOC, *PNV_EVENT_BLOCK_PINNED_SURFACE_ALLOC;


typedef struct _NV_EVENT_BLOCK_PINNED_SURFACE_FREE
{
    NvU64 hKmHandle;                // adapter identifier
    NvU32 hMem;                     // memory handle of the allocation to free
}NV_EVENT_BLOCK_PINNED_SURFACE_FREE, *PNV_EVENT_BLOCK_PINNED_SURFACE_FREE;

typedef enum
{
    NV_STATE_UNDEFINED = 0,
    NV_STATE_EDID_REQUESTED = 1,
} NvEventLightweightState;

typedef struct _NV_EVENT_BLOCK_HYBRID_NOTIFY_LIGHTWEIGHT_STATE
{
    NvEventLightweightState state;   // Lightweigth Start State
} NV_EVENT_BLOCK_HYBRID_NOTIFY_LIGHTWEIGHT_STATE, *PNV_EVENT_BLOCK_HYBRID_NOTIFY_LIGHTWEIGHT_STATE;

// ACPI diag notifications
typedef struct _NV_EVENT_BLOCK_HYBRID_DIAG_NOTIFY
{
    NvU32    ulACPINotification;
} NV_EVENT_BLOCK_HYBRID_DIAG_NOTIFY, *PNV_EVENT_BLOCK_HYBRID_DIAG_NOTIFY;

// Hybrid mux device hotplug
typedef struct _NV_EVENT_BLOCK_HYBRID_MUX_DEVICE_HOTPLUG_NOTIFY
{
    NvU32    ulACPIId;          
} NV_EVENT_BLOCK_HYBRID_MUX_DEVICE_HOTPLUG_NOTIFY, *PNV_EVENT_BLOCK_HYBRID_MUX_DEVICE_HOTPLUG_NOTIFY;

typedef struct _NV_EVENT_BLOCK_PSTATE_CHANGE
{
    NvU32 Pstate;
} NV_EVENT_BLOCK_PSTATE_CHANGE, *PNV_EVENT_BLOCK_PSTATE_CHANGE;

typedef struct _NV_EVENT_BLOCK_HYBRID_WIN7_HOTKEY_TOPOLOGY_POWERUP_DGPU
{
    NvU32 ulACPIId1;  // For clone/dualview mode, this device will be the primary device.
    NvU32 ulChildId1; // To be used to program CCD.    
    NvU32 ulACPIId2;  // Will be zero for standard mode. Will be non-zero for clone or dualview mode.
    NvU32 ulChildId2; // To be used to program CCD.
    NvU32 ulReserved; // maybe used for the third head support in fermi
    NV_TARGET_VIEW_MODE ViewMode; // NV_VIEW_MODE_STANDARD/CLONE/DUALVIEW
    NvU32 ulPowerUpDgpu; // 1: At least one of the indicated devices is a dgpu-only device and dgpu is currently powered off, 
                         //    hence nvsvc should first power up the dgpu
                         // 0: No need to power up the dgpu
} NV_EVENT_BLOCK_HYBRID_WIN7_HOTKEY_TOPOLOGY_POWERUP_DGPU, *PNV_EVENT_BLOCK_HYBRID_WIN7_HOTKEY_TOPOLOGY_POWERUP_DGPU;

typedef enum _NV_OVERLAY_FAILURE_TYPE
{
    NV_OVERLAY_FAILURE_GENERAL  = 0,
    NV_OVERLAY_FAILURE_IMP  = 1,
} NV_OVERLAY_FAILURE_TYPE;

typedef struct _NV_EVENT_BLOCK_OVERLAY_FAILURE
{
    NV_OVERLAY_FAILURE_TYPE type;
    NvU32 ulProcessId;
    NvU32 ulPathCount;

} NV_EVENT_BLOCK_OVERLAY_FAILURE, *PNV_EVENT_BLOCK_OVERLAY_FAILURE;

typedef struct _NV_EVENT_BLOCK_GSYNC
{
    NvU32 ulData;  // Notification flags (see ctrl30f1.h)
} NV_EVENT_BLOCK_GSYNC, *PNV_EVENT_BLOCK_GSYNC;

#define FULL_TOPOLOGY_POWERUP_DGPU_MAX_HEADS 2
typedef struct _HYBRID_WIN7_FULL_TOPOLOGY_POWERUP_DGPU_PATH_INFO
{
    NvU32                   ChildId;
    NvU32                   SourceId;       
    
    // source mode information
    NvU32                   Width;              // width of the mode
    NvU32                   Height;             // height of the mode
    NvU32                   PixelFormat;        // Pixelformat of the mode indicating the depth.
    NvU32                   VSyncNumerator;     // Numerator of the refresh rate of the mode
    NvU32                   VSyncDenominator;   // Numerator of the refresh rate of the mode
    
    // These fields will be based on the corresponding D3DKMDT_VIDPN_PRESENT_PATH_IMPORTANCE/ROTATION/SCALING enums.
    NvU32                   ImportanceOrdinal;
    NvU32                   Rotation;           // rotation setting.
    NvU32                   Scaling;            // scaling setting
    NvU32                   ScanlineOrdering;   // interlaced or progressive mode flag
} *PHYBRID_WIN7_FULL_TOPOLOGY_POWERUP_DGPU_PATH_INFO, HYBRID_WIN7_FULL_TOPOLOGY_POWERUP_DGPU_PATH_INFO;


// Power up the DGPU, switch to hybrid perf mode, and do a modeset with the full specified topology.
// This gets called for the scenarios of 
// a) CCD restoring persistence when another external monitor is already connected.
// b) User going to MSPanel to activate the dgpu monitor.
// c) Any general running app doing a modeset to activate the dgpu monitor.
typedef struct _NV_EVENT_BLOCK_HYBRID_WIN7_FULL_TOPOLOGY_POWERUP_DGPU
{
    NvU32 NumPathCount;  // Number of paths.
    HYBRID_WIN7_FULL_TOPOLOGY_POWERUP_DGPU_PATH_INFO PathInfo[FULL_TOPOLOGY_POWERUP_DGPU_MAX_HEADS];
} NV_EVENT_BLOCK_HYBRID_WIN7_FULL_TOPOLOGY_POWERUP_DGPU, *PNV_EVENT_BLOCK_HYBRID_WIN7_FULL_TOPOLOGY_POWERUP_DGPU;

// Coproc/Gplex/Carlsbad
// Container for NV_EVENT_ID_COPROC_POWER_REF_COUNT
typedef struct _NV_EVENT_BLOCK_COPROC_POWER_REF_COUNT
{
    NvU64       SequenceNumber;     // Keeps events and queries in order

    NvU32       ReferenceCount;     // Will be 0 or 1
                                    // 0 - safe to power off this adapter.
                                    // nonzero - not safe to power off.
    NvU32       pad0;

} NV_EVENT_BLOCK_COPROC_POWER_REF_COUNT;

typedef struct _NV_EVENT_COPROC_POWER_REF_COUNT
{
    NV_EVENT                                header;
    
    NV_EVENT_BLOCK_COPROC_POWER_REF_COUNT   data;

} NV_EVENT_COPROC_POWER_REF_COUNT;

// Callback Format
typedef void (__cdecl *NV_EVENT_CALLBACK)(NV_EVENT* Event, void* CallbackParam);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Event_RegisterForEvents
//
// DESCRIPTION:   Register the process for events
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:    IN NV_EVENT_CALLBACK Callback - Pointer to function to call
//                                                on new events
//                IN void* CallbackParam        - void* Parameter to be passed
//                                                to the callback function
//                OUT NvEventHandle* phClient   - Handle to client for use with
//                                                unregister function
//
// RETURN STATUS:
//                NVAPI_OK - completed request
//                NVAPI_ERROR - miscellaneous error occurred
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Event_RegisterForEvents(NV_EVENT_CALLBACK Callback,
                                              void* CallbackParam,
                                              NvEventHandle* phClient);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Event_Unregister
//
// DESCRIPTION:   Unregister an event handle
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:    hClient(IN) - Handle associated with this listeners
//                              event queue. Same as passed by
//                              RegisterForEvents.
//
// RETURN STATUS:
//                NVAPI_OK - completed request
//                NVAPI_ERROR - miscellaneous error occurred
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Event_Unregister(NvEventHandle hClient);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SYS_EnableDisplayHotkeyHandling
//
// DESCRIPTION:   Configure the display driver to handle ACPI hotkeys
//
//  SUPPORTED OS: Windows Vista and higher
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_EnableDisplayHotkeyHandling(void);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SYS_DisableDisplayHotkeyHandling
//
// DESCRIPTION:   Configure the display driver to only send events on ACPI
//                hotkeys
//
//  SUPPORTED OS: Windows Vista and higher
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_DisableDisplayHotkeyHandling(void);


typedef struct
{
    NvU32               GPUId;          //dGPU Id
    NvU32               Devicemask;     //display mask
} NV_HYBRID_GPU_INFO;

typedef struct
{
    NvU32               version;           //structure version
    NvU32               GPUCount;          // Number of GPU Info structures
    NV_HYBRID_GPU_INFO  GPUs[NVAPI_MAX_PHYSICAL_GPUS];
}NV_HYBRID_OUTPUTS_INFO;

#define NV_HYBRID_OUTPUTS_INFO_VER  MAKE_NVAPI_VERSION(NV_HYBRID_OUTPUTS_INFO,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_GetHybridConnectedOutputs
//
// DESCRIPTION:    Returns set of GPUs- with gpuid and conneced device mask array.
//                 It is for hybrid system, to get display info of devices connected
//                 with dGPU.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE     NvAPI_GetHybridConnectedOutputs(NV_HYBRID_OUTPUTS_INFO *dGPUInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_GetHybridEDID
//
// DESCRIPTION:    Return Edid for a particular dGPU display for a hybrid system.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE     NvAPI_GetHybridEDID(NvU32 GPUId, NvU32 displayOutputId, NV_EDID *pEDID);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SendHybridMessage
//
// DESCRIPTION:     This API sends a hybrid message to nvsvc
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      msgType(IN)       - message type
//                  param(IN)         - message param
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////

typedef enum _NV_HYBRID_MESSAGE
{
    NV_HYBRID_MESSAGE_D3D_ATTACH           = 0x00,
    NV_HYBRID_MESSAGE_OGL_ATTACH           = 0x01,
    NV_HYBRID_MESSAGE_PROCESS_ATTACH       = 0x02,
    NV_HYBRID_MESSAGE_PROCESS_DETACH       = 0x03,
    NV_HYBRID_MESSAGE_POWER_SETTING        = 0x04,
    NV_HYBRID_MESSAGE_POWER_SOURCE         = 0x05,
    NV_HYBRID_MESSAGE_DISPLAY_SETTING      = 0x06,
    NV_HYBRID_MESSAGE_DOCKING              = 0x07,
    NV_HYBRID_MESSAGE_THERMAL              = 0x08,
    NV_HYBRID_MESSAGE_SETHYBRIDMODE        = 0x09,
} NV_HYBRID_MESSAGE;

NVAPI_INTERFACE NvAPI_SendHybridMessage(NV_HYBRID_MESSAGE msgType, NvU32 param);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SetHybridMode
//
// DESCRIPTION: This API sets Hybrid mode. Supported on Vista and higher.
//              App calling this API is required to run in elevated mode.
//              This API can be called from a system service to derive the elevated context of the System service.
//              Non migratable apps running can prevent a successful transition. To query non migratable
//              apps use the NvAPI_QueryNonMigratableApps.
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      mode(IN)     - hybrid mode
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////

typedef enum _NV_HYBRID_MODE
{
    NV_HYBRID_MODE_IGPU                 = 0x00,
    NV_HYBRID_MODE_DGPU                 = 0x01,
    NV_HYBRID_MODE_MULTI_ADAPTER        = 0x02,
    NV_HYBRID_MODE_INVALID              = 0x03,
    NV_HYBRID_MODE_DGPU_WARMUP          = 0x04,
    NV_HYBRID_MODE_DGPU_DEEP_IDLE       = 0x05,
    NV_HYBRID_MODE_INSTALL              = 0x06,
} NV_HYBRID_MODE;

NVAPI_INTERFACE NvAPI_SetHybridMode(NV_HYBRID_MODE mode);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetHybridMode
//
// DESCRIPTION:     This API gets current Hybrid mode. Supported on Vista and higher.
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      pMode(OUT)     - hybrid mode
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_GetHybridMode(NV_HYBRID_MODE *pMode);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetHybridSwitchStatus
//
// DESCRIPTION:     This API gets current Hybrid Switch Status
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:      pMode(OUT)     - hybrid mode
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetHybridSwitchStatus(NV_HYBRID_MODE *pMode);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetHybridInfo
//
// DESCRIPTION:     This API queries the valid hybrid modes, the hybrid status. Supported on Vista and higher.
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      pHybridInfo (IN)     - the hybrid info structure
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////

typedef struct
{
    NvU32 version;                          // the structure version
    NvU32 validHybridModes;                 // NV_HYBRID_STATUS mask
    NvU32 hybridStatus;                     // NV_HYBRID_VALID_MODES mask
} NV_HYBRID_INFO_v1;

typedef struct
{
    NvU32 version;                          // the structure version
    NvU32 validHybridModes;                 // NV_HYBRID_STATUS mask
    NvU32 hybridStatus;                     // NV_HYBRID_VALID_MODES mask
    NvU32 hybridDefaultGPU;                 // NV_GPU_TYPE: default GPU in the current mode
    NvU32 hybridUIState;                    // NV_HYBRID_STATE : what is the UI icon showing
    NvU32 hybridDriverState;                // NV_HYBRID_STATE : what state is the driver in
    NvU32 bIsHybridPerfSliSupported:1;      // boolean: 0 = not supported, 1 = supported;
    NvU32 bIsHybridMCP:1;                   // boolean: true if this is an MCP board.
    NvU32 bIsHybridMobileSystem:1;          // boolean: true if a mobile hybrid system
    NvU32 transferNodeType;                 // NV_HYBRID_TRANSFER_NODE
} NV_HYBRID_INFO_v2;

typedef struct
{
    NvU32 version;                          // the structure version
    NvU32 validHybridModes;                 // NV_HYBRID_STATUS mask
    NvU32 hybridStatus;                     // NV_HYBRID_VALID_MODES mask
    NvU32 hybridDefaultGPU;                 // NV_GPU_TYPE: default GPU in the current mode
    NvU32 hybridUIState;                    // NV_HYBRID_STATE : what is the UI icon showing
    NvU32 hybridDriverState;                // NV_HYBRID_STATE : what state is the driver in
    NvU32 bIsHybridPerfSliSupported:1;      // boolean: 0 = not supported, 1 = supported;
    NvU32 bIsHybridMCP:1;                   // boolean: true if this is an MCP board.
    NvU32 bIsHybridMobileSystem:1;          // boolean: true if a mobile hybrid system
    NvU32 transferNodeType;                 // NV_HYBRID_TRANSFER_NODE
    NvU8  showHybridUI;                     // (boolean) show the hybrid UI
} NV_HYBRID_INFO;

#define NV_HYBRID_INFO_VER          MAKE_NVAPI_VERSION(NV_HYBRID_INFO, 3)
#define NV_HYBRID_INFO_VER_1        MAKE_NVAPI_VERSION(NV_HYBRID_INFO_v1, 1)
#define NV_HYBRID_INFO_VER_2        MAKE_NVAPI_VERSION(NV_HYBRID_INFO_v2, 2)

typedef enum
{
    NV_HYBRID_STATUS_OK                     = 0x00000000,
    NV_HYBRID_STATUS_CHIPSET_NOT_SUPPORTED  = 0x00000001,
    NV_HYBRID_STATUS_MGPU_NOT_SUPPORTED     = 0x00000002,
    NV_HYBRID_STATUS_DGPU_NOT_SUPPORTED     = 0x00000004,
    NV_HYBRID_STATUS_NO_ASYNC_DMA_ENGINE    = 0x00000008,
    NV_HYBRID_STATUS_SBIOS_NOT_CONFIGURED   = 0x00000010,
    NV_HYBRID_STATUS_DGPUS_NOT_IDENTICAL    = 0x00000020,
    NV_HYBRID_STATUS_INVALID_GPU_COUNT      = 0x00000040,
    NV_HYBRID_STATUS_DGPU_DEEP_IDLE_NOT_SUPPORTED = 0x00000080
} NV_HYBRID_STATUS;

typedef enum
{
    NV_HYBRID_VALID_MODE_NONE               = 0x00000000,
    NV_HYBRID_VALID_MODE_POWER              = 0x00000001,
    NV_HYBRID_VALID_MODE_PERF               = 0x00000002,
    NV_HYBRID_VALID_MODE_PERFSLI            = 0x00000004,
    NV_HYBRID_VALID_MODE_MULTI_ADAPTER      = 0x00000008,
    NV_HYBRID_VALID_MODE_POWER_DEEP_IDLE          = 0x00000010
} NV_HYBRID_VALID_MODES;

typedef enum _NV_HYBRID_TRANSFER_NODE
{
    NV_HYBRID_TRANSFER_NODE_3D            = 0x00000000,
    NV_HYBRID_TRANSFER_NODE_CIPHER        = 0x00000001,
    NV_HYBRID_TRANSFER_NODE_VP            = 0x00000002,
    NV_HYBRID_TRANSFER_NODE_DMACOPY0      = 0x00000003,
    NV_HYBRID_TRANSFER_NODE_DMACOPY1      = 0x00000004,
    NV_HYBRID_TRANSFER_NODE_UNKNOWN       = 0xFFFFFFFF
} NV_HYBRID_TRANSFER_NODE;

typedef enum _NV_HYBRID_STATE
{
    NV_HYBRID_STATE_POWER              = 0x00000000,
    NV_HYBRID_STATE_PERF               = 0x00000001,
    NV_HYBRID_STATE_MULTI_ADAPTER      = 0x00000002,
    NV_HYBRID_STATE_INVALID            = 0xFFFFFFFF,
} NV_HYBRID_STATE;


NVAPI_INTERFACE NvAPI_GetHybridInfo(NV_HYBRID_INFO *pHybridInfo);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Coproc_GetCoprocInfo
//
// DESCRIPTION:     This API queries the the copoc status. Supported on Vista and higher.
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      pCoprocInfo (IN)     - the coproc info structure
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////

typedef struct
{
    NvU32 version;                      // the structure version
    NvU32 coprocStatusMask;             // NV_COPROC_STATUS mask
    NvU32 coprocFlags;                  // NV_COPROC_FLAGS mask
    NvU32 totalReferenceCount;          // Sum of references keeping the GPU powered up.
    NvU32 deviceCount;                  // Devices created on GPU
    NvU32 allocationCount;              // Allocations created on GPU
    NvU32 activeEntryPointCount;        // Active calls into the KMD.
    NvU32 timeInCurrentStateMs;         // in ms
    NvU32 timeInLastStateMs;            // in ms
    NvU8  currentState;                 // State NV_COPROC_STATE
    NvU8  lastState;                    // State NV_COPROC_STATE
} NV_COPROC_INFO;

#define NV_COPROC_INFO_VER          MAKE_NVAPI_VERSION(NV_COPROC_INFO, 1)

typedef enum
{
    NV_COPROC_STATUS_OK                     = 0x00000000,
    NV_COPROC_STATUS_CHIPSET_NOT_SUPPORTED  = 0x00000001,
    NV_COPROC_STATUS_MGPU_NOT_SUPPORTED     = 0x00000002,
    NV_COPROC_STATUS_DGPU_NOT_SUPPORTED     = 0x00000004,
    NV_COPROC_STATUS_INVALID_GPU_COUNT      = 0x00000008,
    NV_COPROC_STATUS_DISABLED_BY_REG_KEY    = 0x00000010,
    NV_COPROC_STATUS_DGPU_POSTING_DEVICE    = 0x00000020,
    NV_COPROC_STATUS_DISABLED_BY_HYBRID     = 0x00000040,
} NV_COPROC_STATUS;

typedef enum 
{
    NV_COPROC_FLAGS_NONE                    = 0x00000000,
    NV_COPROC_FLAGS_MONITOR_FOUND           = 0x00000001,
    NV_COPROC_FLAGS_TIMER_SCHEDULED         = 0x00000002,
} NV_COPROC_FLAGS;

typedef enum 
{
    NV_COPROC_STATE_DGPU_GOLD              = 0x00000000,
    NV_COPROC_STATE_DGPU_ON                = 0x00000001,
} NV_COPROC_STATE;

NVAPI_INTERFACE NvAPI_Coproc_GetCoprocInfo(NV_COPROC_INFO *pCoprocInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetHybridStatusString
//
//   DESCRIPTION: converts an Hybrid status into a null terminated string
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: null terminated string (always, never NULL)
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetHybridStatusString(NvU32 nr,NvAPI_String szDesc);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetHybridModesString
//
//   DESCRIPTION: converts an hybrid mode into a null terminated string
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: null terminated string (always, never NULL)
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetHybridModesString(NvU32 nr,NvAPI_String szDesc);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Coproc_GetCoprocStatusString
//
//   DESCRIPTION: converts an Coproc status into a null terminated string
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: null terminated string (always, never NULL)
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Coproc_GetCoprocStatusString(NvU32 nr,NvAPI_String szDesc);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Coproc_GetCoprocFlagsString
//
//   DESCRIPTION: converts an Coproc status into a null terminated string
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: null terminated string (always, never NULL)
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Coproc_GetCoprocFlagsString(NvU32 nr,NvAPI_String szDesc);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_LightWeightDGPU
//
//   DESCRIPTION: Wakes up dGPU and loads nvidia driver for Intel_Hybrid systems
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_OK - completed request
//                NVAPI_ERROR - miscellaneous error occurred
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_LightWeightDGPU(NvU32 flags);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_HybridIGPUHeadsControl
//
//   DESCRIPTION: Requests the Hybrid Interposer to hide or unhide IGPU heads
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_OK - completed request
//                NVAPI_ERROR - miscellaneous error occurred
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_HybridIGPUHeadsControl(NvU8 bHide);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_QueryHybridIGPUHeadsControl
//
//   DESCRIPTION: Query the Hybrid Interposer IGPU hide heads state
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_OK - completed request
//                NVAPI_ERROR - miscellaneous error occurred
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_QueryHybridIGPUHeadsControl(NvU8 *pbHide);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_IsIntelHybrid
//
// PARAMETERS:      IsIntel(IN/OUT)          - boolean: zero=Not a Intel Hybrid System, one=Intel Hybrid System
// DESCRIPTION:     This API determines whether running system is Intel Hybrid or not
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: 
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_IsIntelHybrid(NvU8 *IsIntel);



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Hybrid_SetDGPUPowerState
//
// DESCRIPTION: This API sets the dGPU Power State on a hybrid system. 
//         Supported on Vista and higher.
//              App calling this API is required to run in elevated mode. 
//              When called, this will change the power state of all dGPUs in
//              the system.
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:      powerState(IN)     - Requested power state for dGPUs
//
// RETURN STATUS: 
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////

typedef enum _NV_HYBRID_POWERSTATE
{
    NV_HYBRID_POWERSTATE_OFF       = 0x00,
    NV_HYBRID_POWERSTATE_ON        = 0x01,
    NV_HYBRID_POWERSTATE_DEEPIDLE  = 0x02, 
} NV_HYBRID_POWERSTATE;

NVAPI_INTERFACE NvAPI_Hybrid_SetDGPUPowerState(NV_HYBRID_POWERSTATE powerState);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Hybrid_GetDGPUPowerState
//
// DESCRIPTION:     This API gets current dGPU Power State. 
//                  Supported on Vista and higher.
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:      pPowerState(OUT)     - Power State
//
// RETURN STATUS: 
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_Hybrid_GetDGPUPowerState(NV_HYBRID_POWERSTATE *pPowerState);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Hybrid_StartTransition
//
// DESCRIPTION: This API notifies the driver to start a hybrid transition
//         Supported on Vista and higher.
//              App calling this API is required to run in elevated mode. 
//              This call is called after the dGPUs are powered up, but before
//              the DGPU drivers are enabled.
//              If this call succeeds, an NvAPI_Hybrid_StopTransition() must
//              be called, regardless of success or failure.
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:      mode(IN)     - Requested mode for transition
//                  phTransition(OUT) - Handle used to address this transition
//
// RETURN STATUS: 
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_Hybrid_StartTransition(NV_HYBRID_MODE mode, NvTransitionHandle* phTransition);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Hybrid_StopTransition
//
// DESCRIPTION: This API notifies the driver to stop a hybrid transition
//         Supported on Vista and higher.
//              App calling this API is required to run in elevated mode. 
//              This call is called after the drivers are stable, but
//              not necessarily powered off.
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:      hTransition(IN) - Handle returned from NvAPI_Hybrid_StartTransition
//                  mode(IN)     - Final mode which was accepted
//                                 This might be different than the 
//                                 StartTransition mode, since a failure
//                                 could result in falling back
//
// RETURN STATUS: 
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_Hybrid_StopTransition(NvTransitionHandle hTransition, NV_HYBRID_MODE mode);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Hybrid_SetDGPUDriverState
//
// DESCRIPTION:     This API sets the current dGPU Driver State
//                  Supported on Vista and higher.
//                  NOTE: If the driver is currently yellow-banged, and the
//                  request is to start the driver, a stop will be called 
//                  first to clear the driver failure.
//                  This call is made after a successful StartTransition
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:      hTransition(IN) - Handle returned from NvAPI_Hybrid_StartTransition
//                  driverState(IN) - Requested driver state
//
// RETURN STATUS: 
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////

typedef enum _NV_HYBRID_DRIVERSTATE
{
    NV_HYBRID_DRIVERSTATE_UNKNOWN   = 0x00,
    NV_HYBRID_DRIVERSTATE_DISABLED  = 0x01,
    NV_HYBRID_DRIVERSTATE_ENABLED   = 0x02,
    NV_HYBRID_DRIVERSTATE_PROBLEM   = 0x03,
    NV_HYBRID_DRIVERSTATE_STARTING  = 0x04,
} NV_HYBRID_DRIVERSTATE;

NVAPI_INTERFACE NvAPI_Hybrid_SetDGPUDriverState(NvTransitionHandle hTransition, NV_HYBRID_DRIVERSTATE driverState);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Hybrid_GetDGPUDriverState
//
// DESCRIPTION:     This API gets the current dGPU Driver State
//                  Supported on Vista and higher.
//                  NOTE: If the driver is currently yellow-banged, and the
//                  request is to start the driver, a stop will be called 
//                  first to clear the driver failure.
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:      hTransition(IN) - Handle returned from NvAPI_Hybrid_StartTransition
//                  pDriverState(OUT) - Current driver state
//
// RETURN STATUS: 
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_Hybrid_GetDGPUDriverState(NvTransitionHandle hTransition, NV_HYBRID_DRIVERSTATE* pDriverState);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Hybrid_StartDisplaySwitch
//
// DESCRIPTION: This API notifies the driver to prepare to switch the display
//         Supported on Vista and higher.
//              App calling this API is required to run in elevated mode. 
//              This call is called after the dGPUs drivers are enabled, but
//              before calls to ChangeDisplaySettingsEx
//              If this call succeeds, an NvAPI_Hybrid_StopDisplaySwitch() 
//              must be called, regardless of success or failure.
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:      hTransition(IN) - Handle returned from NvAPI_Hybrid_StartTransition
//                  mode(IN)     - Requested mode for transition
//
// RETURN STATUS: 
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_Hybrid_StartDisplaySwitch(NvTransitionHandle hTransition, NV_HYBRID_MODE mode);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Hybrid_StopDisplaySwitch
//
// DESCRIPTION: This API notifies the driver that display switching is done
//         Supported on Vista and higher.
//              App calling this API is required to run in elevated mode. 
//              This call is called after an attempt to move the active display
//              to the new hybrid display. The requested mode may differ if
//              a failure was encountered during the switching of displays.
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:      hTransition(IN) - Handle returned from NvAPI_Hybrid_StartTransition
//                  mode(IN)     - Final mode which was accepted
//                                 This might be different than the 
//                                 StartTransition mode, since a failure
//                                 could result in falling back
//
// RETURN STATUS: 
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_Hybrid_StopDisplaySwitch(NvTransitionHandle hTransition, NV_HYBRID_MODE mode);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Hybrid_GetMirroredDisplays
//
// DESCRIPTION:     This API gets the display mirrors for power and perf.
//                  Supported on Vista and higher.
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:      hTransition(IN) - Handle returned from NvAPI_Hybrid_StartTransition
//                  pMirroredHeadIDs(OUT) - Array of NVAPI_MAX_HEADS_PER_GPU
//                                          elements which holds the mirror
//                                          IDs for a configuration
//
// RETURN STATUS: 
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_Hybrid_GetMirroredDisplays(NvTransitionHandle hTransition, 
                                                 NvU32* pMirroredHeadIDs);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Hybrid_SwapDisplays
//
// DESCRIPTION:     This API swaps the current active displays from one adapter
//                  to the other. This should not be used with multi-adapter.
//                  Supported on Vista and higher.
//                  Mode is used to verify the proper display direction
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:      hTransition(IN) - Handle returned from NvAPI_Hybrid_StartTransition
//                  mode(IN)     - Requested mode for transition
//
// RETURN STATUS: 
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_Hybrid_SwapDisplays(NvTransitionHandle hTransition, NV_HYBRID_MODE mode);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Hybrid_SetDisplayMUX
//
// DESCRIPTION:     This API sets the active display MUX, used on systems with
//                  either Intel Hybrid, or MCP controlled by a MUX.
//                  Supported on Vista and higher.
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:      hTransition(IN) - Handle returned from NvAPI_Hybrid_StartTransition
//                  mode(IN) - Must be either NV_HYBRID_MODE_IGPU or 
//                             NV_HYBRID_MODE_DGPU
//
// RETURN STATUS: 
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_Hybrid_SetDisplayMUX(NvTransitionHandle hTransition, NV_HYBRID_MODE mode);


// Basic Flow Diagram of SetHybridMode(NV_HYBRID_MODE_DGPU)
//
//  NvAPI_Hybrid_SetDGPUPowerState(NV_HYBRID_POWERSTATE_ON);
//  NvAPI_Hybrid_StartTransition(NV_HYBRID_MODE_DGPU);
//  NvAPI_Hybrid_SetDGPUDriverState(NV_HYBRID_DRIVERSTATE_ENABLED);
//  NvAPI_Hybrid_StartDisplaySwitch(NV_HYBRID_MODE_DGPU);
//  NvAPI_Hybrid_SwapDisplays(NV_HYBRID_MODE_DGPU);
//  NvAPI_Hybrid_StopDisplaySwitch(NV_HYBRID_MODE_DGPU);
//  NvAPI_Hybrid_StopTransition(NV_HYBRID_MODE_DGPU);

// Basic Flow Diagram of SetHybridMode(NV_HYBRID_MODE_IGPU)
//
//  NvAPI_Hybrid_StartTransition(NV_HYBRID_MODE_IGPU);
//  NvAPI_Hybrid_StartDisplaySwitch(NV_HYBRID_MODE_IGPU);
//  NvAPI_Hybrid_SwapDisplays(NV_HYBRID_MODE_IGPU);
//  NvAPI_Hybrid_StopDisplaySwitch(NV_HYBRID_MODE_IGPU);
//  NvAPI_Hybrid_SetDGPUDriverState(NV_HYBRID_DRIVERSTATE_DISABLED);
//  NvAPI_Hybrid_StopTransition(NV_HYBRID_MODE_IGPU);
//  NvAPI_Hybrid_SetDGPUPowerState(NV_HYBRID_POWERSTATE_OFF);

// Basic Flow Diagram of SetHybridMode(NV_HYBRID_MODE_MULTI_ADAPTER)
//
//  NvAPI_Hybrid_SetDGPUPowerState(NV_HYBRID_POWERSTATE_ON);
//  NvAPI_Hybrid_StartTransition(NV_HYBRID_MODE_MULTI_ADAPTER);
//  NvAPI_Hybrid_SetDGPUDriverState(NV_HYBRID_DRIVERSTATE_ENABLED);
//  NvAPI_Hybrid_StopTransition(NV_HYBRID_MODE_MULTI_ADAPTER);



#define NV_MAX_HYBRID_ACPI_IDS      16      // Based on NV_MAX_DOD_ACPI_IDS as per spec limit
typedef struct
{
    NvU32                   acpiId;
    NvU32                   intelId;
    NvU32                   displayId;          // Not yet supported
    NvPhysicalGpuHandle     physicalGpu;        // Not yet supported
    NvU32                   outputId;
} NV_HYBRID_INTEL_DEVICE_MAP_ENTRY;

typedef struct
{
    NvU32 version;
    NvU32 count;
    NV_HYBRID_INTEL_DEVICE_MAP_ENTRY maps[NV_MAX_HYBRID_ACPI_IDS];
} NV_HYBRID_INTEL_DEVICE_MAP;

#define NV_HYBRID_INTEL_DEVICE_MAP_VER          MAKE_NVAPI_VERSION(NV_HYBRID_INTEL_DEVICE_MAP, 1)

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Hybrid_GetIntelDeviceMap
//
// DESCRIPTION:     This API gets the mapping table for all the IDs for an
//                  Intel Hybrid system. The system must have booted to 
//                  NV_HYBRID_MODE_DGPU at least once before this call will
//                  succeed.
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:      pMap(IN/OUT) - Pointer to the NV_HYBRID_INTEL_DEVICE_MAP
//                                 structure, which will be filled with the
//                                 proper data.
//
// RETURN STATUS: 
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//                  NVAPI_DATA_NOT_FOUND - System must have been to DGPU mode
//                                         before calling this API
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Hybrid_GetIntelDeviceMap(NV_HYBRID_INTEL_DEVICE_MAP* pMap);



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetAdaptiveContrastInfo()
//
// DESCRIPTION:     This API gets the parameters for adaptive contrast enchancement and color shift/squeeze
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      hNvDisplay(IN)  - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated
//                                    from NvAPI_EnumNVidiaDisplayHandle().
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_API_NOT_INTIALIZED - You first have to initialize NVAPI
//
///////////////////////////////////////////////////////////////////////////////
#define NV_ADAPTIVE_CONTRAST_INFO_NUM_CONSTS 128
typedef struct
{
    NvU32   version;                // the structure version
    NvU32   consts[NV_ADAPTIVE_CONTRAST_INFO_NUM_CONSTS];
     // 0-16 YUV2RGB coefs
     //16-24 maxdistance
     //24-32 squeeze constants
     //32-64 sliders
     //64-128 YUV regions for green,red, skin
}NV_ADAPTIVE_CONTRAST_INFO;
#define NV_ADAPTIVE_CONTRAST_INFO_VER  MAKE_NVAPI_VERSION(NV_ADAPTIVE_CONTRAST_INFO,1)
NVAPI_INTERFACE NvAPI_GetAdaptiveContrastInfo(NvDisplayHandle hNvDisplay, NV_ADAPTIVE_CONTRAST_INFO *pCfg);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SetAdaptiveContrastInfo()
//
// DESCRIPTION:     This API sets the parameters for adaptive contrast enchancement and color shift/squeeze
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:      hNvDisplay(IN)  - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated
//                                    from NvAPI_EnumNVidiaDisplayHandle().
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_API_NOT_INTIALIZED - You first have to initialize NVAPI
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetAdaptiveContrastInfo(NvDisplayHandle hNvDisplay, NV_ADAPTIVE_CONTRAST_INFO *pCfg);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GPU_SetVidPnInfo
//
// DESCRIPTION:     This API allows the caller to inform the driver of any display
//                  change events so that the VidPnSrcId's may be updated
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      hPhysicalGpu(IN)    - GPU selection.
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_GPU_SetVidPnInfo(NvPhysicalGpuHandle hPhysicalGpu);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetVideoState
//
// DESCRIPTION:     Return the video state component for the component ID passed in. It is the responsibility
//                  of the caller to fill secret application key that enables authentication of the caller.
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:      hNvDisplay(IN)          - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated
//                                            from NvAPI_EnumNVidiaDisplayHandle().
//                  pGetVidStateComp(IN)    - NVAPI_GET_VIDEO_STATE_COMPONENT packet containing
//                                            a valid component ID and a valid application secret key.
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////

#ifndef NV_VIDEO_COMPONENTS_DEFINE
#define NV_VIDEO_COMPONENTS_DEFINE

///////////////////////////////////////////////////////////////////////////////
// Structs and enums related to Video state
///////////////////////////////////////////////////////////////////////////////

// Components related to video state
typedef enum _NVAPI_VIDEO_STATE_COMPONENT_ID
{
    NVAPI_VIDEO_STATE_COMPONENT_ID_NONE     = -1,   // Placeholder for invalid component ID
    NVAPI_VIDEO_STATE_COMPONENT_BRIGHTNESS      ,   // Permits control of video's brightness value
    NVAPI_VIDEO_STATE_COMPONENT_CONTRAST        ,   // Allows control of video's contrast value
    NVAPI_VIDEO_STATE_COMPONENT_HUE             ,   // To control the hue value
    NVAPI_VIDEO_STATE_COMPONENT_SATURATION      ,   // Allows control of video's saturation value
    NVAPI_VIDEO_STATE_COMPONENT_COLORTEMP       ,   // Allows control of the color temperature value
    NVAPI_VIDEO_STATE_COMPONENT_Y_GAMMA         ,   // To set the Y-gamma values
    NVAPI_VIDEO_STATE_COMPONENT_RGB_GAMMA_R     ,   // To set the R value of RGB gamma
    NVAPI_VIDEO_STATE_COMPONENT_RGB_GAMMA_G     ,   // To set the G value of RGB gamma
    NVAPI_VIDEO_STATE_COMPONENT_RGB_GAMMA_B     ,   // To set the B value of RGB gamma
    NVAPI_VIDEO_STATE_COMPONENT_COLOR_SPACE     ,   // Permits choice of various color spaces using VIDEO_COMP_ALGO_COLOR_SPACE_xxx
    NVAPI_VIDEO_STATE_COMPONENT_COLOR_RANGE     ,   // Allows setting between a limited/full color range using VIDEO_COMP_ALGO_COLOR_RANGE_xxx
    NVAPI_VIDEO_STATE_COMPONENT_PLAYBACK_PROFILE,   // Permits using special postprocessing for Adobe Flash 9 Content
    NVAPI_VIDEO_STATE_COMPONENT_DEINTERLACE     ,   // To set various types of deinterlacing algorithms
    NVAPI_VIDEO_STATE_COMPONENT_SCALING         ,   // Allows setting video scaling algorithms
    NVAPI_VIDEO_STATE_COMPONENT_CADENCE         ,   // Allows control of the cadence algorithms
    NVAPI_VIDEO_STATE_COMPONENT_NOISE_REDUCE    ,   // Allows setting post-processing noise reduction values
    NVAPI_VIDEO_STATE_COMPONENT_EDGE_ENHANCE    ,   // Permits post-processing edge enhancement value adjustment
    NVAPI_VIDEO_STATE_COMPONENT_OVERDRIVE       ,   // To control the overdrive feature
    NVAPI_VIDEO_STATE_COMPONENT_SPLITSCREEN     ,   // To permit setting a splitscreen using one of VIDEO_COMP_ALGO_SPLITSCREEN_xxx
    NVAPI_VIDEO_STATE_COMPONENT_DEBLOCKING      ,   // Allows out-of-loop deblocking
    NVAPI_VIDEO_STATE_COMPONENT_DYNAMIC_CONTRAST,   // Permits control of video's dynamic contrast value
    NVAPI_VIDEO_STATE_COMPONENT_GREEN_STRETCH   ,   // Permits control of green stretch
    NVAPI_VIDEO_STATE_COMPONENT_BLUE_STRETCH    ,   // Allows control of blue enhancement
    NVAPI_VIDEO_STATE_COMPONENT_SKIN_TONE_CORRECTION, // Allows skin-tone correction for video
    NVAPI_VIDEO_STATE_COMPONENT_GAMUT_REMAPPING ,   // Applies gamut remapping on video
    NVAPI_VIDEO_STATE_COMPONENT_ID_LAST         ,   // All valid components defined before this one
} NVAPI_VIDEO_STATE_COMPONENT_ID;

#define NVAPI_VIDEO_STATE_COMPONENT_DYNAMIC_CONSTRAST  NVAPI_VIDEO_STATE_COMPONENT_DYNAMIC_CONTRAST  // dynamic contrast value. Kept this for backward compatibility

// Algorithms controlling various video components

#define VIDEO_COMP_ALGO_CUSTOM_BASE 64

typedef enum _NVAPI_VIDEO_COMPONENT_ALGORITHM
{
    VIDEO_COMP_ALGO_COLOR_SPACE_601                  = 0,  // Use the ITU-R BT.601 standard in color-space conversion for xxx_COLOR_SPACE component
    VIDEO_COMP_ALGO_COLOR_SPACE_709                  = 1,  // Use the ITU-R BT.709 standard in color-space conversion for xxx_COLOR_SPACE component
    VIDEO_COMP_ALGO_COLOR_RANGE_STD                  = 0,  // Full range of (0-255) for xxx_COLOR_RANGE component, equivalent to Microsoft's DXVADDI_NOMINALRANGE::DXVADDI_NominalRange_0_255
    VIDEO_COMP_ALGO_COLOR_RANGE_EXT                  = 1,  // Limited range of (16-235) for xxx_COLOR_RANGE component, equivalent to Microsoft's DXVADDI_NOMINALRANGE::DXVADDI_NominalRange_16_235
    VIDEO_COMP_ALGO_PLAYBACK_PROFILE_NONE            = 0,  // Use no playback profile
    VIDEO_COMP_ALGO_PLAYBACK_PROFILE_ADOBE_FLASH_9   = 1,  // Use the internet video enhancement postprocessing for Adobe Flash 9 
    VIDEO_COMP_ALGO_DEINTERLACE_BOB                  = 0,  // Perform Bob deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_WEAVE                = 1,  // Use weave deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_SIMPLE_ADAPTIVE      = 2,  // Perform a simple motion adaptive deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_GRADIENT_SIMPLE      = 3,  // Use a simple gradient deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_GRADIENT_FULL        = 4,  // Use advanced gradient deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_ADAPTIVE_FOUR_FIELD  = 5,  // Perform four field motion adaptive deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_DIR_SPATIAL          = 6,  // User directional spatial deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_ADVANCED             = 7,  // Perform proprietary advanced deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_GPU_CAPABLE          = 8,  // Best available but GPU dependent. (video driver decides dynamically)
    VIDEO_COMP_ALGO_DEINTERLACE_CUSTOM_00            = VIDEO_COMP_ALGO_CUSTOM_BASE+0,    // Use custom Deinterlacing algorithm
    VIDEO_COMP_ALGO_DEINTERLACE_CUSTOM_01            = VIDEO_COMP_ALGO_CUSTOM_BASE+1,    // Use custom Deinterlacing algorithm
    VIDEO_COMP_ALGO_SCALING_ALG_SIMPLE               = 0,  // Do scaling using a simple algorithm
    VIDEO_COMP_ALGO_SCALING_ALG_4x4FILTER            = 1,  // Perform scaling using a 4x4 filter
    VIDEO_COMP_ALGO_SCALING_ALG_8x8FILTER            = 2,  // Perform scaling using a 8x8 filter
    VIDEO_COMP_ALGO_SCALING_ALG_CUSTOM_00            = VIDEO_COMP_ALGO_CUSTOM_BASE+0,    // Use custom scaling component
    VIDEO_COMP_ALGO_SCALING_ALG_CUSTOM_01            = VIDEO_COMP_ALGO_CUSTOM_BASE+1,    // Use custom scaling component
    VIDEO_COMP_ALGO_CADENCE_NONE                     = 0,  // Turn cadence OFF
    VIDEO_COMP_ALGO_CADENCE_SIMPLE                   = 1,  // Use simple cadence detection
    VIDEO_COMP_ALGO_CADENCE_VOF                      = 2,  // Use video on film cadence detection
    VIDEO_COMP_ALGO_CADENCE_COMPUTE                  = 3,  // Use compute cadence detection
    VIDEO_COMP_ALGO_CADENCE_GPU_CAPABLE              = 4,  // Best available but GPU dependent. (video driver decides dynamically)
    VIDEO_COMP_ALGO_NOISE_REDUCE_PUREVIDEO           = 0,  // Use PureVideo noise reduction
    VIDEO_COMP_ALGO_NOISE_REDUCE_CUSTOM_00           = VIDEO_COMP_ALGO_CUSTOM_BASE+0,  // Use custom noise reduction
    VIDEO_COMP_ALGO_NOISE_REDUCE_CUSTOM_01           = VIDEO_COMP_ALGO_CUSTOM_BASE+1,  // Use custom noise reduction
    VIDEO_COMP_ALGO_EDGE_ENHANCE_PUREVIDEO           = 0,  // Use PureVideo Sharpening Filter
    VIDEO_COMP_ALGO_EDGE_ENHANCE_CUSTOM_00           = VIDEO_COMP_ALGO_CUSTOM_BASE+0,  // Use custom Sharpening Filter
    VIDEO_COMP_ALGO_EDGE_ENHANCE_CUSTOM_01           = VIDEO_COMP_ALGO_CUSTOM_BASE+1,  // Use custom Sharpening Filter
    VIDEO_COMP_ALGO_OVERDRIVE_SIMPLE                 = 0,  // Use simple overdrive algorithm
    VIDEO_COMP_ALGO_SPLITSCREEN_TYPE_NORMAL          = 0,  // Set the splitscreen in normal mode
    VIDEO_COMP_ALGO_SPLITSCREEN_TYPE_REPEATED        = 1,  // Set the splitscreen to be repeated
    VIDEO_COMP_ALGO_SPLITSCREEN_TYPE_ON_MIRROR       = 2,  // Set the splitscreen as a mirror
    VIDEO_COMP_ALGO_DYNAMIC_CONTRAST_PRESET_NONE     = 0,  // Use the value setting for dynamic contrast instead of a preset
    VIDEO_COMP_ALGO_DYNAMIC_CONTRAST_PRESET_LOW      = 1,  // Turn the dynamic contrast to a low setting
    VIDEO_COMP_ALGO_DYNAMIC_CONTRAST_PRESET_MEDIUM   = 2,  // Turn the dynamic contrast to a medium setting
    VIDEO_COMP_ALGO_DYNAMIC_CONTRAST_PRESET_HIGH     = 3,  // Turn the dynamic contrast to a high setting
    VIDEO_COMP_ALGO_GREEN_STRETCH_PRESET_NONE        = 0,  // Use the value setting for green stretch instead of a preset
    VIDEO_COMP_ALGO_GREEN_STRETCH_PRESET_LOW         = 1,  // Set the green strech to a low setting
    VIDEO_COMP_ALGO_GREEN_STRETCH_PRESET_MEDIUM      = 2,  // Set the green strech to a medium setting
    VIDEO_COMP_ALGO_GREEN_STRETCH_PRESET_HIGH        = 3,  // Set the green strech to a high setting
    VIDEO_COMP_ALGO_BLUE_STRETCH_PRESET_NONE         = 0,  // Use the value setting for blue stretch instead of a preset
    VIDEO_COMP_ALGO_BLUE_STRETCH_PRESET_LOW          = 1,  // Set the blue strech to a low setting
    VIDEO_COMP_ALGO_BLUE_STRETCH_PRESET_MEDIUM       = 2,  // Set the blue strech to a medium setting
    VIDEO_COMP_ALGO_BLUE_STRETCH_PRESET_HIGH         = 3,  // Set the blue strech to a high setting
    VIDEO_COMP_ALGO_SKIN_TONE_CORRECTION_PRESET_NONE = 0,  // Use the value setting for skin tone correction instead of a preset
    VIDEO_COMP_ALGO_SKIN_TONE_CORRECTION_PRESET_SQUEEZE = 1,  // Turn the skin tone correction to a low setting
    VIDEO_COMP_ALGO_SKIN_TONE_CORRECTION_PRESET_RED     = 2,  // Turn the skin tone correction to a medium setting
    VIDEO_COMP_ALGO_SKIN_TONE_CORRECTION_PRESET_YELLOW  = 3,  // Turn the skin tone correction to a high setting
    VIDEO_COMP_ALGO_GAMUT_REMAPPING_CUSTOM_00        = VIDEO_COMP_ALGO_CUSTOM_BASE+0, // Use custom 3x3 gamut remapping matrix
    VIDEO_COMP_ALGO_GAMUT_REMAPPING_CUSTOM_01        = VIDEO_COMP_ALGO_CUSTOM_BASE+1, // Use custom 3x3 gamut remapping matrix
} NVAPI_VIDEO_COMPONENT_ALGORITHM;

// bitmasks for video components' enable at various resolutions
typedef enum _NVAPI_VIDEO_COMPONENT_ENABLE
{
    VIDEO_COMP_ENA_480i     = 0x00000001, // component is enabled at 480i video resolution
    VIDEO_COMP_ENA_480p     = 0x00000002, // component is enabled at 480p video resolution
    VIDEO_COMP_ENA_576i     = 0x00000004, // component is enabled at 576i video resolution
    VIDEO_COMP_ENA_576p     = 0x00000008, // component is enabled at 576p video resolution
    VIDEO_COMP_ENA_720p     = 0x00000010, // component is enabled at 720p video resolution
    VIDEO_COMP_ENA_1080i    = 0x00000020, // component is enabled at 1080i video resolution
    VIDEO_COMP_ENA_1080p    = 0x00000040, // component is enabled at 1080p video resolution
} NVAPI_VIDEO_COMPONENT_ENABLE;

// Packet that facilitates retrieving information about a video component
typedef struct _NVAPI_GET_VIDEO_STATE_COMPONENT
{
    NvU32   version;                    // (IN)  NVAPI version that matches NVAPI_GET_VIDEO_STATE_COMPONENT_VER
    NvU32   componentID;                // (IN)  identify the individual component, one of NVAPI_VIDEO_STATE_COMPONENT_xxx enums
    NvU32   bIsSupported        : 1;    // (OUT) set if this component feature is supported
    NvU32   bIsOverridenByUser  : 1;    // (OUT) set if component is overriden by user's choice
    NvU32   reserved1           : 30;   // (OUT) reserved for future expansion
    NvU32   isEnabled;                  // (OUT) set if component is enabled, one or more of NVAPI_VIDEO_COMPONENT_ENABLE bitmasks
    NvU32   minValue;                   // (OUT) min valid value
    NvU32   maxValue;                   // (OUT) max valid value
    NvU32   totalSteps;                 // (OUT) number of steps between min and max
    NvU32   defaultValue;               // (OUT) pre-defined NVIDIA default
    NvU32   unityValue;                 // (OUT) unity is the disable value for a component
    NvU32   currentValueActive;         // (OUT) value in use
    NvU64   defaultAlgo;                // (OUT) default algo, one or more of NVAPI_VIDEO_COMPONENT_ALGORITHM enums
    NvU64   currentAlgoActive;          // (OUT) algo in use, one or more of NVAPI_VIDEO_COMPONENT_ALGORITHM enums
    union
    {
        NvU64 qwReserved[9];
        struct
        {
            NvU32   dwAppKey;           // (IN) Secret key to authenticate the caller, ONLY used in NvAPI_SetVideoState
            NvU32   bTopPriority   : 1; // (OUT)indicates that these settings have precedence over D3D NvAPI settings, ONLY valid in NvAPI_GetVideoState
            NvU32   bHasCustomAlgo : 1; // (OUT)indicates whether Out-of-process app has custom algorithm data
            NvU32   bReserved      : 30;// (OUT) reserved for expansion
            struct
            {
                NvU64   pData;          // (IN) Buffer to hold the retreived custom algo data
                NvU32   dwSize;         // (IN) Size in Bytes of the above buffer, must be <= NVAPI_VIDEO_STATE_MAX_CUSTOM_ALGO_SIZE.
            } customAlgo;
        } appInfo;
    };
} NVAPI_GET_VIDEO_STATE_COMPONENT;

#define NVAPI_GET_VIDEO_STATE_COMPONENT_VER  MAKE_NVAPI_VERSION(NVAPI_GET_VIDEO_STATE_COMPONENT,1)

// Return status after attempting to set a video component
typedef enum _NVAPI_VIDEO_COMP_RETURN_STATUS
{
    VIDEO_COMP_STATUS_SUCCESS                   = 0x00000000, // Video component is set successfully
    VIDEO_COMP_STATUS_UNSUCCESSFUL              = 0x00000001, // Failed to set video component
    VIDEO_COMP_STATUS_COMPONENT_NOT_SUPPORTED   = 0x00000002, // Video component is not supported
    VIDEO_COMP_STATUS_VALUE_OUT_OF_RANGE        = 0x00000004, // Video component's value is invalid and does not fall into range
    VIDEO_COMP_STATUS_ALGO_NOT_RECOGNIZED       = 0x00000008, // Video component's algorithm is invalid
    VIDEO_COMP_STATUS_OVERRIDDEN_BY_USER        = 0x00000010, // Request not completed because of user-mandated override
    VIDEO_COMP_STATUS_Y_GAMMA_ENABLED           = 0x00000020, // Cannot set RGB-gamma because Y-Gamma is already enabled
    VIDEO_COMP_STATUS_RGB_GAMMA_ENABLED         = 0x00000040, // Cannot set Y-gamma because RGB-Gamma is already enabled
} NVAPI_VIDEO_COMP_RETURN_STATUS;

// Packet containing information to allow setting the video component

#define NVAPI_VIDEO_STATE_MAX_CUSTOM_ALGO_SIZE 128

typedef struct _NVAPI_SET_VIDEO_STATE_COMPONENT
{
    NvU32   version;                        // (IN) NVAPI version that matches NVAPI_SET_VIDEO_STATE_COMPONENT_VER
    NvU32   componentID;                    // (IN) identify the individual component, one of NVAPI_VIDEO_STATE_COMPONENT_xxx enums
    NvU32   enable;                         // (IN) flag to enable setting of component, one or more of NVAPI_VIDEO_COMPONENT_ENABLE bitmasks
    NvU32   setToValue;                     // (IN) value to use
    NvU64   setToAlgo;                      // (IN) algorithm to use
    NvU32   retStatus;                      // (OUT) result of video-component-set operation; a combination of VIDEO_COMP_STATUS_xxx bitmasks
    NvU32   reserved;
    union
    {
        NvU64 qwReserved[4];
        struct
        {
            NvU32   dwAppKey;               // (IN) Secret key to authenticate the caller, ONLY used in NvAPI_SetVideoState
            NvU32   bTopPriority       : 1; // (IN) Force these settings to have priority over D3D NvAPI settings, ONLY valid in NvAPI_GetVideoState
            NvU32   bHasCustomAlgo     : 1; // (IN) Out-of-process app has custom algorithm data
            NvU32   bReserved          : 30;// (IN) reserved for expansion
            struct
            {
                NvU64   pData;              // (IN) (Used only when bHasCustomAlgo == 1) Pointer to the custom algo data.
                NvU32   dwSize;             // (IN) (Used only when bHasCustomAlgo == 1) Size in Bytes of the custom algo data, must be <= NVAPI_VIDEO_STATE_MAX_CUSTOM_ALGO_SIZE.
            } customAlgo;
        } appInfo;
    };
} NVAPI_SET_VIDEO_STATE_COMPONENT;

#define NVAPI_SET_VIDEO_STATE_COMPONENT_VER  MAKE_NVAPI_VERSION(NVAPI_SET_VIDEO_STATE_COMPONENT,1)

#endif // ifndef NV_VIDEO_COMPONENTS_DEFINE

NVAPI_INTERFACE NvAPI_GetVideoState(NvDisplayHandle hNvDisplay, NVAPI_GET_VIDEO_STATE_COMPONENT *pGetVidStateComp);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SetVideoState
//
// DESCRIPTION:     API that allows callers to set a particular video state component. It is the responsibility
//                  of the caller to fill the secret application key that enables authentication of the caller.
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:      hNvDisplay(IN)          - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated
//                                            from NvAPI_EnumNVidiaDisplayHandle().
//                  pSetVidStateComp(IN)    - NVAPI_SET_VIDEO_STATE_COMPONENT packet containing
//                                            a valid component ID and a valid application secret key.
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetVideoState(NvDisplayHandle hNvDisplay, NVAPI_SET_VIDEO_STATE_COMPONENT *pSetVidStateComp);

//  SUPPORTED OS: Windows XP and higher

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SetFrameRateNotify
//
// DESCRIPTION:     This API signals the driver to turn on/off the notification to
//                  the service app of the video frame rate.
//
//
// PARAMETERS:      hNvDisplay(IN)  - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated
//                                    from NvAPI_EnumNVidiaDisplayHandle().
//                  pFRNotifyInfo(IN) - Pointer to the supplied NVAPI_FRAME_RATE_NOTIFY_INFO struct.
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////
typedef struct _NVAPI_FRAME_RATE_NOTIFY_INFO
{
    NvU32   version;                // (IN) version for this NVAPI struct
    NvU64   hWnd;                   // (IN) the window handle of the service application handling the RR adjust
    NvU32   bEnable         : 1;    // (IN) To turn feature ON/OFF
    NvU32   bReserved       : 31;   // (IN/OUT) reserved for later use
} NVAPI_FRAME_RATE_NOTIFY_INFO;

#define NVAPI_FRAME_RATE_NOTIFY_INFO_VER  MAKE_NVAPI_VERSION(NVAPI_FRAME_RATE_NOTIFY_INFO,1)

NVAPI_INTERFACE NvAPI_SetFrameRateNotify(NvDisplayHandle hNvDisplay, NVAPI_FRAME_RATE_NOTIFY_INFO* pFRNotifyInfo);

//  SUPPORTED OS: Windows XP and higher

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SetPVExtName
//
// DESCRIPTION:     This API specifies the name of the PureVideo extension dll
//                  to be used when custom algorithms are enabled via 
//                  NvAPI_SetVideoState calls
//
// PARAMETERS:      hNvDisplay(IN)  - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated
//                                    from NvAPI_EnumNVidiaDisplayHandle().
//                  szDllName - name of the dll to be used for custom algorithms
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetPVExtName(NvDisplayHandle hNvDisplay, const char *szDllName);

//  SUPPORTED OS: Windows XP and higher

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetPVExtName
//
// DESCRIPTION:     This API retrieves the name of the PureVideo extension dll
//                  to be used when custom algorithms are enabled via 
//                  NvAPI_SetVideoState calls
//
// PARAMETERS:      hNvDisplay(IN)  - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated
//                                    from NvAPI_EnumNVidiaDisplayHandle().
//                  szDllName - name of the dll that's currently registered with the driver
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetPVExtName(NvDisplayHandle hNvDisplay, NvAPI_String szDllName);

//  SUPPORTED OS: Windows XP and higher

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SetPVExtProfile
//
// DESCRIPTION:     This API specifies the profile number that the PureVideo 
//                  extension dll should use
//
// PARAMETERS:      hNvDisplay(IN)  - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE
//                                    or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle()
//                  dwProfile(IN)   - the profile number 
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetPVExtProfile(NvDisplayHandle hNvDisplay, NvU32 dwProfile);

//  SUPPORTED OS: Windows XP and higher

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetPVExtProfile
//
// DESCRIPTION:     This API retrieves the profile number that the PureVideo 
//                  extension dll is set to use
//
// PARAMETERS:      hNvDisplay(IN)  - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE
//                                    or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle()
//                  pProfile(OUT)   - the returned profile number
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetPVExtProfile(NvDisplayHandle hNvDisplay, NvU32* pProfile);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetVideoLinkParams
//
// DESCRIPTION:     This API receives content protection information
//                  during video playback.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS:      hNvDisplay(IN)  - NVIDIA Display selection. It can be 
//                                    NVAPI_DEFAULT_HANDLE or a handle 
//                                    enumerated from 
//                                    NvAPI_EnumNVidiaDisplayHandle().
//                  outputId(IN)    - The display output id for which the
//                                    video link parameters are requested. 
//                                    If it's "0" then the default outputId from
//                                    NvAPI_GetAssociatedDisplayOutputId() 
//                                    will be used.
//                  pVideoLinkInfo(OUT)- The supplied NV_VIDEO_LINK_INFO packet. 
//
// RETURN STATUS: 
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////

typedef enum _NV_HDCP_STATUS_INFO 
{
    NV_HDCP_STATUS_INFO_AVAILABLE                           = 0x00000000, // Link (GPU + display) is HDCP-capable
    NV_HDCP_STATUS_INFO_UNAVAILABLE                         = 0x00000001, // Link not HDCP-capable
    NV_HDCP_STATUS_INFO_UNAVAILABLE_INVALID_DISPLAY_ID      = 0x00000002, // DisplayId does not match a digital (DVI/HDMI) connector
    NV_HDCP_STATUS_INFO_UNAVAILABLE_INVALID_DISPLAY         = 0x00000004, // Display is not HDCP-capable as reported by RM (may be independent of _INVALID_DISPLAY_ID)
    NV_HDCP_STATUS_INFO_UNAVAILABLE_INVALID_DISPLAY_MODE    = 0x00000008, // In clone/span mode
    NV_HDCP_STATUS_INFO_UNAVAILABLE_INVALID_GPU             = 0x00000010, // GPU is not HDCP-capable as reported by RM
    NV_HDCP_STATUS_INFO_UNAVAILABLE_INVALID_GPU_MODE        = 0x00000020, // *NOT SUPPORTED, please remove option from CPL* 
    NV_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_UNTRUST           = 0x00000040, // Status signature did not match
    NV_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_LINK_FAILURES     = 0x00000080, // Abort due to repeated link failures
    NV_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_KSV_LENGTH        = 0x00000100, // Invalid key parameter passed by app
    NV_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_KSV_SIGNATURE     = 0x00000200, // Invalid key signature passed by app
    NV_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_SRM_SIGNATURE     = 0x00000400, // The player app looks suspicious
    NV_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_SRM_REVOKED       = 0x00000800, // Bad display due to revocation to carry HDCP content
    NV_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_REPEATER_NO_READY = 0x00001000, // Repeater not ready
    NV_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_TOPOLOGY_ERROR    = 0x00002000, // Invalid topology for display devices' configuration
    NV_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_BAD_DISPLAY       = 0x00004000, // Invalid BKSV from display device    
    // additional HDCP-related codes
} NV_HDCP_STATUS_INFO;

typedef struct _NV_HDCP_LINK_STATUS
{
    NV_HDCP_STATUS_INFO     nvHdcpStatusInfo;           // One or more HDCP-related status codes         
    NvU64                   bRepeaterPresent    : 1;    // Has a repeater
    NvU64                   bDebuggerDetected   : 1;    // Debugger is present
    NvU64                   bHDCPOn             : 1;    // HDCP encryption is ON
    NvU64                   bReserved1          : 61;
    NvU64                   qwReserved2;
} NV_HDCP_LINK_STATUS;

typedef struct _NV_MACROVISION_STATUS
{
    NvU64   bMacrovisionOn      : 1; // Macrovision protection is ON
    NvU64   bReserved1          : 63;
    NvU64   qwReserved2;
} NV_MACROVISION_STATUS;

typedef struct _NV_VIDEO_LINK_INFO
{
    NvU32                   version;
    NV_HDCP_LINK_STATUS     hdcpStatus;         // (OUT)
    NV_MACROVISION_STATUS   macrovisionStatus;  // (OUT)
} NV_VIDEO_LINK_INFO;

#define NV_VIDEO_LINK_INFO_VER  MAKE_NVAPI_VERSION(NV_VIDEO_LINK_INFO,1)

NVAPI_INTERFACE NvAPI_GetVideoLinkParams(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_VIDEO_LINK_INFO* pVideoLinkInfo);


///////////////////////////////////////////////////////////////////////////////
// Structs and enums related to Video Ctrl
///////////////////////////////////////////////////////////////////////////////

typedef enum _NVAPI_VIDEO_CTRL_REQUEST
{
    NVAPI_VCTL_REQ_NONE                     = 0x00000000,
    NVAPI_VCTL_REQ_DI_BOB                   = 0x00000001, // use bob
    NVAPI_VCTL_REQ_DI_MEDIAN                = 0x00000002, // use fweave (not on nv4x)
    NVAPI_VCTL_REQ_DI_WEAVE                 = 0x00000004, // use weave
    NVAPI_VCTL_REQ_DI_ADAPTIVE              = 0x00000008, // use adaptive (not on nv1x) (note - this is default for most nv3x, all nv4x)
    NVAPI_VCTL_REQ_DI_EDGE_FULL             = 0x00000010, // use full edge with adaptive (nv4x only)
    NVAPI_VCTL_REQ_DI_EDGE_SIMPLE           = 0x00000020, // use simple edge with adaptive (nv4x only)
    NVAPI_VCTL_REQ_GAMMA_DISABLE            = 0x00000040, // disable gamma
    NVAPI_VCTL_REQ_709EXT_ENABLE            = 0x00000080, // enable 709 ext shader
    NVAPI_VCTL_REQ_709EXT_DISABLE           = 0x00000100, // disable 709 ext shader
    NVAPI_VCTL_REQ_601EXT_DISABLE           = 0x00000200, // disable 601 ext
    NVAPI_VCTL_REQ_OVERDRIVE_DISABLE        = 0x00000400, // disable overdrive
    NVAPI_VCTL_REQ_COLORTEMP_DISABLE        = 0x00000800, // disable color temp adjustment
    NVAPI_VCTL_REQ_INV32_DISABLE            = 0x00001000, // disable inv32
    NVAPI_VCTL_REQ_VP_DISABLE               = 0x00002000, // disable vp
    NVAPI_VCTL_REQ_DI_GRADIENT_FULL         = 0x00004000, // use full gradient with adaptive (nv4x only)
    NVAPI_VCTL_REQ_DI_GRADIENT_SIMPLE       = 0x00008000, // use simple gradient with adaptive (nv4x only)
    NVAPI_VCTL_REQ_INV22_DISABLE            = 0x00010000, // disable inv22
    NVAPI_VCTL_REQ_DI_SIMPLE_ADAPTIVE       = 0x00020000, // use simple adaptive
    NVAPI_VCTL_REQ_NO_PROCESSING            = 0x00040000, // no vid quality processing
    NVAPI_VCTL_REQ_DI_ONLY                  = 0x00080000, // no vid quality processing other than DI
    NVAPI_VCTL_REQ_NR_ONLY                  = 0x00100000, // no vid quality processing other than NR
    NVAPI_VCTL_REQ_EE_ONLY                  = 0x00200000, // no vid quality processing other than EE
    NVAPI_VCTL_REQ_CADENCE_ONLY             = 0x00400000, // no vid quality processing other than CADENCE
    NVAPI_VCTL_REQ_XFER_XTRA_SAME           = 0x00800000, // on video blit to csc, first xfer to same fmt
    NVAPI_VCTL_REQ_XFER_XTRA_NV12           = 0x01000000, // on video blit to csc, first xfer to nv12
    NVAPI_VCTL_REQ_XFER_XTRA_YUY2           = 0x02000000, // on video blit to csc, first xfer to yuy2
    NVAPI_VCTL_REQ_XFER_XTRA_SCALE          = 0x04000000, // on video blit to csc, first xfer to scaled to 1.5 OR specified width/height
    NVAPI_VCTL_REQ_DI_ADVANCED              = 0x08000000, // Advanced Deinterlace
    NVAPI_VCTL_REQ_DI_DIR_SPATIAL           = 0x10000000, // Advanced Dir Spatial enable/disable spatial dir interp
    NVAPI_VCTL_REQ_DI_CADENCE               = 0x20000000, // Advanced Cadence enable disable
    NVAPI_VCTL_REQ_DI_VOF                   = 0x40000000, // VOF enable/disable
    NVAPI_VCTL_REQ_XFER_XTRA_ARGB           = 0x80000000, // on video blit to csc, first xfer to argb
} NVAPI_VIDEO_CTRL_REQUEST;

typedef enum _NVAPI_VIDEO_CTRL_REQUEST2
{
    NVAPI_VCTL2_REQ_10BITOVERLAY_ENABLE        = 0x00000001, //enable 10 bit overlay
    NVAPI_VCTL2_REQ_VP2_SCALING_ENABLE         = 0x00000002, //enable vp2 scaling
    NVAPI_VCTL2_REQ_VP2_SCALING_DISABLE        = 0x00000004, //disable vp2 scaling
    NVAPI_VCTL2_REQ_CAPTURE_UNIQUE_FRAME       = 0x00000008, //disable vp2 scaling
} NVAPI_VIDEO_CTRL_REQUEST2;
// video caps
typedef enum _NVAPI_VIDEO_CTRL_CAPS_FLAG
{
    NVAPI_VIDEO_CTRL_CAPS_NONE                     = 0x00000000,
    NVAPI_VIDEO_CTRL_CAPS_MEDIAN_DI                = 0x00000001, // supports median
    NVAPI_VIDEO_CTRL_CAPS_SPAD_DI                  = 0x00000002, // supports spad
    NVAPI_VIDEO_CTRL_CAPS_ADV_DI                   = 0x00000004, // supports adv and edge
    NVAPI_VIDEO_CTRL_CAPS_GAMMA                    = 0x00000008, // supports gamma
    NVAPI_VIDEO_CTRL_CAPS_709EXT                   = 0x00000010, // supports 709ext
    NVAPI_VIDEO_CTRL_CAPS_OVERDRIVE                = 0x00000020, // supports overdrive
    NVAPI_VIDEO_CTRL_CAPS_COLORTEMP                = 0x00000040, // supports colortemp
    NVAPI_VIDEO_CTRL_CAPS_INVAPI32                 = 0x00000080, // supports iNVAPI32
    NVAPI_VIDEO_CTRL_CAPS_VP                       = 0x00000100, // supports VP
    NVAPI_VIDEO_CTRL_CAPS_INVAPI22                 = 0x00000200, // supports iNVAPI22
    NVAPI_VIDEO_CTRL_CAPS_XFER_XTRA                = 0x00000400, // supports xfer xtra requests
    NVAPI_VIDEO_CTRL_CAPS_NVAPI24                  = 0x00000800, // supports NVAPI24
} NVAPI_VIDEO_CTRL_CAPS_FLAG;
// IDs related to video Ctrl
typedef enum _NVAPI_VIDEO_CTRL_ID
{
    NVAPI_VIDEO_CTRL_ID_NONE     = -1,   // Placeholder for invalid ctrl ID
    NVAPI_VIDEO_CTRL_ID_REQ1         ,   // Veracity requests
    NVAPI_VIDEO_CTRL_ID_REQ2         ,   // Veracity requests
    NVAPI_VIDEO_CTRL_ID_CAPTURE      ,   // For veracity video capture info
    NVAPI_VIDEO_CTRL_ID_PERF         ,   // For veracity perf test
    NVAPI_VIDEO_CTRL_ID_LAST         ,   // All valid ctrls defined before this one
} NVAPI_VIDEO_CTRL_ID;

typedef enum _NVAPI_VIDEO_CTRL_FLAG
{
    NVAPI_VIDEO_CTRL_FLAG_SET            = 1, // 1 : Set Ctrl
    NVAPI_VIDEO_CTRL_FLAG_GET               , // 2 : Get Ctrl
    NVAPI_VIDEO_CTRL_FLAG_RESET             , // 3 : Reset Ctrl
} NVAPI_VIDEO_CTRL_FLAG;

// enums related to Video Capture

typedef enum _NVAPI_VIDEO_CAPTURE_FLAG
{
    NVAPI_VIDEO_CAPTURE_STOP             = 0x00000001,
    NVAPI_VIDEO_CAPTURE_SOURCE_ALSO      = 0x00000002,
    NVAPI_VIDEO_CAPTURE_ALLFRAMES        = 0x00000004,
    NVAPI_VIDEO_CAPTURE_NEWBUFFER        = 0x00000008,
} NVAPI_VIDEO_CAPTURE_FLAG;
typedef enum _NVAPI_VIDEO_CAPTURE_POINT
{
    NVAPI_VIDEO_CAPTURE_POINT_NONE                     = 0,
    NVAPI_VIDEO_CAPTURE_POINT_OVERLAY_FLIP             = 1,
    NVAPI_VIDEO_CAPTURE_POINT_VIDEO_BLIT               = 2,
    NVAPI_VIDEO_CAPTURE_POINT_DELETED_RENDER_MPEG      = 3,
    NVAPI_VIDEO_CAPTURE_POINT_DELETED_RENDER_WMV9      = 4,
    NVAPI_VIDEO_CAPTURE_POINT_PROCAMP_OUTPUT           = 5,
    NVAPI_VIDEO_CAPTURE_POINT_DI_OUTPUT                = 6,
    NVAPI_VIDEO_CAPTURE_POINT_DELETED_SUBPIC_OUTPUT    = 7,
    NVAPI_VIDEO_CAPTURE_POINT_CSC_OUTPUT               = 8,
    NVAPI_VIDEO_CAPTURE_POINT_DELETED_INV32_OUTPUT     = 9,
    NVAPI_VIDEO_CAPTURE_POINT_UNLOCK                   = 10,
    NVAPI_VIDEO_CAPTURE_POINT_DELETED_00               = 11,
    NVAPI_VIDEO_CAPTURE_POINT_MOCOMP_END_FRAME         = 12,
    NVAPI_VIDEO_CAPTURE_POINT_DELETED_MOCOMP_H264      = 13,
    NVAPI_VIDEO_CAPTURE_POINT_MIRROR                   = 14,
    NVAPI_VIDEO_CAPTURE_POINT_BLIT32_DST               = 15,
    NVAPI_VIDEO_CAPTURE_POINT_FE_SP_BLEND              = 16,
    NVAPI_VIDEO_CAPTURE_POINT_BE_SP_BLEND              = 17,
    NVAPI_VIDEO_CAPTURE_POINT_VP_OUTPUT                = 18,
    NVAPI_VIDEO_CAPTURE_POINT_DELETED_MOCOMP_VC1       = 19,
    NVAPI_VIDEO_CAPTURE_POINT_YUV_OUT                  = 20,
    NVAPI_VIDEO_CAPTURE_POINT_NR_OUTPUT                = 21,
    NVAPI_VIDEO_CAPTURE_POINT_ADI_OUTPUT               = 22,
    NVAPI_VIDEO_CAPTURE_POINT_MSDEC_OUTPUT             = 23,
} NVAPI_VIDEO_CAPTURE_POINT;

// Packet that facilitates retrieving information about a video ctrl
typedef struct _NVAPI_VIDEO_CTRL_V1
{
    NvU32   version;                    // (IN) NVAPI version that matches NVAPI_VIDEO_CTRL_VER
    NvU32   ctrlID;                     // (IN) identify the individual ctrl, one of NVAPI_VIDEO_CTRL_xxx enums
    NvU32   ctrlFlag;                   // (IN) Set/Get/Reset NVAPI_VIDEO_CTRL_FLAG_XXXX enums
    NvU32   retStatus;                  // (OUT) Return Status
    union                               // (IN/OUT) parameters
    {
        NvU32   parm[8];
        NvU32   diagCtrlReq1;
        NvU32   diagCtrlReq2;
    } u;
    NvU64   reserved3[10];              // (OUT) reserved for future expansion
} NVAPI_VIDEO_CTRL_V1;

typedef struct _NVAPI_VIDEO_CTRL_V2
{
    NvU32   version;                    // (IN) NVAPI version that matches NVAPI_VIDEO_CTRL_VER
    NvU32   ctrlID;                     // (IN) identify the individual ctrl, one of NVAPI_VIDEO_CTRL_xxx enums
    NvU32   ctrlFlag;                   // (IN) Set/Get/Reset NVAPI_VIDEO_CTRL_FLAG_XXXX enums
    NvU32   retStatus;                  // (OUT) Return Status
    NvU32   bResetDiagCtrlInfo : 1;     // reset driverdata variables based on it
    NvU32   bReserved : 31;             // reserved for future expansion
    union                               // (IN/OUT) parameters
    {
        NvU32   parm[8];
        struct 
        {
            NvU32   diagCtrlReq1;
            NvU32   diagCtrlReq2;
        } diagCtrlRequest;
        struct
        {
            NvU32 captureBufferAdd;         // (IN/OUT)address of the veracity capture buffer
            NvU32 captureFlags;
            NvU32 captureBufferSize;        // (IN/OUT)size of the buffer
            NvU32 capturePoint;             // (IN/OUT)where frame capture takes place
            NvU32 captureFrameIndex;        // (IN/OUT)number of the frame to capture
            NvU32 captureFrameRange : 16;   // (IN/OUT)the range of frames to capture
            NvU32 reserved2 : 16;           // reserved for future expansion
        } captureInfo;
        struct
        {
            NvU32 startFrameIdx;            // (IN)  frame index for starting perf 
            NvU32 endFrameIdx;              // (IN)  frame index for ending perf 
            NvU32 bEnablePerf : 1;          // (IN)  perf test is enabled 
            NvU32 reserved2 : 31;           // reserved for future expansion
        } perftestInfo;
    } u;

    struct
    {
        NvU32            dwVideoControlDiagInfoBits;
        NvU32            dwVideoControlDiagInfo2Bits;
        NvU32            dwVideoControlDiagCapsBits;
    } diagVideoControlInfo;             // (IN/OUT)storage for pDriverdata->nvVideoControlDiagInfo
    struct
    {
        NvU32            dwTargetWidth;
        NvU32            dwTargetHeight;
    } diagVideoControlParm;             // (IN/OUT)storage for pDriverdata->nvVideoControlDiagParm
    NvU64   reserved3[7];               // (OUT) reserved for future expansion
} NVAPI_VIDEO_CTRL_V2;

typedef NVAPI_VIDEO_CTRL_V2 NVAPI_VIDEO_CTRL;

#define NVAPI_VIDEO_CTRL_VER1  MAKE_NVAPI_VERSION(NVAPI_VIDEO_CTRL_V1,1)
#define NVAPI_VIDEO_CTRL_VER2  MAKE_NVAPI_VERSION(NVAPI_VIDEO_CTRL_V2,2)
#define NVAPI_VIDEO_CTRL_VER   NVAPI_VIDEO_CTRL_VER2
// Return status after attempting to set a video ctrl
typedef enum _NVAPI_VIDEO_CTRL_RETURN_STATUS
{
    NVAPI_VIDEO_CTRL_STATUS_SUCCESS                        = 0x00000000, // Video ctrl is set successfully
    NVAPI_VIDEO_CTRL_STATUS_UNSUCCESSFUL                   = 0x00000001, //
    NVAPI_VIDEO_CTRL_STATUS_CTRL_NOT_SUPPORTED             = 0x00000002, // Invalid Ctrl
    NVAPI_VIDEO_CTRL_STATUS_CTRL_FLAG_INVALID              = 0x00000003, // Invalid Flag.
    NVAPI_VIDEO_CTRL_STATUS_CTRL_FIELD_NOT_SUPPORTED       = 0x00000004, // Unsupported Field in Ctrl.
    NVAPI_VIDEO_CTRL_STATUS_CAPTURE_PENDING                = 0x00000005, // capture not done
} NVAPI_VIDEO_CTRL_RETURN_STATUS;

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_VideoCtrl
//
// DESCRIPTION:     API that allows callers to tweak a particular video Ctrl.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS:      hNvDisplay(IN)          - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated
//                                            from NvAPI_EnumNVidiaDisplayHandle().
//                  pVideoCtrl(IN)          - NVAPI_VIDEO_CTRL packet containing a valid ctrl ID (NVAPI_VIDEO_CTRL_ID) and flag
//                                            (NVAPI_VIDEO_CTRL_FLAG) for GET/RESET/SET video ctrl information.
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_VideoCtrl(NvDisplayHandle hNvDisplay, NVAPI_VIDEO_CTRL *pVideoCtrl);


// enums and structs related to video control points
#define NVAPI_MAX_CONTROL_POINT_DATA_SIZE_IN_BYTES  0x100
#define NVAPI_MAX_CONTROL_POINTS_PER_PACKET  20

typedef enum _NVAPI_VIDEO_CONTROL_RETURN_STATUS
{
    NVAPI_VIDEO_CONTROL_STATUS_SUCCESS = 0,
    NVAPI_VIDEO_CONTROL_STATUS_UNSUCCESSFUL,
    NVAPI_VIDEO_CONTROL_STATUS_COMPONENT_NOT_SUPPORTED,
    NVAPI_VIDEO_CONTROL_STATUS_VALUE_OUT_OF_RANGE,
    NVAPI_VIDEO_CONTROL_STATUS_DATA_TYPE_MISMATCH,
    NVAPI_VIDEO_CONTROL_STATUS_FLAG_INVALID,
    NVAPI_VIDEO_CONTROL_STATUS_UNREGISTERED,
    NVAPI_VIDEO_CONTROL_STATUS_INVALID_ARGUMENT,
    NVAPI_VIDEO_CONTROL_STATUS_INVALID_ID,
    NVAPI_VIDEO_CONTROL_STATUS_INVALID_DATA_SIZE,
    NVAPI_VIDEO_CONTROL_STATUS_DISABLED,
} NVAPI_VIDEO_CONTROL_RETURN_STATUS;

// video control points, update the nvVidCtrlPointNames[] array in nvdisp.cpp as well when adding a new ID.
typedef enum _NVAPI_VIDEO_CONTROL_POINT_ID
{
    NVAPI_CPID_FIRST = -1,

    NVAPI_CPID_NoiseReductionStrength,
    NVAPI_CPID_EdgeEnhancementStrength,
    NVAPI_CPID_BrightnessValue,
    NVAPI_CPID_ContrastValue,
    NVAPI_CPID_HueValue,
    NVAPI_CPID_SaturationValue,
    NVAPI_CPID_GammaValueR,
    NVAPI_CPID_GammaValueG,
    NVAPI_CPID_GammaValueB,
    NVAPI_CPID_DeInterlacingAlgo,
    NVAPI_CPID_CadenceDetectionAlgo,
    NVAPI_CPID_SubPictureBlendingMode,
    NVAPI_CPID_ColorSpace,
    NVAPI_CPID_ColorRange,
    NVAPI_CPID_DynamicContrastEnhancement,
    NVAPI_CPID_Scaling,
    NVAPI_CPID_GamutRemap,
    NVAPI_CPID_SkinToneCorrection,
    
    // append here 

    NVAPI_CPID_LAST, // must be last
} NVAPI_VIDEO_CONTROL_POINT_ID;

// update the nvVidCtrlPointDataTypes[] array in nvdisp.cpp as well when adding a new Datatype.
typedef enum _NVAPI_VIDEO_CONTROL_POINT_DATATYPE
{
    NVAPI_CPDT_UNKNOWN = 0,
    NVAPI_CPDT_Integer,
    NVAPI_CPDT_Float,
    NVAPI_CPDT_String,
    NVAPI_CPDT_Binary,
    NVAPI_CPDT_LAST,
} NVAPI_VIDEO_CONTROL_POINT_DATATYPE;

// update the nvVidCtrlPointGranularity[] array in nvdisp.cpp as well when adding a new Granularity type.
typedef enum _NVAPI_CONTROL_POINT_GRANULARITY
{
    NVAPI_CPG_UNKNOWN = 0,
    NVAPI_CPG_InitTime,
    NVAPI_CPG_PerFrame,
} NVAPI_CONTROL_POINT_GRANULARITY;

typedef enum _NVAPI_VIDEO_CONTROL_GET_FLAG
{
    NVAPI_CP_FLAG_GET_UNKNOWN = 0,
    NVAPI_CP_FLAG_GET_COUNT,
    NVAPI_CP_FLAG_GET_DETAILS,
} NVAPI_VIDEO_CONTROL_GET_FLAG;

typedef enum _NVAPI_VIDEO_CONTROL_COMPONENT_ALGORITHM
{
    // Color space formats
    NV_VCTRL_ColorSpaceBase            = 0x1000,
    NV_VCTRL_ColorSpace601             = (NV_VCTRL_ColorSpaceBase) + 0x01,  // ITU-R BT.601
    NV_VCTRL_ColorSpace709             = (NV_VCTRL_ColorSpaceBase) + 0x02,  // ITU-R BT.709
    NV_VCTRL_ColorSpaceLast            = (NV_VCTRL_ColorSpaceBase) + 0x03,

    // Color range formats
    NV_VCTRL_ColorRangeBase            = 0x1100,
    NV_VCTRL_ColorRangeStd             = (NV_VCTRL_ColorRangeBase) + 0x01,  // color range of (0-255)
    NV_VCTRL_ColorRangeExt             = (NV_VCTRL_ColorRangeBase) + 0x02,  // color range of (16-235)
    NV_VCTRL_ColorRangeLast            = (NV_VCTRL_ColorRangeBase) + 0x03,

    // Deinterlacing Algos 
    NV_VCTRL_DIBase                    = 0x2000,
    NV_VCTRL_DIBob                     = (NV_VCTRL_DIBase) + 0x01,  // Perform Bob deinterlacing
    NV_VCTRL_DIMedian                  = (NV_VCTRL_DIBase) + 0x02,  // Use median filter 
    NV_VCTRL_DI3x3                     = (NV_VCTRL_DIBase) + 0x03,  // Perform a 3x3 adaptive deinterlacing
    NV_VCTRL_DIAdaptiveFourField       = (NV_VCTRL_DIBase) + 0x04,  // Perform four field motion adaptive deinterlacing
    NV_VCTRL_DIDirectionalSpatial      = (NV_VCTRL_DIBase) + 0x05,  // Use directional spatial deinterlacing for SD
    NV_VCTRL_DIOnePass                 = (NV_VCTRL_DIBase) + 0x06,  // Use One Pass deinterlacing
    NV_VCTRL_DISony                    = (NV_VCTRL_DIBase) + 0x07,  // Use Sony deinterlacing Algo
    NV_VCTRL_DILast                    = (NV_VCTRL_DIBase) + 0x08,

    // Cadence detection Algos 
    NV_VCTRL_CadenceBase               = 0x3000,
    NV_VCTRL_CadenceBasic              = (NV_VCTRL_CadenceBase) + 0x01,  // Basic cadence detection Algo
    NV_VCTRL_CadenceVideoOnFilm        = (NV_VCTRL_CadenceBase) + 0x02,  // Use video on film cadence detection
    NV_VCTRL_CadenceAdv                = (NV_VCTRL_CadenceBase) + 0x03,  // Advanced cadence detection Algo
    NV_VCTRL_CadenceLast               = (NV_VCTRL_CadenceBase) + 0x04,
    
    // Dynamic Contrast Color Enhancement Algos
    NV_VCTRL_DCCEBase                  = 0x4000,
    NV_VCTRL_DCCELow                   = (NV_VCTRL_DCCEBase) + 0x01,    // DCCE Low
    NV_VCTRL_DCCEMedium                = (NV_VCTRL_DCCEBase) + 0x02,    // DCCE Medium
    NV_VCTRL_DCCEHigh                  = (NV_VCTRL_DCCEBase) + 0x03,    // DCCE High
    NV_VCTRL_DCCELast                  = (NV_VCTRL_DCCEBase) + 0x04,
    
    // Scaling Algos
    NV_VCTRL_ScalingBase               = 0x5000,
    NV_VCTRL_ScalingSimple             = (NV_VCTRL_ScalingBase) + 0x01,  // Simple Shader Scaling
    NV_VCTRL_Scaling4x4Filter          = (NV_VCTRL_ScalingBase) + 0x02,  // Scaling by 4x4 filter
    NV_VCTRL_ScalingSony               = (NV_VCTRL_ScalingBase) + 0x03,  // Sony Scaling Algo          
    NV_VCTRL_ScalingLast               = (NV_VCTRL_ScalingBase) + 0x04,

    // Gamut Remap Algos
    NV_VCTRL_GamutRemapBase            = 0x6000,
    NV_VCTRL_GamutRemapSony            = (NV_VCTRL_GamutRemapBase) + 0x01, // Sony Gamut Remap Algo
    NV_VCTRL_GamutRemapLast            = (NV_VCTRL_GamutRemapBase) + 0x02,
    
    // Skin-Tone Correction levels
    NV_VCTRL_SkinToneCorrectionBase    = 0x7000,
    NV_VCTRL_SkinToneCorrectionSqueeze = (NV_VCTRL_SkinToneCorrectionBase) + 0x01, // Turn the skin tone correction to a low setting
    NV_VCTRL_SkinToneCorrectionRed     = (NV_VCTRL_SkinToneCorrectionBase) + 0x02, // Turn the skin tone correction to a medium setting
    NV_VCTRL_SkinToneCorrectionYellow  = (NV_VCTRL_SkinToneCorrectionBase) + 0x03, // Turn the skin tone correction to a high setting 
    NV_VCTRL_SkinToneCorrectionLast    = (NV_VCTRL_SkinToneCorrectionBase) + 0x04,
    
} NVAPI_VIDEO_CONTROL_COMPONENT_ALGORITHM;

typedef struct _NVAPI_VIDEO_CONTROL_POINT_DESC
{
    NVAPI_VIDEO_CONTROL_POINT_ID        eID;
    NVAPI_VIDEO_CONTROL_POINT_DATATYPE  eType;
    NVAPI_CONTROL_POINT_GRANULARITY     eGranularity;
    NvU32                               dwDataSize;
    NvU32                               adwReserved[4];
} NVAPI_VIDEO_CONTROL_POINT_DESC;

typedef struct _NVAPI_VID_CTRL_POINT_DESC_STRINGS
{
    NVAPI_VIDEO_CONTROL_POINT_ID    eID;
    NvAPI_ShortString               szControlPoint; // ControlPoint name
    NvAPI_ShortString               szDataType;     // control point data type
    NvAPI_ShortString               szGranularity;  // control point Granularity
    NvAPI_ShortString               szReserved1;    // reserved for future expansion
} NVAPI_VID_CTRL_POINT_DESC_STRINGS;

typedef struct _NVAPI_VIDEO_CONTROL_POINT_DESC_PACKET
{
    NvU32                           version; // (IN) NVAPI version that matches NVAPI_VIDEO_CONTROL_POINT_DESC_PACKET_VER
    NvU32                           dwReturnStatus; // (OUT) one of the NVAPI_VIDEO_CONTROL_RETURN_STATUS
    NVAPI_VIDEO_CONTROL_GET_FLAG    eGetID; // (IN) get total CP count or CP details
    NVAPI_VIDEO_CONTROL_POINT_DESC  astCtrlPointDesc[NVAPI_MAX_CONTROL_POINTS_PER_PACKET]; // (OUT) details of supported control points
    NvU32                           dwCPCount; // (OUT) total count of enumerated control points
    NvU32                           dwStartCPCount; // (IN) starting CP count when reading the data
    NvU64                           aqwReserved[3]; // (IN/OUT) reserved for future expansion
} NVAPI_VIDEO_CONTROL_POINT_DESC_PACKET;

#define NVAPI_VIDEO_CONTROL_POINT_DESC_PACKET_VER MAKE_NVAPI_VERSION(NVAPI_VIDEO_CONTROL_POINT_DESC_PACKET,1)

typedef enum _NVAPI_VID_CTRL_COMMAND
{
    NVAPI_VideoCtrlPoint_Set = 1,
    NVAPI_VideoCtrlPoint_Reset = 2,
    NVAPI_VideoCtrlPoint_ResetAll = 3,
} NVAPI_VID_CTRL_COMMAND;


typedef struct _NVAPI_VIDEO_CONTROL_POINT_DATA_PACKET
{
    NvU32                               version; // (IN) NVAPI version that matches NVAPI_VIDEO_CONTROL_POINT_DATA_PACKET_VER
    NvU32                               dwReturnStatus; // (OUT) one of the NVAPI_VIDEO_CONTROL_RETURN_STATUS
    NVAPI_VID_CTRL_COMMAND              eCommand;       // (IN) one of NVAPI_VideoCtrlPoint_XXX enums
    NVAPI_VIDEO_CONTROL_POINT_ID        eID;            // (IN) control point ID
    NVAPI_VIDEO_CONTROL_POINT_DATATYPE  eType;          // (IN) data type
    union                                               // anonymous union 
    {
        void*                           pData;          // (IN) pointer to control point data 
        NvU64                           qwDataPad;      // pad up to 64 bit on 32 bit systems
    };
    NvU32                               dwDataSize;     // (IN) control point data size 
    NvU32                               adwReserved[4]; // (IN/OUT) reserved for future expansion 
} NVAPI_VIDEO_CONTROL_POINT_DATA_PACKET;

#define NVAPI_VIDEO_CONTROL_POINT_DATA_PACKET_VER   MAKE_NVAPI_VERSION(NVAPI_VIDEO_CONTROL_POINT_DATA_PACKET,1)

typedef struct _NVAPI_VIDEO_CONTROL_POINT_DATA
{
    NVAPI_VID_CTRL_COMMAND              eCommand;
    NVAPI_VIDEO_CONTROL_POINT_ID        eID;
    NvU32                               dwReturnStatus;
    NVAPI_VIDEO_CONTROL_POINT_DATATYPE  eType;
    NvU32                               dwStartOffset;
    NvU8                                abyData[NVAPI_MAX_CONTROL_POINT_DATA_SIZE_IN_BYTES]; // control point data
    NvU32                               dwPacketDataSize; // size of current packet
    NvU32                               dwDataSize; // total size of control point data 
} NVAPI_VIDEO_CONTROL_POINT_DATA;

typedef struct _NVAPI_VIDEO_CONTROL_POINT_REGISTER
{
    NvU64   qwCPSupportedBitFlags; // to be passed to KMD/XP in order to set supported bit of control points
} NVAPI_VIDEO_CONTROL_POINT_REGISTER;

typedef enum _NVAPI_VIDEO_CONTROL_ID
{
    NVAPI_VID_CTRL_ENUM = 1,
    NVAPI_VID_CTRL_GET,
    NVAPI_VID_CTRL_SET,
    NVAPI_VID_CTRL_REGISTER,
    NVAPI_VID_CTRL_LAST, // must be last 
} NVAPI_VIDEO_CONTROL_ID;

// struct to be passed to KMD 
typedef struct _NVAPI_VIDEO_CONTROL
{
    NvU32       dwCtrlID; // (IN) identify the individual ctrl, one of NVAPI_VID_CTRL_XXX enums
    union
    {
        NVAPI_VIDEO_CONTROL_POINT_DESC_PACKET  stVidCtrlPointDesc; // (IN/OUT)
        NVAPI_VIDEO_CONTROL_POINT_DATA         stVidCtrlPointData; // (IN/OUT)
        NVAPI_VIDEO_CONTROL_POINT_REGISTER     stVidCtrlPointReg; // (IN/OUT)
    };
} NVAPI_VIDEO_CONTROL;
///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_EnumerateVideoControlPoints
//
// DESCRIPTION:     API that enumerates all supported video control points to the caller 
//                  caller will first call it with GET_COUNT flag. Then this API will be called repeatedly with 
//                  GET_DETAILS flag until all the control points get enumerated.
//
// PARAMETERS:      hNvDisplay(IN)           - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle 
//                                             enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                  pControlPointDesc(IN/OUT)- NVAPI_VIDEO_CONTROL_POINT_DESC_PACKET containing details of all 
//                                             supported control points (NVAPI_VIDEO_CONTROL_POINT_DESC) and total count 
//                  pCPDescNamesArray(OUT)   - Array of NVAPI_VID_CTRL_POINT_DESC_STRINGS structs of size NVAPI_MAX_CONTROL_POINTS_PER_PACKET.
//                                              Strings will be filled if not NULL.
//  SUPPORTED OS: Windows XP and higher
// RETURN STATUS: 
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_EnumerateVideoControlPoints(NvDisplayHandle hNvDisplay, 
                                                  NVAPI_VIDEO_CONTROL_POINT_DESC_PACKET* pControlPointDesc, 
                                                  NVAPI_VID_CTRL_POINT_DESC_STRINGS* pCPDescNamesArray);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_VideoControl
//
// DESCRIPTION:     API that allows the caller to set one video control point value and 
//                  reset one/all control point value(s)
//
// PARAMETERS:      hNvDisplay(IN)        - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle 
//                                          enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                  pControlPointData(IN) - NVAPI_VIDEO_CONTROL_POINT_DATA_PACKET containing a flag(eCommand) for 
//                                          set one/ reset one/ reset all.
//                                          For setting one CP other inputs are:
//                                              a valid control point ID (NVAPI_VIDEO_CONTROL_POINT_ID),
//                                              eType (NVAPI_VIDEO_CONTROL_POINT_DATATYPE), 
//                                              data size and 
//                                              data pointer 
//                                          For resetting one CP other inputs are:
//                                              a valid control point ID (NVAPI_VIDEO_CONTROL_POINT_ID).
//                                          For resetting all CPs only the eCommand flag is required.
//  SUPPORTED OS: Windows XP and higher
// RETURN STATUS: 
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_VideoControl(NvDisplayHandle hNvDisplay, NVAPI_VIDEO_CONTROL_POINT_DATA_PACKET* pControlPointData);



// enums and structs related to video data providers 

#define NVAPI_MAX_DATA_PROVIDER_DETAILS    10
#define NVAPI_MAX_CAPTURE_IMAGES           8
#define NVAPI_MAX_CAPTURE_EXTRA_INFO       8
#define NVAPI_MAX_PULL_MODEL_DP_DATA_SIZE_IN_BYTES  476

typedef enum _NVAPI_VIDEO_DATA_PROVIDER_STATUS
{
    NVAPI_DP_STATUS_SUCCESS = 0,
    NVAPI_DP_STATUS_UNSUCCESSFUL,
    NVAPI_DP_STATUS_INVALID_ID,
    NVAPI_DP_STATUS_VALUE_OUT_OF_RANGE,
    NVAPI_DP_STATUS_INVALID_DATA_SIZE,
    NVAPI_DP_STATUS_FLAG_INVALID,
    NVAPI_DP_STATUS_NOT_INTIALIZED,
    NVAPI_DP_STATUS_INVALID_ARGUMENT,
    NVAPI_DP_STATUS_DISABLED,
    NVAPI_DP_STATUS_MAX_CLIENT_REACHED,
    NVAPI_DP_STATUS_CLIENT_NOT_PRESENT,
    NVAPI_DP_STATUS_MAX_DP_PER_CLIENT_REACHED,
} NVAPI_VIDEO_DATA_PROVIDER_STATUS;

// update the nvVidDataProviderNames[] array in nvdisp.cpp as well when adding a new Data Provider ID.
typedef enum _NVAPI_VIDEO_DATA_PROVIDER_ID
{
    NVAPI_DPID_INVALID = -1,
    NVAPI_DPID_DECODEDFRAMECOUNT,
    NVAPI_DPID_VPPSURFACECOUNT,
    NVAPI_DPID_VP2CYCLES,
    NVAPI_DPID_IMAGEBUFFER,
    NVAPI_DPID_FIXEDBUGS,
    NVAPI_DPID_INVTCWEAVEMODE,

	NVAPI_DPID_IMAGEBUFFER_OVERLAY_INTERNAL,
    NVAPI_DPID_IMAGEBUFFER_OVERLAY_EXTERNAL,
    NVAPI_DPID_IMAGEBUFFER_SHADER_DCCE,
    NVAPI_DPID_IMAGEBUFFER_SHADER_GAMUT_REMAP,
    NVAPI_DPID_IMAGEBUFFER_SHADER_GAMMA,
    NVAPI_DPID_IMAGEBUFFER_SHADER_PROCAMP,
    NVAPI_DPID_IMAGEBUFFER_SHADER_CSC,
    NVAPI_DPID_IMAGEBUFFER_SHADER_EE,
    NVAPI_DPID_IMAGEBUFFER_SHADER_FE,
    NVAPI_DPID_IMAGEBUFFER_SHADER_FMTXFER,
    NVAPI_DPID_IMAGEBUFFER_SHADER_NR,
    NVAPI_DPID_IMAGEBUFFER_SHADER_BLEND,
    NVAPI_DPID_IMAGEBUFFER_SHADER_SCALE,
    NVAPI_DPID_IMAGEBUFFER_4x4_SCALE,
    NVAPI_DPID_IMAGEBUFFER_COMPOSITOR_D3D,
    NVAPI_DPID_IMAGEBUFFER_DECODE,
    NVAPI_DPID_IMAGEBUFFER_SHADER_DI,
    NVAPI_DPID_IMAGEBUFFER_SHADER_ROTATE,

    // append here 
    NVAPI_DPID_LAST, // must be the last
} NVAPI_VIDEO_DATA_PROVIDER_ID;

typedef enum _NVAPI_VIDEO_DATA_PROVIDER_CAPTURE_STATUS
{
    NVAPI_DP_STATUS_CAPTURE_OFF = 0,
    NVAPI_DP_STATUS_CAPTURE_GENERIC_ERROR,
    NVAPI_DP_STATUS_CAPTURE_PENDING,
    NVAPI_DP_STATUS_CAPTURE_PENDING_SRC,
    NVAPI_DP_STATUS_CAPTURE_COMPLETE,
    NVAPI_DP_STATUS_CAPTURE_BUFFER_TOO_SMALL,
} NVAPI_VIDEO_DATA_PROVIDER_CAPTURE_STATUS;

typedef struct _NVAPI_VIDEO_DATA_PROVIDER_DESC
{
    NVAPI_VIDEO_DATA_PROVIDER_ID    eID;
    NvU32                           dwPeriod;
    NvU32                           dwBufferSize;
    NvU32                           dwBufferCount;
    NvU32                           bIsPullModelDataProvider:  1; // 0: Push model , 1: Pull model 
    NvU32                           bReserved1              : 31;
    NvU64                           aqwReserved2[3];
} NVAPI_VIDEO_DATA_PROVIDER_DESC;

// names to be returned to APP. used inside NVAPI
typedef struct _NVAPI_VID_DATA_PROVIDER_DESC_STRINGS
{
    NVAPI_VIDEO_DATA_PROVIDER_ID    eID;
    NvAPI_ShortString               szDataProviderName; // name of the Data Provider
    NvAPI_ShortString               szReserved1; // reserved for future expansion
    NvAPI_ShortString               szReserved2; // reserved for future expansion
} NVAPI_VID_DATA_PROVIDER_DESC_STRINGS;

typedef enum _NVAPI_VID_DATA_PROVIDER_GET_FLAG
{
    NVAPI_DP_GET_COUNT = 0,
    NVAPI_DP_GET_DETAILS,
} NVAPI_VID_DATA_PROVIDER_GET_FLAG;

typedef struct _NVAPI_VIDEO_DATA_PROVIDER_DESCRIPTOR
{
    NvU32                            version; // (IN) version that matches NVAPI_VIDEO_DATA_PROVIDER_DESCRIPTOR_VER
    NvU32                            dwStatus; // (OUT) one of the NVAPI_VIDEO_DATA_PROVIDER_RETURN_STATUS 
    NVAPI_VID_DATA_PROVIDER_GET_FLAG eGetID; // (IN) get total DP count or DP details
    NvU32                            dwStartDPCount; // (IN) starting DP count when reading the data
    NvU32                            dwDPCount; // (OUT) DP count returned
    NVAPI_VIDEO_DATA_PROVIDER_DESC   astDataProviderDetails[NVAPI_MAX_DATA_PROVIDER_DETAILS]; // (OUT) DP description
    NvU32                            adwReserved[5]; // (IN/OUT) reserved for future expansion
} NVAPI_VIDEO_DATA_PROVIDER_DESCRIPTOR;

#define NVAPI_VIDEO_DATA_PROVIDER_DESCRIPTOR_VER MAKE_NVAPI_VERSION(NVAPI_VIDEO_DATA_PROVIDER_DESCRIPTOR,1)

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_EnumVideoDataProviders
//
// DESCRIPTION:     API that enumerates all available data providers to the caller.
//                  Users are suggested to prefer Push model data providers to Pull model ones, as pull model Data 
//                  Providers are more incursive.
//
// PARAMETERS:      hNvDisplay(IN)        - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle 
//                                          enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                  pVideoDataProviderDesc(IN) - NVAPI_VIDEO_DATA_PROVIDER_DESCRIPTOR containing a valid get ID
//                                          (NVAPI_VID_DATA_PROVIDER_GET_FLAG), 
//                                          First client calls with NVAPI_DP_GET_COUNT flag.
//                                          Then it calls repeatedly with NVAPI_DP_GET_DETAILS flag to get the 
//                                          data provider description.
//                  pDataProvDescNamesArray(OUT) - NVAPI_VID_DATA_PROVIDER_DESC_STRINGS array of size NVAPI_MAX_DATA_PROVIDER_DETAILS.
//                                          The array is filled up if not NULL.
//  SUPPORTED OS: Windows XP and higher
// RETURN STATUS: 
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_EnumVideoDataProviders(NvDisplayHandle hNvDisplay, 
                                             NVAPI_VIDEO_DATA_PROVIDER_DESCRIPTOR* pVideoDataProviderDesc, 
                                             NVAPI_VID_DATA_PROVIDER_DESC_STRINGS* pDataProvDescNamesArray);

// struct used for registering / unregistering data providers.
typedef struct _NVAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO
{
    NvU32                       version;            // (IN) version that matches NVAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO_VER
    NvU32                       dwStatus;           // (OUT) one of the NV_VIDEO_DATA_PROVIDER_STATUS 
    NVAPI_VIDEO_DATA_PROVIDER_ID   eID;             // (IN) ID of the data provider 
    NvU32                       dwClientID;         // (IN) process ID of the client
    NvU32                       dwBufferCount;      // (IN) number of buffers in the buffer array
    NvU32                       dwBufferSize;       // (IN) size of the buffer 
    NvU64                       qwBufferArrayAdd;   // (IN) address of the client allocated buffer array 
    NvU32                       dwCapturePoint;     // (IN) capture point mask for current DP 
    NvU32                       dwNotifyPeriod;     // (IN) number of frames between two consecutive notifications
    NvU64                       qwEventHandle;      // (IN) event handle used for synchronization 
    NvU32                       dwFrameStart;       // (IN) frame number to start capture (first frame is 1!)
    NvU32                       dwFrameEnd;         // (IN) frame number to end capture
    NvU64                       aqwReserved[4];     // (IN/OUT) reserved for future expansion 
} NVAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO;

#define NVAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO_VER MAKE_NVAPI_VERSION(NVAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO,1)

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_RegisterVideoDataProvider
//
// DESCRIPTION:     API that allow caller to register a video data provider 
//
// PARAMETERS:      hNvDisplay(IN)        - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle 
//                                          enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                  pDataProviderReg(IN)  - NVAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO containing 
//                                          a valid data provider ID (eID), 
//                                          a client ID(dwClientID), 
//                                          address of the Buffer Array(qwBufferArrayAdd), 
//                                          buffer count in array(dwBufferCount), 
//                                          buffer size(dwBufferSize), 
//                                          capture points (dwCapturePoint), 
//                                          an event handle used for synchronization(qwEventHandle).
//  SUPPORTED OS: Windows XP and higher
// RETURN STATUS: 
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_RegisterVideoDataProvider(NvDisplayHandle hNvDisplay, 
                                                NVAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO* pDataProviderReg);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_UnregisterVideoDataProvider
//
// DESCRIPTION:     API that allow caller to register a video data provider 
//
// PARAMETERS:      hNvDisplay(IN)        - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle 
//                                          enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                  pDataProviderReg(IN)  - NVAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO containing 
//                                          a valid data provider ID (eID), 
//                                          a client ID(dwClientID).
//  SUPPORTED OS: Windows XP and higher
// RETURN STATUS: 
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_UnregisterVideoDataProvider(NvDisplayHandle hNvDisplay, 
                                                NVAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO* pDataProviderReg);

// Internal struct used to get values of pull model data providers
typedef struct _NVAPI_PULL_MODEL_DATA_PACKET
{
    NvU32                           dwStatus;
    NVAPI_VIDEO_DATA_PROVIDER_ID    eID;
    NvU32                           dwBufferCount;
    NvU32                           dwBufferSize;
    NvU32                           dwStartOffset;
    NvU8                            abyData[NVAPI_MAX_PULL_MODEL_DP_DATA_SIZE_IN_BYTES];
    NvU32                           dwClientID;
} NVAPI_PULL_MODEL_DATA_PACKET;

typedef struct _NVAPI_VIDEO_DATA_GET
{
    NvU32                           version;        // (IN) version that matches NVAPI_VIDEO_DATA_GET_VER
    NvU32                           dwStatus;       // (OUT) one of the NV_VIDEO_DATA_PROVIDER_STATUS 
    NVAPI_VIDEO_DATA_PROVIDER_ID    eID;            // (IN) Video Data Provider ID 
    NvU32                           dwClientID;     // (IN) process ID of the client 
    NvU32                           dwBufferSize;   // (IN) size (in bytes) of each data element in the array
    NvU32                           dwBufferCount;  // (IN) number of elements in the array 
    union                                           // anonymous union 
    {
        void*                       pBuffArray;     // (IN) base address of buffer array 
        NvU64                       pPad;           // ensure proper sizing on 64bit OS 
    };
    NvU32                           dwReserved[3];  // (IN/OUT) reserved for future expansion 
} NVAPI_VIDEO_DATA_GET;

#define NVAPI_VIDEO_DATA_GET_VER MAKE_NVAPI_VERSION(NVAPI_VIDEO_DATA_GET,1)

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetVideoData
//
// DESCRIPTION:     API that allow caller to retrieve video data for a pull model data provider. Total size of 
//                  the data array is limited to NVAPI_MAX_PULL_MODEL_DP_DATA_SIZE_IN_BYTES.
//                  The caller should use this method as infrequently as possible, preferably after completion of 
//                  one playback session.
//
// PARAMETERS:      hNvDisplay(IN)   - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle 
//                                     enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                  pVidDataGet(IN)  - NVAPI_VIDEO_DATA_GET containing 
//                                      a valid data provider ID (eID), 
//                                      a client ID(dwClientID),
//                                      data size,
//                                      data Pointer,
//                                      buffer count.
//  SUPPORTED OS: Windows XP and higher
// RETURN STATUS: 
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetVideoData(NvDisplayHandle hNvDisplay, NVAPI_VIDEO_DATA_GET* pVidDataGet);

// structures used for user allocated capture buffer, to be used for DPID_ImageBuffer.
typedef struct _NVAPI_IMAGE_BUFFER
{
    NvU32   dwDataSize;         // size of segment in bytes
    NvU32   dwPixelType;        // FOURCC code, or 1,2,3,4 for n-byte RGB data
    NvU32   dwHeight;           // height in pels
    NvU32   dwWidth;            // width in pels
    NvU32   bytesPerPixel:  3;  // number of bytes per pixel : width*bytesPerPixel = image data on each line
    NvU32   bReserved1   : 29;  // reserved for future expansion
    NvU32   dwPitch;            // pitch in bytes
    NvU32   dwInfo1;            // general info relevant to this pixeltype
    NvU32   dwInfo2;            // more general info
    union                       // anonymous union
    {
        NvU8*   pImgData;       // Pointer to data for this buffer
        NvU64   qwPad;          // pad up to 64 bit on 32 bit systems 
    };
    NvU64   aqwReserved2[2];    // reserved for future expansion
} NVAPI_IMAGE_BUFFER;

typedef struct _NVAPI_VIDEO_CAPTURE_BUFFER
{
    NvU32           dwCaptureStatus;        // NVAPI_VIDEO_DATA_PROVIDER_CAPTURE_STATUS
    NvU32           dwCapturePoint;         // At what point was this frame captured
    NvU32           dwCaptureFrameIndex;    // What frame number is to be captured
    NvU32           dwCaptureBufferSize;    // Size of the buffer (including this header)
    NvU32           dwCurrentFrameIndex;    // What the frame number is now
    NvU32           dwImageCount;           // Number of image buffers used
    NVAPI_IMAGE_BUFFER  astImage[NVAPI_MAX_CAPTURE_IMAGES];

    NvU32           bCaptureSource    :  1;  // additional segments store source fields/frames (for deinterlace capture)
    NvU32           bCaptureAllFrames :  1;  // set only if we're capturing all frames (or at least more than just one)
    NvU32           byDecodedFrameType:  8;  // field (0=Progressive/1=A/2=B/3=Unknown) corresponding to decoded frame
    NvU32           reserved1         : 22;  // reserved for future expansion

    NvU32           dwCaptureFrameRange;    // set the range of frames to capture (typically only used for
                                            // golden captures on emulation)
    NvU32           dwDecodedFrameCount;    // Frame count of decoded frame corresponding to this buffer
    NvU32           dwUsedBufferSpace;      // Size used in the buffer (including this header)
    NvU32           dwSrcCount;
    NvU32           adwExtraInfo[NVAPI_MAX_CAPTURE_EXTRA_INFO]; // Extra info about this capture (specific to capture type)
    NvU32           dwReserved2[3];         // reserved for future expansion

    // Image buffer data immediately follows this struct in memory. astImage[i].pImgData points into it

} NVAPI_VIDEO_CAPTURE_BUFFER;

typedef struct _NVAPI_VIDEO_INVTC_WEAVEMODE_BUFFER
{
    NvU32           dwCaptureStatus;        // NV_VIDEO_DATA_PROVIDER_CAPTURE_STATUS        
    NvU32           dwWeaveMode;            // dwWeaveMode stores the WeaveMode decision
    NvU32           dwReserved[2];          // reserved for future expansion    
}NVAPI_VIDEO_INVTC_WEAVEMODE_BUFFER;

// video capture points used for image capture 
typedef enum _NVAPI_VIDEO_CAPTURE_POINTS
{
    NVAPI_VIDEO_CAPTURE_NONE           = 0x00000000,
    NVAPI_VIDEO_CAPTURE_DECODE         = 0x00000001,
    NVAPI_VIDEO_CAPTURE_OVERLAY        = 0x00000002,
    NVAPI_VIDEO_CAPTURE_BLIT           = 0x00000004,
    NVAPI_VIDEO_CAPTURE_VPBLIT         = 0x00000008,
    NVAPI_VIDEO_CAPTURE_UNLOCK         = 0x00000010,
    NVAPI_VIDEO_CAPTURE_FE             = 0x00000020,
    NVAPI_VIDEO_CAPTURE_EE             = 0x00000040,
    NVAPI_VIDEO_CAPTURE_NR             = 0x00000080,
    NVAPI_VIDEO_CAPTURE_DI             = 0x00000100,
    NVAPI_VIDEO_CAPTURE_INVTC          = 0x00000200,
    NVAPI_VIDEO_CAPTURE_PROCAMP_CSC    = 0x00000400,
    NVAPI_VIDEO_CAPTURE_GAMMA          = 0x00000800,
    NVAPI_VIDEO_CAPTURE_GAMUT_REMAP    = 0x00001000,
    NVAPI_VIDEO_CAPTURE_DCCE           = 0x00002000,
    NVAPI_VIDEO_CAPTURE_BLEND          = 0x00004000,
    NVAPI_VIDEO_CAPTURE_SCALE          = 0x00008000,
    NVAPI_VIDEO_CAPTURE_COMPOSITOR     = 0x00010000,
} NVAPI_VIDEO_CAPTURE_POINTS;

// Internal functions and structs for Video Data Providers.

typedef enum _NVAPI_VID_DATA_PROVIDER_CTRL_ID
{
    NV_DATA_PROVIDER_ENUM = 1,
    NV_DATA_PROVIDER_REGISTER = 2,
    NV_DATA_PROVIDER_UNREGISTER = 3,
    NV_DATA_PROVIDER_PULL_MODEL_GET = 6,

    NV_DATA_PROVIDER_CTRL_LAST = 7,
} NVAPI_VID_DATA_PROVIDER_CTRL_ID;

// internal common struct to be passed to KMD/XP
typedef struct _NVAPI_VID_DATA_PROVIDER_CTRL
{
    NvU32           dwCtrlID; // (IN) one of the NV_DATA_PROVIDER_xxx enums 
    union // anonymous union 
    {
        NvU64 qwParams[70]; // this is to ensure proper sizing with the driver 

        NVAPI_VIDEO_DATA_PROVIDER_DESCRIPTOR           stDataProviderDesc; // (IN/OUT)
        NVAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO    stDataProviderReg; // (IN/OUT)
        NVAPI_PULL_MODEL_DATA_PACKET                   stPullModelData; // (IN/OUT)
    };
} NVAPI_VID_DATA_PROVIDER_CTRL;



#define NVAPI_MAX_NBSI_PARAM_SIZE 256

// Constants for hive values defined for modules
typedef enum _NVAPI_BIOS_NBSI_MODULE_TYPES
{
    NVAPI_BIOS_NBSI_MODULE_GLOBAL=0,      // global section contains version
    NVAPI_BIOS_NBSI_MODULE_RM ,
    NVAPI_BIOS_NBSI_MODULE_DD,
    NVAPI_BIOS_NBSI_MODULE_VIDEO,
    NVAPI_BIOS_NBSI_MODULE_CPL,
    NVAPI_BIOS_NBSI_MODULE_D3D,
    NVAPI_BIOS_NBSI_MODULE_OGL,
    NVAPI_BIOS_NBSI_PMU,           // PMU microcode
    NVAPI_BIOS_NBSI_MODE          // Modes
    } NVAPI_BIOS_NBSI_MODULE_TYPES;

typedef enum _NVAPI_BIOS_NBSI_ERROR_CODES
{
    NVAPI_BIOS_GET_NBSI_SUCCESS         = 0x00000000,
    NVAPI_BIOS_GET_NBSI_OVERRIDE        = 0x00000001,
    NVAPI_BIOS_GET_NBSI_BAD_HASH        = 0xFFFFFFFA,
    NVAPI_BIOS_GET_NBSI_APITEST_SUCCESS = 0xFFFFFFFB,
    NVAPI_BIOS_GET_NBSI_BAD_TABLE       = 0xFFFFFFFC,
    NVAPI_BIOS_GET_NBSI_NO_TABLE        = 0xFFFFFFFD,
    NVAPI_BIOS_GET_NBSI_INCOMPLETE      = 0xFFFFFFFE,
    NVAPI_BIOS_GET_NBSI_NOT_FOUND       = 0xFFFFFFFF,
} NVAPI_BIOS_NBSI_ERROR_CODES;
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetNBSIParams
//
//PARAMETERS:      hPhysicalGpu(IN)     - GPU selection.
//                 key(IN)              - Ascii value of key, to be used to identify parameter name/value.
//                 val(IN)              - Ascii value of Value, to be used to identify parameter name/value.
//                 moduleId(IN)         - Enum value of module to which this parameter setting belongs.
//                 data(OUT)            - Data stored for the parameter(NBSI setting object).
//                 psizeofdata(IN/OUT)  - Maximum size of data(return value), is passed in. If successfull this parameter contains actuall size of the output data.
//                 pnbsiErrorCode(OUT)  - Returns possible error values of NBSI.
// DESCRIPTION: Gives the NBSI parameter value and NBSI return code as output.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hPhysicalGpu or data is NULL
//                NVAPI_OK: *data contains NBSI parameter value
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetNBSIParams(NvPhysicalGpuHandle hPhysicalGpu, NvAPI_LongString key, NvAPI_LongString val, NVAPI_BIOS_NBSI_MODULE_TYPES moduleId, NvU8 data[NVAPI_MAX_NBSI_PARAM_SIZE], NvU32 *psizeofdata, NVAPI_BIOS_NBSI_ERROR_CODES *pnbsiErrorCode);


#define NVAPI_MAX_GPUS_PER_VISUAL_COMPUTING_DEVICE    8
#define NVAPI_MAX_VISUAL_COMPUTING_DEVICES            8
#define NVAPI_MAX_GSYNC_DEVICES                       4

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_EnumVisualComputingDevices
//
//   DESCRIPTION: Returns an array of Visual Computing Device handles. A Visual Computing Device handle 
//                represents one or more GPUs acting in concert as a single Visual Computing Device.
//
//   PARAMETERS:  nvComputeHandles[OUT] - The caller provides an array of handles, which 
//                must contain at least NVAPI_MAX_VISUAL_COMPUTING_DEVICES elements. The API will zero out 
//                the entire array, and then fill in one or more handles. If an error occurs, the array is invalid.
//
//                *pSystemCount[OUT] - The caller provides the storage space. NvAPI_EnumVisualComputingDevices
//                sets *pSystemCount to indicate how many of the elements in the nvComputeHandles[] array are valid.
//                If an error occurs, *pSystemCount will be set to zero.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: nvComputingHandle or pSystemCount is NULL
//                NVAPI_OK: one or more handles were returned
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: The queried Graphics system does not have any Visual Computing Device.
//                NVAPI_ERROR: the operation failed.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_EnumVisualComputingDevices(NvVisualComputingDeviceHandle nvComputeHandles[NVAPI_MAX_VISUAL_COMPUTING_DEVICES], NvU32 *pSystemCount);

///////////////////////////////////////////////////////////////////////////////
typedef enum 
{
    NV_VISUAL_COMPUTING_DEVICE_PERFORMANCE_MODE_ON = 1,
    NV_VISUAL_COMPUTING_DEVICE_PERFORMANCE_MODE_OFF = 2,
    NV_VISUAL_COMPUTING_DEVICE_PERFORMANCE_MODE_NOT_SUPPORTED = -1,

} NV_VISUAL_COMPUTING_DEVICE_PERFORMANCE_MODE;


typedef struct _NV_VISUAL_COMPUTING_DEVICE_INFO
{
    NvU32                               version;
    NvAPI_LongString                    productName;
    NvAPI_LongString                    serialNumber;
    NvAPI_ShortString                   firmwareVersion;                    //major number.minor number
    NvU32                               buildDateYear;                      //build date: year the system got built.
    NvU32                               buildDateWeek;                      //build date: week the system got built.
    NvAPI_ShortString                   hardwareVersion;                    //version of the hardware spin
    NV_VISUAL_COMPUTING_DEVICE_PERFORMANCE_MODE  perfMode;                  //system performance mode

    NvPhysicalGpuHandle gpuHandle[NVAPI_MAX_GPUS_PER_VISUAL_COMPUTING_DEVICE];//associated physical gpu handles.
     
} NV_VISUAL_COMPUTING_DEVICE_INFO;

#define NV_VISUAL_COMPUTING_DEVICE_INFO_VER  MAKE_NVAPI_VERSION(NV_VISUAL_COMPUTING_DEVICE_INFO,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_VCD_GetDeviceInfo
//
//   DESCRIPTION: Returns Visual Computing Device information.
//
//   PARAMETERS:  nvComputingHandle[IN] - The enumerated Visual Computing Device handle retrieved from NvAPI_EnumVisualComputingDevices.
//                pVisInfo[OUT] - Contains the retrieved Visual Computing Device information with the associated GPU handles.
//                pVisInfo->version needs to be set to NV_VISUAL_COMPUTING_DEVICE_INFO_VER for the API to succeed.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: nvComputingHandle or pVisInfo is NULL
//                NVAPI_OK: one or more handles were returned
//                NVAPI_ERROR: the operation failed.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: The queried Graphics system does not have any Visual Computing Device.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_VCD_GetDeviceInfo(NvVisualComputingDeviceHandle nvComputingHandle, NV_VISUAL_COMPUTING_DEVICE_INFO *pVisInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_VCD_UpdatePerformanceMode
//
//   DESCRIPTION: Enables or disables the Visual Computing Device high performance mode.
//
//   PARAMETERS:  nvComputingHandle[IN] - The enumerated Visual Computing Device handle retrieved from NvAPI_EnumVisualComputingDevices.
//                systemPerfMode[IN] - The valid value to switch to the new performance mode.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: Any values other than NV_VISUAL_COMPUTING_DEVICE_PERFORMANCE_MODE_ON 
//                and NV_VISUAL_COMPUTING_DEVICE_PERFORMANCE_MODE_OFF are invalid.
//                NVAPI_OK: update successful.
//                NVAPI_NOT_SUPPORTED: This controller does not support performance mode.
//                NVAPI_ERROR: the operation failed.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: The queried Graphics system does not have any Visual Computing Device.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_VCD_UpdatePerformanceMode(NvVisualComputingDeviceHandle nvComputingHandle, NV_VISUAL_COMPUTING_DEVICE_PERFORMANCE_MODE systemPerfMode);

///////////////////////////////////////////////////////////////////////////////

#define NV_POWER_SUPPLY_STATE_NORMAL                    0x00000001    //Normal operation
#define NV_POWER_SUPPLY_STATE_ABNORMAL                  0x00000002    //Power Shut down
//Additional Abnormal power states 
#define NV_POWER_SUPPLY_STATE_ABNORMAL_HIGH_VOLTAGE     0x00000008    //Output shutdown due to hi-voltage
#define NV_POWER_SUPPLY_STATE_ABNORMAL_FAN_FAILURE      0x00000010    //Fan failure
#define NV_POWER_SUPPLY_STATE_ABNORMAL_HEATSINK         0x00000040    //Alarm - "Heatsink over temperature"    
#define NV_POWER_SUPPLY_STATE_ABNORMAL_LIMIT_REACHED    0x00000080    //Current limit reached    
#define NV_POWER_SUPPLY_STATE_ABNORMAL_OUTPUT_THRESHOLD 0x00000100    //Output voltage below UV alarm threshold
#define NV_POWER_SUPPLY_STATE_ABNORMAL_LOW_VOLTAGE      0x00000200    //Output shut down due to lo-voltage         
#define NV_POWER_SUPPLY_STATE_ABNORMAL_I2C_REMOTE_OFF   0x00001000    //Shutdown due to I2C remote off command        
#define NV_POWER_SUPPLY_STATE_ABNORMAL_DISABLE          0x00002000    //Shutdown due to MOD_DISABLE input
#define NV_POWER_SUPPLY_STATE_ABNORMAL_SHORT_PIN        0x00004000    //Shutdown due to short pin transition

typedef enum 
{
    NV_POWER_SUPPLY_VALERE = 1,
    NV_POWER_SUPPLY_DELTA,

} NV_POWER_SUPPLY_TYPE;

typedef struct _NV_POWER_SUPPLY_INFO
{
    NvU32                   version;  
    NV_POWER_SUPPLY_TYPE    psuType;    //power supply make
    NvU32                   voltage;    //in volts
    NvU32                   current;    //in amps
    NvU32                   stateFlags; //one or more power state flags - normal or abnormal
    
} NV_POWER_SUPPLY_INFO;

#define NV_POWER_SUPPLY_INFO_VER  MAKE_NVAPI_VERSION(NV_POWER_SUPPLY_INFO,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_VCD_GetPowerSupplyInfo
//
//   DESCRIPTION: Returns power suppply information on the Visual Computing Device.
//
//   PARAMETERS:  nvComputingHandle[IN] - The enumerated Visual Computing Device handle retrieved from NvAPI_EnumVisualComputingDevices.
//                pPowerInfo[OUT] - Contains the retrieved Power Supply information for the selected Visual Computing Device.
//                pPowerInfo->version has to be set to NV_POWER_SUPPLY_INFO_VER for the API to succeed..
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: nvComputingHandle or pPowerInfo is NULL
//                NVAPI_OK: Information successfully in pPowerInfo.
//                NVAPI_ERROR: the operation failed.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: The queried Graphics system does not have any Visual Computing Device.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_VCD_GetPowerSupplyInfo(NvVisualComputingDeviceHandle nvComputingHandle, NV_POWER_SUPPLY_INFO *pPowerInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_VCD_GetThermalInfo
//
//   DESCRIPTION: Returns thermal information from the Visual Computing Device.
//
//   PARAMETERS:  nvComputingHandle[IN] - The enumerated Visual Computing Device handle retrieved from NvAPI_EnumVisualComputingDevices.
//                pThermalSettings[OUT] - Contains the Visual Computing Device thermal information returned in pThermalSettings.
//                pThermalSettings->version has to be set to NV_GPU_THERMAL_SETTINGS_VER for the API to succeed..
//                One or more NVAPI_THERMAL_TARGET_VCD target thermal information can be retrieved.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: nvComputingHandle or pThermalSettings is NULL
//                NVAPI_OK: Information successfully in pThermalSettings.
//                NVAPI_ERROR: the operation failed.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: The queried Graphics system does not have any Visual Computing Device.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_VCD_GetThermalInfo(NvVisualComputingDeviceHandle nvComputingHandle, NV_GPU_THERMAL_SETTINGS *pThermalSettings);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_VCD_GetCoolerSettings
//
//   DESCRIPTION: Returns cooler information from the Visual Computing Device.
//
//   PARAMETERS:  nvComputingHandle[IN] - The enumerated Visual Computing Device handle retrieved from NvAPI_EnumVisualComputingDevices.
//                pCoolerInfo[OUT] - The Visual Computing Device cooler information returned in pCoolerInfo.
//                pCoolerInfo->version has to be set to NV_GPU_GETCOOLER_SETTINGS_VER for the API to succeed..
//                requestedFanLevel[OUT] - Percent of cooling capacity requested by the internal fan controller.
//                                         This is typically a function of exhaust temperature and/or chip temperature.
//                One or more NVAPI_COOLER_TARGET_VCD target cooler settings can be retrieved.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: nvComputingHandle or pCoolerInfo is NULL
//                NVAPI_OK: Information successfully in pCoolerInfo.
//                NVAPI_ERROR: the operation failed.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: The queried Graphics system does not have any Visual Computing Device.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_VCD_GetCoolerSettings(NvVisualComputingDeviceHandle nvComputingHandle, NV_GPU_GETCOOLER_SETTINGS *pCoolerInfo, NvU32 * pRequestedFanLevel);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_VCD_GetAssociatedGSyncs
//
//   DESCRIPTION: Returns all the GSync devices attached to a Visual Computing Device(VCD)
//
//   PARAMETERS:  nvComputingHandle[IN] - The enumerated Visual Computing Device handle retrieved from NvAPI_EnumVisualComputingDevices.
//                nvGSyncHandles[OUT] - The caller provides an array of handles, which must contain at least 
//                NVAPI_MAX_GSYNC_DEVICES elements. The API will fill in one or more handles. If an error occurs, the array is invalid.
//
//                *gsyncCount[OUT] - The caller provides the storage space. NvAPI_VCD_GetAssociatedGSyncs
//                sets *gsyncCount to indicate how many of the elements in the nvGSyncHandles[] array are valid.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: One of the arguments is NULL.
//                NVAPI_OK: Information retrieved successfully.
//                NVAPI_ERROR: The operation failed.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: The queried Graphics system does not have any Visual Computing Device.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_VCD_GetAssociatedGSyncs(NvVisualComputingDeviceHandle nvComputingHandle, NvGSyncDeviceHandle nvGSyncHandles[NVAPI_MAX_GSYNC_DEVICES], NvU32 *gsyncCount);




#ifndef ANY_SIZE_ARRAY
#define ANY_SIZE_ARRAY 127
#endif

#define NBSIDIRHDRSTRING (NvU32) (('N'<<24)+('B'<<16)+('S'<<8)+'I')
// A directory of globs
#pragma pack(1)
typedef union _NBSI_DIRECTORY
{
    struct OLD_FORMAT                   // Original version for Beta
    {
        NvU8  numGlobs;                 // number of globs
        NvU8  dirVer;                   // dirVer
        NvU16 globType[1];              // NBSI_GLOB_TYPE (placeholder)
    } od;
    struct NEW_FORMAT                   // Shipping version
    {
        NvU32 nbsiHeaderString;         // header string NBSIDIRHDRSTRING
        NvU32 size;                     // size of entire directory
        NvU8  numGlobs;                 // number of globs
        NvU8  dirVer;                   // dirVer
        NvU16 globType[1];              // NBSI_GLOB_TYPE (placeholder
    } d;
} NBSI_DIRECTORY, *PNBSI_DIRECTORY;
#pragma pack()

#pragma pack(1)
typedef struct _NBSI_GEN_OBJ
{
    NvU64       sig;          // One-way Hash of the entire object
    // Hash from here -->
    NvU16       globType;     // NBSI_GLOB_TYPE
    NvU32       size;         // Total size of GLOB including Signature
    NvU16       majMinVer;    // Version of Generic Object in Maj:Min format
    // actual packed object data
    NvU8        objData[ANY_SIZE_ARRAY];
    // <-- to here
} NBSI_GEN_OBJ, *PNBSI_GEN_OBJ;
#pragma pack()

typedef enum _NBSI_TBL_SOURCES
{
    NBSI_TBL_SOURCE_BEST_FIT = 0,
    NBSI_TBL_SOURCE_REGISTRY = 1,
    NBSI_TBL_SOURCE_VBIOS    = 2,
    NBSI_TBL_SOURCE_I2C      = 4,
    NBSI_TBL_SOURCE_SBIOS    = 8,
    NBSI_TBL_SOURCE_ACPI     = 0x10
} NBSI_TBL_SOURCES, * PNBSI_TBL_SOURCES;
#define NBSI_TBL_SOURCE_MAX 5                    // number of NBSI_TBL_SOURCES entries (not including BEST FIT)

#define nbsiobjtype(ch1,ch2) (NvU16) ((ch1<<8) + ch2)
typedef enum _NBSI_GLOB_TYPES
{
    NBSI_RSRVD_GLOB     = 0,                     // Reserved Glob type
    NBSI_DRIVER         = nbsiobjtype('D','R'),  // Driver Object
    NBSI_VBIOS          = nbsiobjtype('V','B'),  // VBIOS Object
    NBSI_HDCP           = nbsiobjtype('H','K'),  // HDCP Keys
    NBSI_HDD            = nbsiobjtype('H','D'),  // Storage Driver
    NBSI_NONVOLATILE    = nbsiobjtype('N','V')   // CMOS settings
} NBSI_GLOB_TYPE, * PNBSI_GLOB_TYPE;

#define GLOB_TYPE_APITEST            0xffff     // used to test the nvapi interface
#define GLOB_TYPE_GET_NBSI_DIR       0xfffe     // used to get entire dir, must specify globSource
#define GLOB_TYPE_GET_NBSI_ACPI_RAW  0xfffd     // used when accessing ACPI via GET NBSI OBJ call. Used by tools.
#define NBSI_FUNC_SUPPORT            0          // function for checking NBSI ACPI support

#define NBSI_SOURCE_LOC NvU16

#define NVAPI_MAX_GET_NBSI_OBJ_SIZE 4096

#define NVAPI_MAX_GET_MAX_GLOB_INDEX 15

typedef struct _NVAPI_GET_NBSI_OBJ
{
    NvU32 version;                              // (IN) NVAPI version that matches NVAPI_GET_NBSI_OBJ_VER
    NvU16 globType;                             // (IN) The glob Type for the nbsi object to get.
    NvU8  globIndex;                            // (IN/OUT) IN: The glob Index for the object to get (0..15) 0=best fit, 1=1st instance, 2=2nd instance etc.)
                                                //         OUT: actual index found at.
    NBSI_SOURCE_LOC globSource;                 // (IN/OUT) IN: Source of directory to get glob from (0=normal search sequence, 1..x specific dir location).
                                                //         OUT: actual directory source object was found at.
    NvU32 dataOffset;                           // (IN) Starting data offset within the nbsi object to return (when doing multiple calls... 0=beginning of object)
    NvU8  data[NVAPI_MAX_GET_NBSI_OBJ_SIZE];    // (OUT) Buffer to hold return data
    NvU32 pSizeOfData;                          // (IN/OUT) in: contains size of data buffer, on output contains amount filled in data buffer.
    NvU32 totalObjSize;                         // (OUT) total size of entire object (may exceed pSizeOfData).
    NVAPI_BIOS_NBSI_ERROR_CODES pNbsiErrorCode; // (OUT) - Returns error values of NBSI.
} NVAPI_GET_NBSI_OBJ;


#define NVAPI_GET_NBSI_OBJ_VER  MAKE_NVAPI_VERSION(NVAPI_GET_NBSI_OBJ,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetNBSIObj
//
// PARAMETERS:    hPhysicalGpu(IN)        - GPU selection.
//                getNbsiObjParms(IN/OUT) - NVAPI_GET_NBSI_OBJ packet containing request/return for get NBSI object.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// DESCRIPTION: Gives a generic NBSI object and NBSI return code as output.
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hPhysicalGpu or data is NULL
//                NVAPI_OK: *data contains NBSI parameter value (including error code in pNbsiErrorCode on failure).
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetNBSIObj(NvPhysicalGpuHandle hPhysicalGpu, NVAPI_GET_NBSI_OBJ * getNbsiObjParms);


////////////////////////////////////////////////////////////////////////////////////////
//
// MOSAIC allows a multi display target output scanout on a single source. 
//
// SAMPLE of MOSAIC 1x4 topo with 8 pixel horizontal overlap
//
//+-------------------------++-------------------------++-------------------------++-------------------------+
//|                         ||                         ||                         ||                         |
//|                         ||                         ||                         ||                         |
//|                         ||                         ||                         ||                         |
//|        DVI1             ||           DVI2          ||         DVI3            ||          DVI4           |
//|                         ||                         ||                         ||                         |
//|                         ||                         ||                         ||                         |
//|                         ||                         ||                         ||                         |
//|                         ||                         ||                         ||                         |
//+-------------------------++-------------------------++-------------------------++-------------------------+

#define NVAPI_MAX_MOSAIC_DISPLAY_ROWS       8
#define NVAPI_MAX_MOSAIC_DISPLAY_COLUMNS    8

//
// These bits are used to describe the validity of a topo.
//
#define NV_MOSAIC_TOPO_VALIDITY_VALID               0x00000000  // The topo is valid
#define NV_MOSAIC_TOPO_VALIDITY_MISSING_GPU         0x00000001  // Not enough SLI GPUs were found to fill the entire
                                                                // topo.  hPhysicalGPU will be 0 for these.
#define NV_MOSAIC_TOPO_VALIDITY_MISSING_DISPLAY     0x00000002  // Not enough displays were found to fill the entire
                                                                // topo.  displayOutputId will be 0 for these.
#define NV_MOSAIC_TOPO_VALIDITY_MIXED_DISPLAY_TYPES 0x00000004  // Topo is only possible with displays of the same
                                                                // NV_GPU_OUTPUT_TYPE.  Check displayOutputIds to make
                                                                // sure they are all CRT, or all DFP.


//
// This structure defines the details of a topo.
//
typedef struct 
{
    NvU32                version;              // version of this structure
    NvLogicalGpuHandle   hLogicalGPU;          // logical gpu this topo is for
    NvU32                validityMask;         // 0 means topo is valid with current hardware.
                                               // If not 0, inspect bits against NV_MOSAIC_TOPO_VALIDITY_*.
    NvU32                rowCount;             // number of displays in a row
    NvU32                colCount;             // number of displays in a column

    struct 
    {
        NvPhysicalGpuHandle hPhysicalGPU;      // physical gpu to be used in the topo (0 if GPU missing)
        NvU32               displayOutputId;   // connected display target (0 if no display connected)
        NvS32               overlapX;          // pixels of overlap on left of target: (+overlap, -gap)
        NvS32               overlapY;          // pixels of overlap on top of target: (+overlap, -gap)

    } gpuLayout[NVAPI_MAX_MOSAIC_DISPLAY_ROWS][NVAPI_MAX_MOSAIC_DISPLAY_COLUMNS];

} NV_MOSAIC_TOPO_DETAILS;

#define NVAPI_MOSAIC_TOPO_DETAILS_VER         MAKE_NVAPI_VERSION(NV_MOSAIC_TOPO_DETAILS,1)


//
// These values refer to the different types of Mosaic topos that are possible.  When
// getting the supported Mosaic topos, you can specify one of these types to narrow down
// the returned list to only those that match the given type.
//
typedef enum
{
    NV_MOSAIC_TOPO_TYPE_ALL,                          // All mosaic topos
    NV_MOSAIC_TOPO_TYPE_BASIC,                        // Basic Mosaic topos
    NV_MOSAIC_TOPO_TYPE_PASSIVE_STEREO,               // Passive Stereo topos
    NV_MOSAIC_TOPO_TYPE_SCALED_CLONE,                 // Not supported at this time
    NV_MOSAIC_TOPO_TYPE_PASSIVE_STEREO_SCALED_CLONE,  // Not supported at this time
    NV_MOSAIC_TOPO_TYPE_MAX,                          // Always leave this at end of enum
} NV_MOSAIC_TOPO_TYPE;


//
// The complete list of supported Mosaic topos.
//
// NOTE: common\inc\nvEscDef.h shadows a couple PASSIVE_STEREO enums.  If this
//       enum list changes and effects the value of NV_MOSAIC_TOPO_BEGIN_PASSIVE_STEREO
//       please update the corresponding value in nvEscDef.h
//
typedef enum
{
    NV_MOSAIC_TOPO_NONE,

    // 'BASIC' topos start here
    //
    // The result of using one of these Mosaic topos is that multiple monitors
    // will combine to create a single desktop.
    //
    NV_MOSAIC_TOPO_BEGIN_BASIC,
    NV_MOSAIC_TOPO_1x2_BASIC = NV_MOSAIC_TOPO_BEGIN_BASIC,
    NV_MOSAIC_TOPO_2x1_BASIC,
    NV_MOSAIC_TOPO_1x3_BASIC,
    NV_MOSAIC_TOPO_3x1_BASIC,
    NV_MOSAIC_TOPO_1x4_BASIC,
    NV_MOSAIC_TOPO_4x1_BASIC,
    NV_MOSAIC_TOPO_2x2_BASIC,
    NV_MOSAIC_TOPO_2x3_BASIC,
    NV_MOSAIC_TOPO_2x4_BASIC,
    NV_MOSAIC_TOPO_END_BASIC = NV_MOSAIC_TOPO_2x4_BASIC,

    // 'PASSIVE_STEREO' topos start here
    //
    // The result of using one of these Mosaic topos is that multiple monitors
    // will combine to create a single PASSIVE STEREO desktop.  What this means is
    // that there will be two topos that combine to create the overall desktop.
    // One topo will be used for the left eye, and the other topo (of the
    // same rows x cols), will be used for the right eye.  The difference between
    // the two topos is that different GPUs and displays will be used.
    //
    NV_MOSAIC_TOPO_BEGIN_PASSIVE_STEREO,    // value shadowed in nvEscDef.h
    NV_MOSAIC_TOPO_1x2_PASSIVE_STEREO = NV_MOSAIC_TOPO_BEGIN_PASSIVE_STEREO,
    NV_MOSAIC_TOPO_2x1_PASSIVE_STEREO,
    NV_MOSAIC_TOPO_1x3_PASSIVE_STEREO,
    NV_MOSAIC_TOPO_3x1_PASSIVE_STEREO,
    NV_MOSAIC_TOPO_1x4_PASSIVE_STEREO,
    NV_MOSAIC_TOPO_4x1_PASSIVE_STEREO,
    NV_MOSAIC_TOPO_2x2_PASSIVE_STEREO,
    NV_MOSAIC_TOPO_END_PASSIVE_STEREO = NV_MOSAIC_TOPO_2x2_PASSIVE_STEREO,

    //
    // Total number of topos.  Always leave this at the end of the enumeration.
    //
    NV_MOSAIC_TOPO_MAX

} NV_MOSAIC_TOPO;


//
// This is a topo brief structure.  It tells you what you need to know about
// a topo at a high level.  A list of these is returned when you query for the
// supported Mosaic information.
//
// If you need more detailed information about the topo, call
// NvAPI_Mosaic_GetTopoGroup() with the topo value from this structure.
//
typedef struct 
{
    NvU32                        version;            // version of this structure
    NV_MOSAIC_TOPO               topo;               // the topo
    NvU32                        enabled;            // 1 if topo is enabled, else 0
    NvU32                        isPossible;         // 1 if topo *can* be enabled, else 0

} NV_MOSAIC_TOPO_BRIEF;

#define NVAPI_MOSAIC_TOPO_BRIEF_VER         MAKE_NVAPI_VERSION(NV_MOSAIC_TOPO_BRIEF,1)


//
// Basic per display settings that are used in setting/getting the Mosaic mode
//
typedef struct 
{
    NvU32                        version;            // version of this structure
    NvU32                        width;              // per display width
    NvU32                        height;             // per display height
    NvU32                        bpp;                // bits per pixel
    NvU32                        freq;               // display frequency
} NV_MOSAIC_DISPLAY_SETTING;

#define NVAPI_MOSAIC_DISPLAY_SETTING_VER         MAKE_NVAPI_VERSION(NV_MOSAIC_DISPLAY_SETTING,1)


//
// Set a reasonable max number of display settings to support
// so arrays are bound.
//
#define NV_MOSAIC_DISPLAY_SETTINGS_MAX 40


//
// This structure is used to contain a list of supported Mosaic topos
// along with the display settings that can be used.
//
typedef struct 
{
    NvU32                       version;                                         // version of this structure
    NvU32                       topoBriefsCount;                                 // number of topos in below array
    NV_MOSAIC_TOPO_BRIEF        topoBriefs[NV_MOSAIC_TOPO_MAX];                  // list of supported topos with only brief details
    NvU32                       displaySettingsCount;                            // number of display settings in below array
    NV_MOSAIC_DISPLAY_SETTING   displaySettings[NV_MOSAIC_DISPLAY_SETTINGS_MAX]; // list of per display settings possible

} NV_MOSAIC_SUPPORTED_TOPO_INFO;

#define NVAPI_MOSAIC_SUPPORTED_TOPO_INFO_VER         MAKE_NVAPI_VERSION(NV_MOSAIC_SUPPORTED_TOPO_INFO,1)


//
// Indexes to use to access the topos array within the mosaic topo
//
#define NV_MOSAIC_TOPO_IDX_DEFAULT       0

#define NV_MOSAIC_TOPO_IDX_LEFT_EYE      0
#define NV_MOSAIC_TOPO_IDX_RIGHT_EYE     1
#define NV_MOSAIC_TOPO_NUM_EYES          2


//
// This defines the maximum number of topos that can be in a topo group.
// At this time, it is set to 2 because our largest topo group (passive
// stereo) only needs 2 topos (left eye and right eye).
//
// If a new topo group with more than 2 topos is added above, then this
// number will also have to be incremented.
//
#define NV_MOSAIC_MAX_TOPO_PER_TOPO_GROUP 2


//
// This structure defines a group of topos that work together to create one
// overall layout.  All of the supported topos are represented with this
// structure.
//
// For example, a 'Passive Stereo' topo would be represented with this
// structure, and would have separate topo details for the left and right eyes.
// The count would be 2.  A 'Basic' topo is also represented by this structure,
// with a count of 1.
//
// The structure is primarily used internally, but is exposed to applications in a
// read only fashion because there are some details in it that might be useful
// (like the number of rows/cols, or connected display information).  A user can
// get the filled in structure by calling NvAPI_Mosaic_GetTopoGroup().
//
// You can then look at the detailed values within the structure.  There are no
// entrypoints which take this structure as input (effectively making it read only).
//
typedef struct 
{
    NvU32                      version;              // version of this structure
    NV_MOSAIC_TOPO_BRIEF       brief;                // the brief details of this topo
    NvU32                      count;                // number of topos in array below
    NV_MOSAIC_TOPO_DETAILS     topos[NV_MOSAIC_MAX_TOPO_PER_TOPO_GROUP];

} NV_MOSAIC_TOPO_GROUP;

#define NVAPI_MOSAIC_TOPO_GROUP_VER         MAKE_NVAPI_VERSION(NV_MOSAIC_TOPO_GROUP,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_GetSupportedTopoInfo
//
// DESCRIPTION:     This API returns information on the topos and display resolutions
//                  supported by Mosaic.
//
//                  NOTE: Not all topos returned can be immediately set.
//                        See 'OUT' Notes below.
//
//                  Once you get the list of supported topos, you can call
//                  NvAPI_Mosaic_GetTopoGroup() with a Mosaic topo if you need
//                  more information about that topo.
//
// PARAMETERS:      pSupportedTopoInfo(IN/OUT):  Information about what topos and display resolutions
//                                               are supported for Mosaic.
//                  type(IN):                    The type of topos the caller is interested in
//                                               getting.  See NV_MOSAIC_TOPO_TYPE for possible
//                                               values.
//  SUPPORTED OS: Windows XP
//
//     'IN' Notes:  pSupportedTopoInfo->version must be set before calling this function.
//                  If the specified version is not supported by this implementation,
//                  an error will be returned (NVAPI_INCOMPATIBLE_STRUCT_VERSION).
//
//     'OUT' Notes: Some of the topos returned might not be valid for one reason or
//                  another.  It could be due to mismatched or missing displays.  It
//                  could also be because the required number of GPUs is not found.
//                  At a high level, you can see if the topo is valid and can be enabled
//                  by looking at the pSupportedTopoInfo->topoBriefs[xxx].isPossible flag.
//                  If this is true, the topo can be enabled.  Otherwise, if it
//                  is false, you can find out why it cannot be enabled by getting the
//                  details of the topo via NvAPI_Mosaic_GetTopoGroup().  From there,
//                  look at the validityMask of the individual topos.  The bits can
//                  be tested against the NV_MOSAIC_TOPO_VALIDITY_* bits.
//
//                  It is possible for this function to return NVAPI_OK with no topos
//                  listed in the return structure.  If this is the case, it means that
//                  the current hardware DOES support Mosaic, but with the given configuration
//                  no valid topos were found.  This most likely means that SLI was not
//                  enabled for the hardware.  Once enabled, you should see valid topos
//                  returned from this function.
//
// RETURN STATUS    NVAPI_OK:                          No errors in returning supported topos
//                  NVAPI_NOT_SUPPORTED:               Mosaic is not supported with the existing hardware
//                  NVAPI_INVALID_ARGUMENT:            One or more args passed in are invalid
//                  NVAPI_API_NOT_INTIALIZED:          The NvAPI API needs to be initialized first
//                  NVAPI_NO_IMPLEMENTATION:           This entrypoint not available
//                  NVAPI_INCOMPATIBLE_STRUCT_VERSION: The version of the structure passed in is not
//                                                     compatible with this entrypoint
//                  NVAPI_ERROR:                       Miscellaneous error occurred
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Mosaic_GetSupportedTopoInfo(NV_MOSAIC_SUPPORTED_TOPO_INFO *pSupportedTopoInfo, NV_MOSAIC_TOPO_TYPE type);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_GetTopoGroup
//
// DESCRIPTION:     This API returns a structure filled with the topo details
//                  for the given Mosaic topo.
//
//                  If the pTopoBrief passed in matches the topo which is
//                  current, then information in the brief and group structures
//                  will reflect what is current.  Thus the brief would have
//                  the current 'enable' status, and the group would have the
//                  current overlap values.  If there is no match, then the
//                  returned brief has an 'enable' status of FALSE (since it
//                  is obviously not enabled), and the overlap values will be 0.
//
// PARAMETERS:      pTopoBrief(IN):         The topo to get details for.
//                                          This must be one of the topo briefs
//                                          returned from NvAPI_Mosaic_GetSupportedTopoInfo().
//                  pTopoGroup(IN/OUT):     The topo details matching the brief.
//
//  SUPPORTED OS: Windows XP
//     'IN' Notes:  pTopoGroup->version must be set before calling this function.
//                  If the specified version is not supported by this implementation,
//                  an error will be returned (NVAPI_INCOMPATIBLE_STRUCT_VERSION).
//
// RETURN STATUS    NVAPI_OK:                          Details were retrieved successfully
//                  NVAPI_NOT_SUPPORTED:               Mosaic is not supported with the existing hardware
//                  NVAPI_INVALID_ARGUMENT:            One or more args passed in are invalid.
//                  NVAPI_API_NOT_INTIALIZED:          The NvAPI API needs to be initialized first
//                  NVAPI_NO_IMPLEMENTATION:           This entrypoint not available
//                  NVAPI_INCOMPATIBLE_STRUCT_VERSION: The version of the structure passed in is not
//                                                     compatible with this entrypoint
//                  NVAPI_ERROR:                       Miscellaneous error occurred
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Mosaic_GetTopoGroup(NV_MOSAIC_TOPO_BRIEF *pTopoBrief, NV_MOSAIC_TOPO_GROUP *pTopoGroup);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_GetOverlapLimits
//
// DESCRIPTION:     This API returns the X and Y overlap limits required if
//                  the given Mosaic topo and display settings are to be used.
//
// PARAMETERS:      pTopoBrief(IN):         The topo to get limits for.
//                                          This must be one of the topo briefs
//                                          returned from NvAPI_Mosaic_GetSupportedTopoInfo().
//                  pDisplaySetting(IN):    The display settings to get limits for.
//                                          This must be one of the settings
//                                          returned from NvAPI_Mosaic_GetSupportedTopoInfo().
//                  pMinOverlapX(OUT):      X overlap minimum
//                  pMaxOverlapX(OUT):      X overlap maximum
//                  pMinOverlapY(OUT):      Y overlap minimum
//                  pMaxOverlapY(OUT):      Y overlap maximum
//
//  SUPPORTED OS: Windows XP
//
//
// RETURN STATUS    NVAPI_OK:                          Details were retrieved successfully
//                  NVAPI_NOT_SUPPORTED:               Mosaic is not supported with the existing hardware
//                  NVAPI_INVALID_ARGUMENT:            One or more args passed in are invalid.
//                  NVAPI_API_NOT_INTIALIZED:          The NvAPI API needs to be initialized first
//                  NVAPI_NO_IMPLEMENTATION:           This entrypoint not available
//                  NVAPI_INCOMPATIBLE_STRUCT_VERSION: The version of the structure passed in is not
//                                                     compatible with this entrypoint
//                  NVAPI_ERROR:                       Miscellaneous error occurred
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Mosaic_GetOverlapLimits(NV_MOSAIC_TOPO_BRIEF *pTopoBrief, NV_MOSAIC_DISPLAY_SETTING *pDisplaySetting, NvS32 *pMinOverlapX, NvS32 *pMaxOverlapX, NvS32 *pMinOverlapY, NvS32 *pMaxOverlapY);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_SetCurrentTopo
//
// DESCRIPTION:     This API sets the Mosaic topo and does a mode change
//                  using the given display settings.
//
//                  If NVAPI_OK is returned, the current Mosaic topo was set
//                  correctly.  Any other status returned means the
//                  topo was not set, and remains what it was before this
//                  function was called.
//
//
//  SUPPORTED OS: Windows XP
//
// PARAMETERS:      pTopoBrief(IN):       The topo to set.
//                                        This must be one of the topos
//                                        returned from NvAPI_Mosaic_GetSupportedTopoInfo(),
//                                        and it must have an isPossible value of 1.
//                  pDisplaySetting(IN):  The per display settings to be used in the
//                                        setting of Mosaic mode.
//                                        This must be one of the settings
//                                        returned from NvAPI_Mosaic_GetSupportedTopoInfo().
//                  overlapX(IN):         The pixel overlap to use between horizontal
//                                        displays (use positive a number for overlap,
//                                        or a negative number to create a gap.)
//                                        If the overlap is out of bounds for what is
//                                        possible given the topo and display setting,
//                                        the overlap will be clamped.
//                  overlapY(IN):         The pixel overlap to use between vertical
//                                        displays (use positive a number for overlap,
//                                        or a negative number to create a gap.)
//                                        If the overlap is out of bounds for what is
//                                        possible given the topo and display setting,
//                                        the overlap will be clamped.
//                  enable(IN):           If 1, the topo being set will also be enabled,
//                                        meaning that the mode set will occur.  
//                                        Passing a 0 means you don't want to be in
//                                        Mosaic mode right now, but want to set the current
//                                        Mosaic topo so you can enable it later with
//                                        NvAPI_Mosaic_EnableCurrentTopo().
//
// RETURN STATUS    NVAPI_OK:                          Mosaic topo was set
//                  NVAPI_NOT_SUPPORTED:               Mosaic is not supported with the existing hardware
//                  NVAPI_INVALID_ARGUMENT:            One or more args passed in are invalid.
//                  NVAPI_TOPO_NOT_POSSIBLE:           The topo passed in is not currently possible
//                  NVAPI_API_NOT_INTIALIZED:          The NvAPI API needs to be initialized first
//                  NVAPI_NO_IMPLEMENTATION:           This entrypoint not available
//                  NVAPI_INCOMPATIBLE_STRUCT_VERSION: The version of the structure passed in is not
//                                                     compatible with this entrypoint
//                  NVAPI_MODE_CHANGE_FAILED:          There was an error changing the display mode
//                  NVAPI_ERROR:                       Miscellaneous error occurred
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Mosaic_SetCurrentTopo(NV_MOSAIC_TOPO_BRIEF *pTopoBrief, NV_MOSAIC_DISPLAY_SETTING *pDisplaySetting, NvS32 overlapX, NvS32 overlapY, NvU32 enable);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_GetCurrentTopo
//
// DESCRIPTION:     This API returns information for the current Mosaic topo.
//                  This includes topo, display settings, and overlap values.
//
//                  You can call NvAPI_Mosaic_GetTopoGroup() with the topo
//                  if you require more information on the topo.
//
//                  If there isn't a current topo, then pTopoBrief->topo will
//                  be NV_MOSAIC_TOPO_NONE.
//
// PARAMETERS:      pTopoBrief(OUT):      The current Mosaic topo
//                  pDisplaySetting(OUT): The current per display settings
//                  pOverlapX(OUT):       The pixel overlap between horizontal displays
//                  pOverlapY(OUT):       The pixel overlap between vertical displays
//
//  SUPPORTED OS: Windows XP
//
// RETURN STATUS    NVAPI_OK:                          Success getting current info
//                  NVAPI_NOT_SUPPORTED:               Mosaic is not supported with the existing hardware
//                  NVAPI_INVALID_ARGUMENT:            One or more args passed in are invalid
//                  NVAPI_API_NOT_INTIALIZED:          The NvAPI API needs to be initialized first
//                  NVAPI_NO_IMPLEMENTATION:           This entrypoint not available
//                  NVAPI_ERROR:                       Miscellaneous error occurred
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Mosaic_GetCurrentTopo(NV_MOSAIC_TOPO_BRIEF *pTopoBrief, NV_MOSAIC_DISPLAY_SETTING *pDisplaySetting, NvS32 *pOverlapX, NvS32 *pOverlapY);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_EnableCurrentTopo
//
// DESCRIPTION:     This API enables or disables the current Mosaic topo
//                  based on the setting of the incoming 'enable' parameter.
//
//                  When enabling, this will enable the current Mosaic topo
//                  that was previously set.  Note that when the current Mosaic
//                  topo is retrieved, it must have an isPossible value of 1 or
//                  an error will occur.
//
//                  When disabling, the current Mosaic topo is disabled.
//                  The topo information will persist, even across reboots.
//                  To re-enable the Mosaic topo, simply call this function
//                  again with the enable parameter set to 1.
//
// PARAMETERS:      enable(IN):               1 to enable the current Mosaic topo, 0 to disable it.
//
//  SUPPORTED OS: Windows XP
//
// RETURN STATUS    NVAPI_OK:                 The Mosaic topo was enabled/disabled
//                  NVAPI_NOT_SUPPORTED:      Mosaic is not supported with the existing hardware
//                  NVAPI_INVALID_ARGUMENT:   One or more args passed in are invalid
//                  NVAPI_TOPO_NOT_POSSIBLE:  The current topo is not currently possible
//                  NVAPI_MODE_CHANGE_FAILED: There was an error changing the display mode
//                  NVAPI_ERROR:              Miscellaneous error occurred
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Mosaic_EnableCurrentTopo(NvU32 enable);





////////////////////////////////////////////////////////////////////////////////////////
//
// ###########################################################################
// DELME_RUSS - DELME_RUSS - DELME_RUSS - DELME_RUSS - DELME_RUSS - DELME_RUSS
//
//   Below is the Phase 1 Mosaic stuff, the Phase 2 stuff above is what will remain
//   once Phase 2 is complete.  For a small amount of time, the two will co-exist.  As
//   soon as apps (nvapichk, NvAPITestMosaic, and CPL) are updated to use the Phase 2
//   entrypoints, the code below will be deleted.
//
// DELME_RUSS - DELME_RUSS - DELME_RUSS - DELME_RUSS - DELME_RUSS - DELME_RUSS
// ###########################################################################
//
//
// Supported topos 1x4, 4x1 and 2x2 to start with.
//
// Selected scanout targets can be one per GPU or more than one on the same GPU.
//
// SAMPLE of MOSAIC 1x4 SCAN OUT TOPO with 8 pixel horizontal overlap
//
//+-------------------------++-------------------------++-------------------------++-------------------------+
//|                         ||                         ||                         ||                         |
//|                         ||                         ||                         ||                         |
//|                         ||                         ||                         ||                         |
//|        DVI1             ||           DVI2          ||         DVI3            ||          DVI4           |
//|                         ||                         ||                         ||                         |
//|                         ||                         ||                         ||                         |
//|                         ||                         ||                         ||                         |
//|                         ||                         ||                         ||                         |
//+-------------------------++-------------------------++-------------------------++-------------------------+

#define NVAPI_MAX_MOSAIC_DISPLAY_ROWS       8
#define NVAPI_MAX_MOSAIC_DISPLAY_COLUMNS    8
#define NVAPI_MAX_MOSAIC_TOPOS              16

typedef struct
{
    NvU32 version;                             // version number of mosaic topology
    NvU32 rowCount;                            // horizontal display count
    NvU32 colCount;                            // vertical display count

    struct
    {
        NvPhysicalGpuHandle hPhysicalGPU;      // physical gpu to be used in the topology
        NvU32               displayOutputId;   // connected display target
        NvS32               overlapX;          // pixels of overlap on left of target: (+overlap, -gap)
        NvS32               overlapY;          // pixels of overlap on top of target: (+overlap, -gap)

    } gpuLayout[NVAPI_MAX_MOSAIC_DISPLAY_ROWS][NVAPI_MAX_MOSAIC_DISPLAY_COLUMNS];

} NV_MOSAIC_TOPOLOGY;

#define NVAPI_MOSAIC_TOPOLOGY_VER         MAKE_NVAPI_VERSION(NV_MOSAIC_TOPOLOGY,1)

typedef struct
{
    NvU32                   version;
    NvU32                   totalCount;                     //count of valid topologies
    NV_MOSAIC_TOPOLOGY      topos[NVAPI_MAX_MOSAIC_TOPOS];  //max topologies

} NV_MOSAIC_SUPPORTED_TOPOLOGIES;

#define NVAPI_MOSAIC_SUPPORTED_TOPOLOGIES_VER         MAKE_NVAPI_VERSION(NV_MOSAIC_SUPPORTED_TOPOLOGIES,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GetSupportedMosaicTopologies
//
// DESCRIPTION:     This API returns all valid Mosaic topologies
//
//  SUPPORTED OS: Windows XP
//
// PARAMETERS:      pMosaicTopos(OUT):  An array of valid Mosaic topologies.
//
// RETURN STATUS    NVAPI_OK:                      Call succeeded; 1 or more topologies were returned
//                  NVAPI_INVALID_ARGUMENT:        one or more args are invalid
//                  NVAPI_MIXED_TARGET_TYPES:      Mosaic topology is only possible with all targets of the same NV_GPU_OUTPUT_TYPE.
//                  NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//                  NVAPI_NOT_SUPPORTED:           Mosaic is not supported with GPUs on this system.
//                  NVAPI_NO_ACTIVE_SLI_TOPOLOGY:  SLI is not enabled, yet needs to be, in order for this function to succeed.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetSupportedMosaicTopologies(NV_MOSAIC_SUPPORTED_TOPOLOGIES *pMosaicTopos);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GetCurrentMosaicTopology
//
// DESCRIPTION:     This API gets the current Mosaic topology
//
//  SUPPORTED OS: Windows XP
//
// PARAMETERS:      pMosaicTopo(OUT):  The current Mosaic topology
//                  pEnabled(OUT):     TRUE if returned topology is currently enabled, else FALSE
//
// RETURN STATUS    NVAPI_OK:                       Call succeeded.
//                  NVAPI_INVALID_ARGUMENT:         one or more args are invalid
//                  NVAPI_NVIDIA_DEVICE_NOT_FOUND:  no NVIDIA GPU driving a display was found
//                  NVAPI_NOT_SUPPORTED:            Mosaic is not supported with GPUs on this system.
//                  NVAPI_NO_ACTIVE_SLI_TOPOLOGY:   SLI is not enabled, yet needs to be, in order for this function to succeed.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetCurrentMosaicTopology(NV_MOSAIC_TOPOLOGY *pMosaicTopo, NvU32 *pEnabled);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_SetCurrentMosaicTopology
//
// DESCRIPTION:     This API sets the Mosaic topology, and will enable it so the
//                  Mosaic display settings will be enumerated upon request.
//
//  SUPPORTED OS: Windows XP
//
// PARAMETERS:      pMosaicTopo(IN):  A valid Mosaic topology
//
// RETURN STATUS    NVAPI_OK:                      Call succeeded
//                  NVAPI_INVALID_ARGUMENT:        One or more args are invalid
//                  NVAPI_NVIDIA_DEVICE_NOT_FOUND: No NVIDIA GPU driving a display was found
//                  NVAPI_NOT_SUPPORTED:           Mosaic mode could not be set
//                  NVAPI_NO_ACTIVE_SLI_TOPOLOGY:  SLI is not enabled, yet needs to be, in order for this function to succeed.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetCurrentMosaicTopology(NV_MOSAIC_TOPOLOGY *pMosaicTopo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_EnableCurrentMosaicTopology
//
// DESCRIPTION:     This API enables or disables the current Mosaic topology.
//                  When enabling, this will use the last Mosaic topology that was set.
//                  If enabled, enumeration of display settings will include valid
//                  Mosaic resolutions.  If disabled, enumeration of display settings
//                  will not include Mosaic resolutions.
//
//  SUPPORTED OS: Windows XP
//
// PARAMETERS:      enable(IN):  TRUE to enable the Mosaic Topology, FALSE to disable it.
//
// RETURN STATUS    NVAPI_OK:                      Call succeeded
//                  NVAPI_INVALID_ARGUMENT:        One or more args are invalid
//                  NVAPI_NVIDIA_DEVICE_NOT_FOUND: No NVIDIA GPU driving a display was found
//                  NVAPI_NOT_SUPPORTED:           Mosaic mode could not be enabled/disabled
//                  NVAPI_NO_ACTIVE_SLI_TOPOLOGY:  SLI is not enabled, yet needs to be, in order for this function to succeed.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_EnableCurrentMosaicTopology(NvU32 enable);



#define NV_IMP_INTERLACED                         0
#define NV_IMP_PROGRESSIVE                        1
#define NV_IMP_VERTICAL_TAPS1                     2
#define NV_IMP_VERTICAL_TAPS2                     3
#define NV_IMP_VERTICAL_TAPS3                     4
#define NV_IMP_VERTICAL_TAPS3_ADAPTIVE            5
#define NV_IMP_VERTICAL_TAPS5                     6
#define NV_IMP_HORIZONTAL_TAPS1                   7
#define NV_IMP_HORIZONTAL_TAPS2                   8
#define NV_IMP_HORIZONTAL_TAPS8                   9
#define NV_IMP_FORMAT_I8                          10
#define NV_IMP_FORMAT_VOID16                      11
#define NV_IMP_FORMAT_VOID32                      12
#define NV_IMP_FORMAT_RF16_GF16_BF16_AF16         13
#define NV_IMP_FORMAT_A8R8G8B8                    14
#define NV_IMP_FORMAT_A2B10G10R10                 15
#define NV_IMP_FORMAT_A8B8G8R8                    16
#define NV_IMP_FORMAT_R5G6B5                      17
#define NV_IMP_FORMAT_A1R5G5B5                    18
#define NV_IMP_SS_X1AA                            19
#define NV_IMP_SS_X4AA                            20
#define NV_IMP_BASE_USAGE_BOUNDS_USABLE_CURRENT   21
#define NV_IMP_BASE_USAGE_BOUNDS_USABLE_NO        22
#define NV_IMP_BASE_USAGE_BOUNDS_USABLE_YES       23
#define NV_IMP_BASE_USAGE_BOUNDS_DEPTH_CURRENT    24
#define NV_IMP_BASE_USAGE_BOUNDS_DEPTH_8          25
#define NV_IMP_BASE_USAGE_BOUNDS_DEPTH_16         26
#define NV_IMP_BASE_USAGE_BOUNDS_DEPTH_32         27
#define NV_IMP_BASE_USAGE_BOUNDS_DEPTH_64         28
#define NV_IMP_BASE_USAGE_BOUNDS_SS_CURRENT       29
#define NV_IMP_BASE_USAGE_BOUNDS_SS_X1AA          30
#define NV_IMP_BASE_USAGE_BOUNDS_SS_X4AA          31

typedef struct _NV_IMP_MODE
{
    NvU32 PixelClock;
    NvU32 RasterWidth;
    NvU32 RasterHeight;
    NvU32 RasterBlankStartX;
    NvU32 RasterBlankStartY;
    NvU32 RasterBlankEndX;
    NvU32 RasterBlankEndY;
    NvU32 RasterVertBlank2YStart;
    NvU32 RasterVertBlank2YEnd;
    NvU32 ViewportOutWidth;
    NvU32 ViewportOutHeight;
    NvU32 ViewportOutMinWidth;
    NvU32 ViewportOutMinHeight;
    NvU32 ViewportInWidth;
    NvU32 ViewportInHeight;

    NvU32 OverlayBpp;

    NvU32 Interlaced;

    struct
    {
        NvU32 VerticalTaps;
        NvU32 HorizontalTaps;
    } OutputScaler;

    struct
    {
        NvU32 Format;
        NvU32 SuperSample;
    } Params;

    struct
    {
        NvU32 Usable;
        NvU32 PixelDepth;
        NvU32 SuperSample;
    } BaseUsageBounds;
} NV_IMP_MODE;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Disp_ConstructIMPMode
//
// PARAMETERS:    pDispPath    (IN)  - Pointer to a display path
//                pIMPMode     (OUT) - IMP version of display path
//
//
//    FOR INTERNAL TOOL USE ONLY
//
//
//  SUPPORTED OS: Mac OS X, Windows Vista and higher
// DESCRIPTION:   This function will convert the mode data from the
//                pDispPath input to the display driver version of the
//                IMP structure used for IsModePossible calls.
//
// RETURN STATUS:
//                NVAPI_OK                  - completed request
//                NVAPI_API_NOT_INITIALIZED - nvapi not initialized
//                NVAPI_ERROR               - miscellaneous error occurred
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Disp_ConstructIMPMode(NV_DISP_PATH *pPath, NV_IMP_MODE *pIMPMode);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_IsModePossible
//
// PARAMETERS:    nvGPUHandle(IN)          - GPU selection
//                mode(IN)                 - array of modes; one per head
//                modeCount(IN)            - number of modes in the array
//                impResult(OUT)           - boolean: zero=mode not possible, one=mode possible
//
// DESCRIPTION:   Given a list of modes (one per head), return if the configuration is possible.
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: NVAPI_API_NOT_INTIALIZED: You must call NvAPI_Initialize first.
//                NVAPI_ERROR: One of three things went wrong:
//                             1. modeCount is zero
//                             2. A value in the NV_IMP_MODE structure is invalid
//                             3. The RM control call failed
//                NVAPI_NO_IMPLEMENTATION: Only available for up to two heads.
//                NVAPI_OK: impResult holds the return value.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_IsModePossible(NvPhysicalGpuHandle nvGPUHandle, NV_IMP_MODE *mode, NvU32 modeCount, NvU8 *impResult);

#define NV_MAX_LINES_PER_IMP_LOG_ENTRY                     180
#define NV_FLAGS_CMDLINE_SHOW_IMPOSSIBLE_ENTRIES_ONLY      0x01
#define NV_FLAGS_CMDLINE_SHOW_POSSIBLE_ENTRIES_ONLY        0x02
#define NV_FLAGS_CMDLINE_READ_LAST_N_ENTRIES               0x04
#define NV_FLAGS_CMDLINE_RESET_IMP_LOG_ONLY                0x08

typedef struct _NV_IMP_LOG_ENTRY
{
    NvU32 lineCount;
    NvAPI_ShortString line[NV_MAX_LINES_PER_IMP_LOG_ENTRY];
} NV_IMP_LOG_ENTRY;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DIAG_GetIsModePossibleLog
//
// PARAMETERS:    nvGPUHandle(IN)          - GPU selection
//                pTextLog(OUT)            - Array of IMP Log entries in text format
//                pCount(IN/OUT)           - Number of IMP Log entries
//                nCount(IN)               - Number of recent entries to return 
//                flags(IN)                - Flags defining which entries to return
//
// DESCRIPTION:   When called with pTextLog = NULL, returns the number of IMP log entries in pCount.
//                When called with a valid pointer in pTextLog and non zero value through pCount, returns the array of log entries
//                based on the value of flags:
//                flags = 0 : Return all entries 
//                flags = 1 : Return impossible entries only
//                            (NV_FLAGS_CMDLINE_SHOW_IMPOSSIBLE_ENTRIES_ONLY)
//                flags = 2 : Return possible entries only
//                            (NV_FLAGS_CMDLINE_SHOW_POSSIBLE_ENTRIES_ONLY)
//                flags = 4 : Return last nCount entries
//                            (NV_FLAGS_CMDLINE_READ_LAST_N_ENTRIES)
//                flags = 5 : Return last nCount impossible entries only
//                            (NV_FLAGS_CMDLINE_READ_LAST_N_ENTRIES | NV_FLAGS_CMDLINE_SHOW_IMPOSSIBLE_ENTRIES_ONLY)
//                flags = 6 : Return last nCount possible entries only
//                            (NV_FLAGS_CMDLINE_READ_LAST_N_ENTRIES | NV_FLAGS_CMDLINE_SHOW_POSSIBLE_ENTRIES_ONLY)
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_API_NOT_INTIALIZED: You must call NvAPI_Initialize first.
//                NVAPI_ERROR:              miscellaneous error occurred
//                NVAPI_NOT_SUPPORTED       this feature is not supported on this GPU
//                NVAPI_OK:                 completed request.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DIAG_GetIsModePossibleLog(NvPhysicalGpuHandle nvGPUHandle, NV_IMP_LOG_ENTRY *pTextLog, NvU32 *pCount, NvU32 nCount, NvU32 flags);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetBaseChannelLutUsage
//
// PARAMETERS:    hNvDisplay(IN)              - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated
//                                              from NvAPI_EnumNVidiaDisplayHandle().
//                p (OUT)                     - pointer of an enum type data(NV_BASE_CHANNEL_LUT_STATUS) for output
//
// DESCRIPTION:   this function returns the current status of the base channel LUT usage(disable/enable/use_core_lut)
//
//  SUPPORTED OS: Windows Vista and higher
//
// RETURN STATUS: NVAPI_API_NOT_INTIALIZED: You must call NvAPI_Initialize first.
//                NVAPI_ERROR:              miscellaneous error occurred
//                NVAPI_OK:                 completed request.
//
///////////////////////////////////////////////////////////////////////////////

typedef enum
{
    NV_BASE_CHANNEL_LUT_DISABLE      = 0,
    NV_BASE_CHANNEL_LUT_USE_CORE_LUT = 1,
    NV_BASE_CHANNEL_LUT_ENABLE       = 3,
} NV_BASE_CHANNEL_LUT_USAGE;

NVAPI_INTERFACE NvAPI_GetBaseChannelLutUsage(NvDisplayHandle hNvDisplay, NV_BASE_CHANNEL_LUT_USAGE *p);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SetBaseChannelLutUsage
//
// PARAMETERS:    hNvDisplay(IN)              - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated
//                                              from NvAPI_EnumNVidiaDisplayHandle().
//                usage (IN)                  - enum type input data (NV_BASE_CHANNEL_LUT_USAGE).
//
// DESCRIPTION:   this function set the base channel Lut usage
//
//  SUPPORTED OS: Windows Vista and higher
//
// RETURN STATUS: NVAPI_API_NOT_INTIALIZED: You must call NvAPI_Initialize first.
//                NVAPI_ERROR:              miscellaneous error occurred
//                NVAPI_OK:                 completed request.
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_SetBaseChannelLutUsage(NvDisplayHandle hNvDisplay, NV_BASE_CHANNEL_LUT_USAGE usage);


typedef enum
{
    NV_DISPLAY_CRC_CONTROL_CHANNEL_CORE,
    NV_DISPLAY_CRC_CONTROL_CHANNEL_BASE,
    NV_DISPLAY_CRC_CONTROL_CHANNEL_OVERLAY,
    NV_DISPLAY_CRC_CONTROL_CHANNEL_COUNT     // always last
} NV_DISPLAY_CRC_CONTROL_CHANNEL;

typedef NvU32 NV_DISPLAY_CRC_CONTROL;
#define NV_DISPLAY_CRC_CONTROL_EXPECT_BUFFER_COLLAPSE    (1 << 0)
#define NV_DISPLAY_CRC_CONTROL_TIMESTAMP_MODE            (1 << 1)
#define NV_DISPLAY_CRC_CONTROL_FLIP_LOCK_MODE            (1 << 2)
#define NV_DISPLAY_CRC_CONTROL_CRC_DURING_SNOOZE         (1 << 3)
#define NV_DISPLAY_CRC_CONTROL_LEGACY_COMPUTE            (1 << 4)
#define NV_DISPLAY_CRC_CONTROL_ACTIVE_RASTER             (1 << 5)
#define NV_DISPLAY_CRC_CONTROL_COMPLETE_RASTER           (1 << 6)
#define NV_DISPLAY_CRC_CONTROL_NON_ACTIVE_RASTER         (1 << 7)

typedef struct _NV_DISPLAY_CRC_CONFIG
{
    NV_DISPLAY_CRC_CONTROL            crcControl;
    NV_DISPLAY_CRC_CONTROL_CHANNEL    controlChannel;
} NV_DISPLAY_CRC_CONFIG;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SetDisplayCrcConfig
//
// PARAMETERS:    nvGPUHandle(IN)          - GPU selection
//                displayOutputId(IN)      - Display output ID
//                pDisplayCrcConfig(IN)    - Crc configuration
//
// DESCRIPTION:   Configure and start the CRC collection on the display
//                output of the requested GPU.
//
//  SUPPORTED OS: Windows Vista and higher
//
// RETURN STATUS: NVAPI_API_NOT_INTIALIZED: must call NvAPI_Initialize first.
//                NVAPI_ERROR:
//                NVAPI_OK: successfully configured the CRC notifier.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetDisplayCrcConfig(NvPhysicalGpuHandle nvGPUHandle, NvU32 displayOutputId, NV_DISPLAY_CRC_CONFIG *pDisplayCrcConfig);

typedef NvU32 NV_DISPLAY_CRC_ENTRY_FLAG;
#define NV_DISPLAY_CRC_ENTRY_FLAG_TIMESTAMP_MODE        (1 << 0)
#define NV_DISPLAY_CRC_ENTRY_FLAG_HW_FLIP_LOCK_MODE      (1 << 1)
#define NV_DISPLAY_CRC_ENTRY_FLAG_PRESENT_INTERVAL_MET  (1 << 2)

typedef struct _NV_DISPLAY_CRC_ENTRY
{
    NV_DISPLAY_CRC_ENTRY_FLAG    flag;
    NvU32                        auditTimeStamp;
    NvU32                        tag;
    NvU32                        compositorCrc;
    NvU32                        primaryOutputCrc;
    NvU32                        secondaryOutputCrc;
} NV_DISPLAY_CRC_ENTRY;

typedef NvU32 NV_DISPLAY_CRC_STATUS;
#define NV_DISPLAY_CRC_STATUS_DONE                      (1 << 0)
#define NV_DISPLAY_CRC_STATUS_OVERRUN                   (1 << 1)
#define NV_DISPLAY_CRC_STATUS_DSI_OVERFLOW              (1 << 2)
#define NV_DISPLAY_CRC_STATUS_COMPOSITOR_OVERFLOW       (1 << 3)
#define NV_DISPLAY_CRC_STATUS_PRIMARY_OUTPUT_OVERFLOW   (1 << 4)
#define NV_DISPLAY_CRC_STATUS_SECONDARY_OUTPUT_OVERFLOW (1 << 5)
#define NV_DISPLAY_CRC_STATUS_EXPECT_BUFFER_COLLAPSE    (1 << 6)
#define NV_DISPLAY_CRC_STATUS_BUSY                      (1 << 7)

typedef struct _NV_DISPLAY_CRC_DATA_STATUS
{
    NV_DISPLAY_CRC_STATUS   crcStatus;       // status of the data read
    NvU32                   readEntryCount;  // number of entry read
} NV_DISPLAY_CRC_DATA_STATUS;


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_ReadDisplayCrcData
//
// PARAMETERS:    nvGPUHandle(IN)          - GPU selection
//                displayOutputId(IN)      - Display output selection
//                pCrcEntry(OUT)           - CRC data
//
// DESCRIPTION:   Read one CRC entry from the output display of the requested GPU.
//
//  SUPPORTED OS: Windows Vista and higher
//
// RETURN STATUS: NVAPI_API_NOT_INTIALIZED: You must call NvAPI_Initialize first.
//                NVAPI_ERROR:
//                NVAPI_OK: impResult holds the return value.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_ReadDisplayCrcData(NvPhysicalGpuHandle nvGPUHandle, NvU32 displayOutputId, NV_DISPLAY_CRC_DATA_STATUS *pCrcDataStatus, NV_DISPLAY_CRC_ENTRY *pCrcEntryArray, NvU32 arrayEntryCount);


#define NVAPI_MAX_3D_Apps 128
// Structure to get both processIds and processNames
typedef struct
{
  NvU32 version;    // Structure version
  NvU32 processId;
  NvAPI_ShortString   processName;
}NV_3D_APP_INFO;

#define NV_3D_APP_INFO_VER  MAKE_NVAPI_VERSION(NV_3D_APP_INFO,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_QueryNonMigratableApps
//
// PARAMETERS:      apps(IN/OUT)       -Empty structure passed as an input and upon successfull exit, it contains list of nonmigratable apps and processIDs.
//                  total(IN/OUT)      -Total number of nonmigratable apps currently running in the system.
// DESCRIPTION:     Query all non-migratable apps which can block successful driver reload like SLI or Hybrid transition.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_QueryNonMigratableApps(NV_3D_APP_INFO apps[NVAPI_MAX_3D_Apps] , NvU32 *total);

typedef struct
{
  NvU32 version;    // Structure version
  NvAPI_LongString   appName;
  NvAPI_LongString   friendlyName;
}NV_HYBRID_APP_INFO;

#define NV_HYBRID_APP_INFO_VER  MAKE_NVAPI_VERSION(NV_HYBRID_APP_INFO,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Hybrid_QueryUnblockedNonMigratableApps
//
// PARAMETERS:      apps(IN/OUT)     -Empty structure passed as an input and upon successfull exit, it contains list of Unblocked(user white-list) applications..
//                  total(IN/OUT)    -Total number of applications returned from the white list.
// DESCRIPTION:     Query the user-white list applications for Hybrid transition
//
//  SUPPORTED OS: Windows Vista and higher
//
// RETURN STATUS:
//                  NVAPI_OK - completed request.
//                  NVAPI_ERROR - miscellaneous error occurred.
//                  NVAPI_INVALID_ARGUMENT - invalid input parameter.
//                  NVAPI_NO_IMPLEMENTATION - not implemented.
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Hybrid_QueryUnblockedNonMigratableApps(NV_HYBRID_APP_INFO apps[NVAPI_MAX_3D_Apps] , NvU32 *total);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Hybrid_QueryBlockedMigratableApps
//
// PARAMETERS:      apps(IN/OUT)     -Empty structure passed as an input and upon successfull exit, it contains list of blocked(user black-list) applications..
//                  total(IN/OUT)    -Total number of applications returned from the black list.
// DESCRIPTION:     Query the user-black list applications for Hybrid transition
//
//  SUPPORTED OS: Windows Vista and higher
//
// RETURN STATUS:
//                  NVAPI_OK - completed request.
//                  NVAPI_ERROR - miscellaneous error occurred.
//                  NVAPI_INVALID_ARGUMENT - invalid input parameter.
//                  NVAPI_NO_IMPLEMENTATION - not implemented.
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Hybrid_QueryBlockedMigratableApps(NV_HYBRID_APP_INFO apps[NVAPI_MAX_3D_Apps] , NvU32 *total);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Hybrid_SetAppMigrationState
//
// PARAMETERS:      app(IN) - application executable name that is to be blocked, unblocked, reset or removed
//                  flag(IN) -decides on the block, unblock, reset or remove operation.
//                            block =0, unblock =1, reset =2, remove =3
// DESCRIPTION:     Override the pre-determined application migration state.
//
//  SUPPORTED OS: Windows Vista and higher
//
// RETURN STATUS:
//                  NVAPI_OK - completed request.
//                  NVAPI_ERROR - miscellaneous error occurred.
//                  NVAPI_INVALID_ARGUMENT - invalid input parameter.
//                  NVAPI_SET_NOT_ALLOWED - the application list override is not allowed.  
//                  NVAPI_NO_IMPLEMENTATION - not implemented.
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Hybrid_SetAppMigrationState(NV_HYBRID_APP_INFO app , NvU32 flag);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Hybrid_IsAppMigrationStateChangeable
//
// PARAMETERS:      app(IN) - application executable name which user is querying about
//                  allowed(OUT) -Change in migration state of app is allowed or not.
//                                not_allowed =0, allowed =1
// DESCRIPTION:     Query if an application's migration state can be changed by the user.
//
//  SUPPORTED OS: Windows Vista and higher
//
// RETURN STATUS:
//                  NVAPI_OK - completed request.
//                  NVAPI_ERROR - miscellaneous error occurred.
//                  NVAPI_INVALID_ARGUMENT - invalid input parameter.
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Hybrid_IsAppMigrationStateChangeable(NV_HYBRID_APP_INFO app , NvU32 *allowed);

typedef enum
{
    NV_SET_HYBRID_MODE_DEFER_NON_MIGRATABLE_APP_SHUTDOWN    = 0x00000001,//calling application will control the shutdown of non-migratable applications holding hw resources
} NV_SET_HYBRID_MODE_FLAGS;
///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SetHybridModeEx
//
// DESCRIPTION:     This API will support elevated transition if the app does not run on elevated mode.
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      mode(IN)     - hybrid mode
//                  flags(IN)    - flags indicates additional control.
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_SetHybridModeEx(NV_HYBRID_MODE mode, NvU32 flags);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_InitHybridMicroController
//
//   DESCRIPTION: Initialize hybrid ucontroller
//
//  SUPPORTED OS: Windows Vista and higher
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_InitHybridMicroController();

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetPowerConnectorStatus
//
// PARAMETERS:      hPhysicalGpu(IN)        - GPU selection.
//                  pConnectorCount(OUT)    - number of the power connector(s) present on the GPU Board
//                  pConnectionAtBoot(OUT)  - mask of the power connector(s) connected at the boot time
//                  pCurrentConnection(OUT) - mask of the power connector(s) connected currently
//
// DESCRIPTION:     This API provides the number of external power connector(s) on the gpu board
//                  and their connection status.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//                  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPowerConnectorStatus(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pConnectorCount, NvU32 *pConnectionAtBoot, NvU32 *pCurrentConnection);


typedef enum
{
    NV_GPU_NETLIST_REV0 = 0x00000012,
    NV_GPU_NETLIST_REV1 = 0x00000013
} NV_GPU_NETLIST_REV;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetNetlistIdentifier
//
// PARAMETERS:      hPhysicalGpu(IN) - GPU selection.
//                  revIndex(IN)     - Rev index to specify the emulation register.
//                  pValue(OUT)      - Pointer to a variable to get the netlist data value from rev index passed. 
//                     
// DESCRIPTION:     This API gets the netlist data values from emulation registers.
//
//  SUPPORTED OS: Windows XP and higher
//
// HOW TO USE:      NV_GPU_NETLIST_REV index= NV_GPU_NETLIST_REV0 or NV_GPU_NETLIST_REV1;
//                  ret = NvAPI_GPU_GetNetlistIdentifier(hPhysicalGpu, index, &Value);  
//                  On call success:
//                  ValReg would contain the netlist data value corresponding to the index passed   
//
// RETURN STATUS: 
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_NOT_SUPPORTED - functionality not supported 
//                  NVAPI_INVALID_HANDLE - physical GPU not found
//                  NVAPI_INVALID_ARGUMENT - invalid arugument passed
//                  NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//                  NVAPI_API_NOT_INITIALIZED - nvapi not initialized
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetNetlistIdentifier(NvPhysicalGpuHandle nvGPUHandle, NV_GPU_NETLIST_REV revIndex, NvU32 *pValue);


///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_EnumGSyncDevices
//
//   DESCRIPTION: Returns an array of GSync Device handles. A GSync Device handle represents a 
//                single GSync device on the system.
//
//    PARAMETERS: nvGSyncHandles[OUT] - The caller provides an array of handles, which must contain at least 
//                NVAPI_MAX_GSYNC_DEVICES elements. The API will zero out the entire array and then fill in one
//                or more handles. If an error occurs, the array is invalid.
//
//                *gsyncCount[OUT] - The caller provides the storage space. NvAPI_EnumGSyncDevices
//                sets *gsyncCount to indicate how many of the elements in the nvGSyncHandles[] array are valid.
//                If an error occurs, *gsyncCount will be set to zero.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: nvGSyncHandles or gsyncCount is NULL.
//                NVAPI_OK: One or more handles were returned.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: The queried Graphics system does not have any GSync Device.
//                NVAPI_ERROR: The operation failed.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_EnumGSyncDevices(NvGSyncDeviceHandle nvGSyncHandles[NVAPI_MAX_GSYNC_DEVICES], NvU32 *gsyncCount);


//Indicate the number of decimal places of accuracy that the gsync board supports when reporting/accepting refresh rates
#define NVAPI_GSYNC_CAPS_FLAG_FREQ_ACCURACY_2DPS  (0x00000001)
#define NVAPI_GSYNC_CAPS_FLAG_FREQ_ACCURACY_3DPS  (0x00000002)
#define NVAPI_GSYNC_CAPS_FLAG_FREQ_ACCURACY_4DPS  (0x00000004)

//Indicate the types of events that the gsync board can report back to the client
#define NVAPI_GSYNC_CAPS_FLAG_SYNC_LOCK_EVENT     (0x80000000)
#define NVAPI_GSYNC_CAPS_FLAG_HOUSE_SYNC_EVENT    (0x40000000)
#define NVAPI_GSYNC_CAPS_FLAG_FRAME_COUNT_EVENT   (0x20000000)

//gsync boardId values
#define NVAPI_GSYNC_BOARD_ID_P154 340 // 0x154
#define NVAPI_GSYNC_BOARD_ID_P294 660 // 0x294
#define NVAPI_GSYNC_BOARD_ID_P358 856 // 0x358 

typedef struct
{
    NvU32   version;
    NvU32   revId;      //FPGA Revision (low 4 bits) and Board ID (high 4 bits)
    NvU32   boardId;    //Board ID
    NvU32   revision;   //FPGA Revision
    NvU32   capFlags;   //Capabilities of the GSync board
    NvU32   maxSyncSkew;  //maximum units of sync skew the board supports
    NvU32   syncSkewResolution; //number of nanoseconds that one unit of sync skew corresponds to
    NvU32   maxStartDelay; //maximum units of sync start delay the board supports
    NvU32   startDelayResolution; // number of nanoseconds that one unit of sync start delay corresponds to 
} NV_GSYNC_CAPABILITIES;

#define NV_GSYNC_CAPABILITIES_VER  MAKE_NVAPI_VERSION(NV_GSYNC_CAPABILITIES,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_QueryCapabilities
//
//   DESCRIPTION: Returns the capabilities of the GSync device
//
//    PARAMETERS: hNvGSyncDevice[IN] - The caller provides the handle for a GSync device for which the capabilities will
//                be queried.
//
//                *pNvGSyncCapabilities[OUT] - The caller provides the storage space. NvAPI_GSync_QueryCapabilities sets *pNvGSyncCapabilities
//                to the version and capabilities details of the GSync device
//                If an error occurs, *pNvGSyncCapabilities will be set to NULL.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hNvGSyncDevice is NULL.
//                NVAPI_OK: *pNvGSyncCapabilities was populated.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: The queried Graphics system does not have any GSync Device.
//                NVAPI_ERROR: The operation failed.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GSync_QueryCapabilities(NvGSyncDeviceHandle hNvGSyncDevice, NV_GSYNC_CAPABILITIES *pNvGSyncCapabilities);


#define NVAPI_MAX_GPUS_PER_GSYNC                    4
//Connector values for a GPU.
typedef enum 
{
    NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_NONE         = 0,
    NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_PRIMARY      = 1,
    NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_SECONDARY    = 2,
} NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR;

//Display sync states
typedef enum
{
    NVAPI_GSYNC_DISPLAY_SYNC_STATE_UNSYNCED         = 0,
    NVAPI_GSYNC_DISPLAY_SYNC_STATE_SLAVE            = 1,
    NVAPI_GSYNC_DISPLAY_SYNC_STATE_MASTER           = 2,
} NVAPI_GSYNC_DISPLAY_SYNC_STATE;

typedef struct
{
    NvU32                               version;
    NvPhysicalGpuHandle                 hPhysicalGpu;       //GPU handle
    NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR  connector;          //Indicates which connector on the device the GPU is connected to
    NvPhysicalGpuHandle                 hProxyPhysicalGpu;  //GPU thru which hPhysicalGpu is connected to the GSync device (if not directly connected)
                                                            // - this is NULL otherwise
    NvU32                               bIsSynced;          //Whether this GPU is synced or not.
    NvU32                               displayCount;
    struct 
    {
        NvDisplayHandle                 hNvDisplay;         //Handle for display (May be common for multiple displays if not in single view mode)
        NvU32                           displayMask;        //(So the mask will distinguish among them)
        NvU32                           bIsMasterable;      //Can this display be the master? (Retrieved with topology)
        NVAPI_GSYNC_DISPLAY_SYNC_STATE  syncState;          //Is this display unsynced/slave/master
                                                            //(Retrieved with topology or set by caller for enable/disable sync)
    } nvDisplays[NV_MAX_HEADS];     //May have 0 elements if no displays connected to GPU
                                    // - And, this array needs to have at least one element when enabling / disabling sync.
} NV_GSYNC_TOPOLOGY_TARGET;

#define NV_GSYNC_TOPOLOGY_TARGET_VER  MAKE_NVAPI_VERSION(NV_GSYNC_TOPOLOGY_TARGET,1)

typedef struct
{
    NvU32                       version;
    NvU32                       gsyncTargetCount;                       //How many GSync targets are valid
    NV_GSYNC_TOPOLOGY_TARGET    gsyncTarget[NVAPI_MAX_GPUS_PER_GSYNC];  //Array of GSync targets
} NV_GSYNC_TOPOLOGY;

#define NV_GSYNC_TOPOLOGY_VER  MAKE_NVAPI_VERSION(NV_GSYNC_TOPOLOGY,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_QueryTopology
//
//   DESCRIPTION: Returns the topology for the specified GSync device. 
//
//                Note: Display handles can get invalidated on a modeset, so the calling applications need to 
//                requery the topology after every modeset.
//
//    PARAMETERS: hNvGSyncDevice[IN] - The caller provides the handle for a GSync device for which the topology will
//                be queried.
//
//  SUPPORTED OS: Windows XP and higher
//
//                *pNvGPUTopology[OUT] - The caller provides the storage space. NvAPI_GSync_QueryTopology sets *pNvGPUTopology
//                to an object containing an array of all GPUs connected to the GSync device, their connectors, handles of their
//                proxy GPUs(handle of GPU through which a GPU is connected to the GSync device) and displays on each GPU
//                If an error occurs, *pNvGPUTopology will be set to NULL.
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hNvGSyncDevice is NULL.
//                NVAPI_OK: *pNvGPUTopology was populated.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: The queried Graphics system does not have any GSync Device.
//                NVAPI_ERROR: The operation failed.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GSync_QueryTopology(NvGSyncDeviceHandle hNvGSyncDevice, NV_GSYNC_TOPOLOGY *pNvGPUTopology);


#define NVAPI_MAX_RJ45_PER_GSYNC    2

typedef struct
{
    NvU32   version;
    NvU32   RJ45[NVAPI_MAX_RJ45_PER_GSYNC];     //The RJ45 signals in Hz
    NvU32   house;                              //House sync signal in Hz
} NV_GSYNC_STATUS_SIGNALS;

#define NV_GSYNC_STATUS_SIGNALS_VER  MAKE_NVAPI_VERSION(NV_GSYNC_STATUS_SIGNALS,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_QueryStatusSignals
//
//   DESCRIPTION: Returns the status signals for the RJ45 and house sync in the specified GSync device
//
//    PARAMETERS: hNvGSyncDevice[IN] - The caller provides the handle for a GSync device for which the status signals will
//                be queried.
//
//                *pNvGSyncStatusSignals[OUT] - The caller provides the storage space. NvAPI_GSync_QueryStatusSignals sets *pNvGSyncStatusSignals
//                to the values of the RJ45 and house sync. House = 0 => No signal and RJ45 = ~0 => Signal detected, but no rate info available
//                If an error occurs, *pNvGSyncStatusSignals will be set to NULL.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hNvGSyncDevice is NULL.
//                NVAPI_OK: *pNvGSyncStatusSignals was populated.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: The queried Graphics system does not have any GSync Device.
//                NVAPI_ERROR: The operation failed.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GSync_QueryStatusSignals(NvGSyncDeviceHandle hNvGSyncDevice, NV_GSYNC_STATUS_SIGNALS *pNvGSyncStatusSignals);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_Signal_Event
//
//   DESCRIPTION: Signal events coming from kmd/rm back to kmd to allow 
//                further processing at kmd.
//
//    PARAMETERS: hNvGSyncDevice[IN] - The caller provides the handle of the GSync device on 
//                which the provided GPU is located
//
//                eventFlags[IN] - Notification flags (see ctrl30f1.h)
//
//                
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_OK: completed request.
//                NVAPI_ERROR: The operation failed.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GSync_Signal_Event(NvGSyncDeviceHandle hNvGSyncDevice, NvU32 eventFlags);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_EnableSync
//
//   DESCRIPTION: Syncs the displays (as master or slaves) at the refresh rate provided.
//
//    PARAMETERS: hNvGSyncDevice[IN] - The caller provides the handle of the GSync device on which the provided GPU is located
//
//                refreshRate[IN] - The caller provides the desired refresh rate to be synced at. The value is in 0.0001 Hertz
//
//                *pNvGTopologyTarget[IN|OUT] - The caller provides the structure containing the GPU, and the
//                displays on the GPU to be synced. Any display not synced will cause the corresponding handle in the structure
//                to become NULL.
//                If an error occurs, *pNvGTopologyTarget will be set to NULL.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hNvGSyncDevice is NULL / pNvGTopologyTarget is NULL.
//                NVAPI_OK: Master display and/or slave displays were synced.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: The queried Graphics system does not have any GSync Device / does not have a GPU attached to
//                the GSync device / display handles are invalid.
//                NVAPI_ERROR: The operation failed.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GSync_EnableSync(NvGSyncDeviceHandle hNvGSyncDevice, NV_GSYNC_TOPOLOGY_TARGET *pNvGTopologyTarget, NvU32 refreshRate);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_DisableSync
//
//   DESCRIPTION: Unsyncs the displays
//
//    PARAMETERS: hNvGSyncDevice[IN] - The caller provides the handle of the GSync device on which the provided GPU is located
//
//                retainMaster[IN] - The caller provides whether to keep a display as master even after unsyncing
//
//                *pNvGTopologyTarget[IN|OUT] - The caller provides the structure containing the GPU, and the
//                displays on the GPU to be unsynced.
//                If an error occurs, *pNvGTopologyTarget will be set to NULL.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hNvGSyncDevice is NULL / pNvGTopologyTarget is NULL.
//                NVAPI_OK: Master and/or slave displays were unsynced.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: The queried Graphics system does not have any GSync Device / does not have a GPU attached to
//                the GSync device.
//                NVAPI_ERROR: The operation failed.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GSync_DisableSync(NvGSyncDeviceHandle hNvGSyncDevice, NV_GSYNC_TOPOLOGY_TARGET *pNvGTopologyTarget, NvU32 retainMaster);

 ///////////////////////////////////////////////////////////////////////////////
 //
 // FUNCTION NAME: NvAPI_GSync_SetSyncState
 //
 //   DESCRIPTION: Sets a new sync state for the displays contained in the given pNvGTopology.
 //                The refreshrate is taken into account in case at least a framelock master or slave is contained in the topology.
 //
 //    PARAMETERS: hNvGSyncDevice[IN] - The caller provides the handle of the GSync device on which the provided GPUs are located.
 //
 //                refreshRate[IN] - The caller provides the desired refresh rate to be synced at. The value is in 0.0001 Hertz
 //
 //                *pNvGTopology[IN|OUT] - The caller provides the structure containing all GPUs connected to a gsync device, and the
 //                displays on the GPUs to be synced. 
 //                Any display which should not be synced should get it's syncState set to NVAPI_GSYNC_DISPLAY_SYNC_STATE_UNSYNCED.
 //                The bIsSynced member of the NV_GSYNC_TOPOLOGY_TARGET is ignored in the call.
 //                This API ensures the atomicity. 
 //                This API takes care of all the Quadroplex models including D4 and non-Quadroplex.
 //
 //                If an error occurs, *pNvGTopology will be set to the current hw state.
 //                In case a gpu or displayhandle could not be found, the target is set the NULL.
 //
//  SUPPORTED OS: Windows XP and higher
 // RETURN STATUS: NVAPI_INVALID_ARGUMENT: hNvGSyncDevice is NULL / pNvGTopology is NULL.
 //                NVAPI_OK: Master display and/or slave displays were synced.
 //                NVAPI_NVIDIA_DEVICE_NOT_FOUND: The queried Graphics system does not have any GSync Device / does not have a GPU attached to
 //                the GSync device / display handles are invalid.
 //                NVAPI_ERROR: The operation failed.
 //
 ///////////////////////////////////////////////////////////////////////////////
 NVAPI_INTERFACE NvAPI_GSync_SetSyncState(NvGSyncDeviceHandle hNvGSyncDevice, NV_GSYNC_TOPOLOGY *pNvGPUTopology, NvU32 refreshRate);
 
//Source signal edge to be used for output pulse
typedef enum 
{
    NVAPI_GSYNC_POLARITY_RISING_EDGE     = 0,
    NVAPI_GSYNC_POLARITY_FALLING_EDGE    = 1,
    NVAPI_GSYNC_POLARITY_BOTH_EDGES      = 2,
} NVAPI_GSYNC_POLARITY;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_UpdateSyncPolarity
//
//   DESCRIPTION: Sets the polarity as leading / falling / both (source signal edge to be used for output pulse)
//
//    PARAMETERS: hNvGSyncDevice[IN] - The caller provides the handle of the GSync device for which to set polarity
//
//                polarity[IN] - Rising / Falling / Both
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hNvGSyncDevice is NULL / polarity is invalid.
//                NVAPI_OK: Polarity set.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: The queried Graphics system does not have any GSync Device.
//                NVAPI_ERROR: The operation failed.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GSync_UpdateSyncPolarity(NvGSyncDeviceHandle hNvGSyncDevice, NVAPI_GSYNC_POLARITY polarity);

typedef enum 
{
    NVAPI_GSYNC_VIDEO_MODE_NONE          = 0,
    NVAPI_GSYNC_VIDEO_MODE_TTL           = 1,
    NVAPI_GSYNC_VIDEO_MODE_NTSCPALSECAM  = 2,
    NVAPI_GSYNC_VIDEO_MODE_HDTV          = 3,
} NVAPI_GSYNC_VIDEO_MODE;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_UpdateVideoMode
//
//   DESCRIPTION: Sets the video mode as one of None, TTL, NTSCPALSECAM, HDTV
//
//    PARAMETERS: hNvGSyncDevice[IN] - The caller provides the handle of the GSync device for which to set video mode
//
//                vmode[IN] - None, TTL, NTSCPALSECAM, HDTV
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hNvGSyncDevice is NULL / vmode is invalid.
//                NVAPI_OK: Video mode set.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: The queried Graphics system does not have any GSync Device.
//                NVAPI_ERROR: The operation failed.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GSync_UpdateVideoMode(NvGSyncDeviceHandle hNvGSyncDevice, NVAPI_GSYNC_VIDEO_MODE vmode);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_UpdateSyncInterval
//
//   DESCRIPTION: Sets the sync interval - number of pulses to wait between sync signal generation
//
//    PARAMETERS: hNvGSyncDevice[IN] - The caller provides the handle of the GSync device for which to set sync interval
//
//                interval[IN] - number of pulses to skip for signal generation. 0 uses source, 1 gives half the frequency and so on.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hNvGSyncDevice is NULL / interval is invalid.
//                NVAPI_OK: Interval set.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: The queried Graphics system does not have any GSync Device.
//                NVAPI_ERROR: The operation failed.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GSync_UpdateSyncInterval(NvGSyncDeviceHandle hNvGSyncDevice, NvU32 interval);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_UpdateSyncSkew
//
//   DESCRIPTION: Sets the sync skew
//
//    PARAMETERS: hNvGSyncDevice[IN] - The caller provides the handle of the GSync device for which to set skew
//
//                skew[IN] - The time delay between the frame sync signal and the GPUs signal in units of 7.81 us, max 15.99 ms.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hNvGSyncDevice is NULL / skew is invalid.
//                NVAPI_OK: Skew set.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: The queried Graphics system does not have any GSync Device.
//                NVAPI_ERROR: The operation failed.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GSync_UpdateSyncSkew(NvGSyncDeviceHandle hNvGSyncDevice, NvS32 skew);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_UpdateSyncStartDelay
//
//   DESCRIPTION: Sets the sync start delay for master
//
//    PARAMETERS: hNvGSyncDevice[IN] - The caller provides the handle of the GSync device for which to set start delay
//
//                startDelay[IN] - The amount of time to wait before generating the first sync pulse in units of 7.81 us, max 64 ms
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hNvGSyncDevice is NULL / startDelay is invalid.
//                NVAPI_OK: Delay set.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: The queried Graphics system does not have any GSync Device.
//                NVAPI_ERROR: The operation failed.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GSync_UpdateSyncStartDelay(NvGSyncDeviceHandle hNvGSyncDevice, NvS32 startDelay);

typedef enum 
{
    NVAPI_GSYNC_SYNC_SOURCE_VSYNC        = 0,
    NVAPI_GSYNC_SYNC_SOURCE_HOUSESYNC    = 1,
} NVAPI_GSYNC_SYNC_SOURCE;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_UpdateSyncSource
//
//   DESCRIPTION: Sets the sync source for the GSync device provided
//
//    PARAMETERS: hNvGSyncDevice[IN] - The caller provides the handle of the GSync device for which to set sync source
//
//                source[IN] - The caller provides VSync / House sync to be set as source
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hNvGSyncDevice is NULL / source is invalid.
//                NVAPI_OK: Source set.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: The queried Graphics system does not have any GSync Device.
//                NVAPI_ERROR: The operation failed.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GSync_UpdateSyncSource(NvGSyncDeviceHandle hNvGSyncDevice, NVAPI_GSYNC_SYNC_SOURCE source);


typedef enum 
{
    NVAPI_GSYNC_RJ45_OUTPUT     = 0,
    NVAPI_GSYNC_RJ45_INPUT      = 1,
    NVAPI_GSYNC_RJ45_UNUSED        = 2 // This field is used only by CPL to notify that the framelock is not actually present.
} NVAPI_GSYNC_RJ45_IO;

typedef struct
{
    NvU32                       version;
    NVAPI_GSYNC_POLARITY        polarity;           //Leading edge / Falling edge / both
    NVAPI_GSYNC_VIDEO_MODE      vmode;              //None, TTL, NTSCPALSECAM, HDTV
    NvU32                       interval;           //Number of pulses to wait between framelock signal generation
    NvS32                       skew;               //The time delay between the frame sync signal and the GPUs signal
    NvS32                       startDelay;         //Sync start delay for master
    NVAPI_GSYNC_SYNC_SOURCE     source;             //VSync / House sync
    NvU32                       refreshRate;        //The refresh rate
    NVAPI_GSYNC_RJ45_IO         RJ45_IO[NVAPI_MAX_RJ45_PER_GSYNC];          //Configured as input / output
    NvU32                       RJ45_Ethernet[NVAPI_MAX_RJ45_PER_GSYNC];    //Connected to ethernet hub? [ERRONEOUSLY CONNECTED!]
} NV_GSYNC_PARAMS;

#define NV_GSYNC_PARAMS_VER  MAKE_NVAPI_VERSION(NV_GSYNC_PARAMS,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_QuerySyncParameters
//
//   DESCRIPTION: Queries for all sync parameters as defined in NV_GSYNC_PARAMS
//
//    PARAMETERS: hNvGSyncDevice[IN] - The caller provides the handle of the GSync device for which to get parameters
//
//                *pVals[OUT] - The caller provides the storage space. NvAPI_GSync_QuerySyncParameters populates *pVals with
//                values. On error, *pVals is set to NULL.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hNvGSyncDevice is NULL.
//                NVAPI_OK: *pVals populated with values.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: The queried Graphics system does not have any GSync Device.
//                NVAPI_ERROR: The operation failed.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GSync_QuerySyncParameters(NvGSyncDeviceHandle hNvGSyncDevice, NV_GSYNC_PARAMS *pVals);

typedef struct
{
    NvU32                       version;
    NVAPI_GSYNC_POLARITY        polarity;           //Leading edge / Falling edge / both
    NVAPI_GSYNC_VIDEO_MODE      vmode;              //None, TTL, NTSCPALSECAM, HDTV
    NvU32                       interval;           //Number of pulses to wait between framelock signal generation
    NvS32                       skew;               //The time delay between the frame sync signal and the GPUs signal
    NvS32                       startDelay;         //Sync start delay for master
    NVAPI_GSYNC_SYNC_SOURCE     source;             //VSync / House sync
} NV_GSYNC_CONTROL_PARAMS;


#define NV_GSYNC_CONTROL_PARAMS_VER  MAKE_NVAPI_VERSION(NV_GSYNC_CONTROL_PARAMS,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_GetControlParameters
//
//   DESCRIPTION: Queries for sync control parameters as defined in NV_GSYNC_CONTROL_PARAMS
//
//    PARAMETERS: hNvGSyncDevice[IN] - The caller provides the handle of the GSync device for which to get parameters
//
//                *pVals[OUT] - The caller provides the storage space. NvAPI_GSync_GetControlParameters populates *pVals with
//                values. On error, *pVals is set to NULL.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hNvGSyncDevice is NULL.
//                NVAPI_OK: *pVals populated with values.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: The queried Graphics system does not have any GSync Device.
//                NVAPI_ERROR: The operation failed.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GSync_GetControlParameters(NvGSyncDeviceHandle hNvGSyncDevice, NV_GSYNC_CONTROL_PARAMS *pVals);

typedef struct
{
    NvU32                       version;
    NvU32                       refreshRate;                                //The refresh rate
    NVAPI_GSYNC_RJ45_IO         RJ45_IO[NVAPI_MAX_RJ45_PER_GSYNC];          //Configured as input / output
    NvU32                       RJ45_Ethernet[NVAPI_MAX_RJ45_PER_GSYNC];    //Connected to ethernet hub? [ERRONEOUSLY CONNECTED!]
    NvU32                        houseSyncIncoming;
    NvU32                        bHouseSync;
} NV_GSYNC_STATUS_PARAMS;

#define NV_GSYNC_STATUS_PARAMS_VER  MAKE_NVAPI_VERSION(NV_GSYNC_STATUS_PARAMS,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_GetStatusParameters
//
//   DESCRIPTION: Queries for sync status parameters as defined in NV_GSYNC_STATUS_PARAMS
//
//    PARAMETERS: hNvGSyncDevice[IN] - The caller provides the handle of the GSync device for which to get parameters
//
//                *pVals[OUT] - The caller provides the storage space. NvAPI_GSync_GetStatusParameters populates *pVals with
//                values. On error, *pVals is set to NULL.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hNvGSyncDevice is NULL.
//                NVAPI_OK: *pVals populated with values.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: The queried Graphics system does not have any GSync Device.
//                NVAPI_ERROR: The operation failed.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GSync_GetStatusParameters(NvGSyncDeviceHandle hNvGSyncDevice, NV_GSYNC_STATUS_PARAMS *pVals);

typedef struct
{
    NvU32 version;
    NvU32 bIsSynced;                        //Is Timing in sync?
    NvU32 bIsStereoSynced;                  //Phase of timing signal from the GPU = phase of master sync signal?
    NvU32 bIsSyncSignalAvailable;           //Sync signal available?
} NV_GSYNC_STATUS;

#define NV_GSYNC_STATUS_VER  MAKE_NVAPI_VERSION(NV_GSYNC_STATUS,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_QuerySyncStatus
//
//   DESCRIPTION: Queries the sync status of a GPU - timing, stereosync and sync signal availability
//
//    PARAMETERS: hNvGSyncDevice[IN] - The caller provides the handle of the GSync device for which to get the sync status
// 
//                gsyncTarget[IN] - GPU to be queried for sync status. The displays (if any are specified) are ignored.
//
//                *pStatus[OUT] - The caller provides the storage space. NvAPI_GSync_QuerySyncStatus populates *pStatus with
//                values - timing, stereosync and signal availability. On error, *pStatus is set to NULL.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hNvGSyncDevice is NULL / gsyncTarget is NULL.
//                NVAPI_OK: *pStatus populated with values.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: The queried Graphics system does not have any GSync Device / specified GPU not found.
//                NVAPI_ERROR: The operation failed.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GSync_QuerySyncStatus(NvGSyncDeviceHandle hNvGSyncDevice, NV_GSYNC_TOPOLOGY_TARGET gsyncTarget, NV_GSYNC_STATUS *pStatus);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_UpdateInterlaceMode
//
//   DESCRIPTION: Enables/disables interlace mode for a GSync device
//
//    PARAMETERS: hNvGSyncDevice[IN] - The caller provides the handle of the GSync device for which to enable interlace mode
//
//                state[IN] - Enable = 1, Disable = 0
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hNvGSyncDevice is NULL.
//                NVAPI_OK: Interlace mode enabled.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: The queried Graphics system does not have any GSync Device.
//                NVAPI_ERROR: The operation failed.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GSync_UpdateInterlaceMode(NvGSyncDeviceHandle hNvGSyncDevice, NvU32 state);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_QueryInterlaceMode
//
//   DESCRIPTION: Queries interlace mode (enabled/disabled) for a GSync device
//
//    PARAMETERS: hNvGSyncDevice[IN] - The caller provides the handle of the GSync device for which to query interlace mode
//
//                *pState[OUT] - Interlace mode enabled = 1, disabled = 0
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hNvGSyncDevice is NULL.
//                NVAPI_OK: Interlace mode returned.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: The queried Graphics system does not have any GSync Device.
//                NVAPI_ERROR: The operation failed.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GSync_QueryInterlaceMode(NvGSyncDeviceHandle hNvGSyncDevice, NvU32 *pState);

typedef enum 
{
    NVAPI_GSYNC_DIAGNOSTIC_LOCK_NONE        = 0,
    NVAPI_GSYNC_DIAGNOSTIC_LOCK_FRAMELOCK   = 1,
    NVAPI_GSYNC_DIAGNOSTIC_LOCK_RASTERLOCK  = 3,
} NVAPI_GSYNC_DIAGNOSTIC_LOCK_STATE;

typedef enum 
{
    NVAPI_GSYNC_DIAGNOSTIC_RM_LOCK_NONE      = 0,
    NVAPI_GSYNC_DIAGNOSTIC_RM_LOCK_MASTER    = 1,
    NVAPI_GSYNC_DIAGNOSTIC_RM_LOCK_SLAVE     = 2,
} NVAPI_GSYNC_DIAGNOSTIC_RM_LOCK_STATE;

// specify a signal path from or to the GPU
typedef enum 
{
    NVAPI_GSYNC_DIAGNOSTIC_PIN_INTERNAL  = 0,   // inside GPU between two heads
    NVAPI_GSYNC_DIAGNOSTIC_PIN_0         = 1,   // through different GPIO of GPU
    NVAPI_GSYNC_DIAGNOSTIC_PIN_1         = 2,
    NVAPI_GSYNC_DIAGNOSTIC_PIN_2         = 3,
    NVAPI_GSYNC_DIAGNOSTIC_PIN_3         = 4,
} NVAPI_GSYNC_DIAGNOSTIC_PIN;

typedef struct
{
    NvU32                                version;
    NVAPI_GSYNC_DIAGNOSTIC_LOCK_STATE    masterLockState;       // master lock mode
    NVAPI_GSYNC_DIAGNOSTIC_PIN           masterLockPin;         // lock to which GPIO
    NVAPI_GSYNC_DIAGNOSTIC_LOCK_STATE    slaveLockState;
    NVAPI_GSYNC_DIAGNOSTIC_PIN           slaveLockPin;
    NVAPI_GSYNC_DIAGNOSTIC_PIN           stereoPin;
    NvU8                                 modeTweaking;          // whether display driver needs to be adjusted for better synchronization
    NVAPI_GSYNC_DIAGNOSTIC_RM_LOCK_STATE rmFramelockState;      // framelock state in RM
    NvU8                                 stereoLock;            // Is stereo locked?
    NvU8                                 syncLock;              // Is synced?
    NvU8                                 primary;               // Is primary or secondary?
    // Mode related information    
    NvU32                                refreshRateX10k;
    NvU32                                hBlankStart;
    NvU32                                hSyncEnd;
    NvU32                                hBlankEnd;
    NvU32                                hTotal;
    NvU32                                vBlankStart;
    NvU32                                vSyncEnd;
    NvU32                                vBlankEnd;
    NvU32                                vTotal;
    NvU32                                vInterlacedBlankEnd;
    NvU32                                vInterlacedBlankStart;
    NvU32                                pixelClockHz;
    NvU8                                 interlaced;
} NVAPI_GSYNC_DIAGNOSTIC_PARAMS;

#define NV_GSYNC_DIAGNOSTIC_PARAMS_VER  MAKE_NVAPI_VERSION(NVAPI_GSYNC_DIAGNOSTIC_PARAMS,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_Get_DiagnosticSettings
//
//   DESCRIPTION: Queries for all sync parameters as defined in NVAPI_GSYNC_DIAGNOSTIC_PARAMS
//
//    PARAMETERS: hNvDisplay[IN]  - The caller provides the handle of the display for which to get parameters
//                outputId[IN] - In nView mode a displaymask is alse needed to define the monitor for which to get parameters
//
//                *pDiagParams[OUT] - The caller provides the storage space. NvAPI_GSync_Diag populates *pDiagParams with
//                                        values. On error, *pDiagParams is set to NULL.
//
//  SUPPORTED OS: Windows XP and higher
//
// RETURN STATUS: NVAPI_OK: *pDiagParams populated with values.
//                NVAPI_INVALID_ARGUMENT: outputId/pDiagParams is NULL.
//                NVAPI_EXPECTED_DISPLAY_HANDLE: invalid diaplay handle.
//                NVAPI_ERROR: The operation failed.
//                NVAPI_API_NOT_INTIALIZED
//                NVAPI_INCOMPATIBLE_STRUCT_VERSION
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GSync_Get_DiagnosticSettings(NvDisplayHandle hNvDisplay, NvU32 outputId, NVAPI_GSYNC_DIAGNOSTIC_PARAMS *pDiagParams);


///////////////////////////////////////////////////////////////////////////////
// (*obsolete*) 
//  We are trying to move away from NvAPI_EnumAppStatistics into NvAPI_GetAppStatistics
// (*obsolete*)
// FUNCTION NAME:   NvAPI_EnumAppStatistics
//
//   DESCRIPTION:   This API lets caller to lets us poll the driver for
//                  any 3D contexts that have been created/destroyed. This information
//                  will be collected by the GeForce Experience client, and sent to
//                  our servers for data-mining purposes. The client should keep enumerating until it
//                  returns NVAPI_END_ENUMERATION.
//                  (Both executed and running apps are treated the same.  Running app would have 0 closeTime.)
//                  (Time is defined as is a count of 100-nanosecond intervals since January 1, 1601)
//                  (Operation mode is specified by Flags. )
//
//  SUPPORTED OS: Windows Vista and higher
//
//         INPUT:   Flags       NV_APPENUMFLAG_READ           read only
//                              NV_APPENUMFLAG_READERASE      read then erase
//                              NV_APPENUMFLAG_READACTIVE     read only ative apps
//                  (these flags are exclusive, and cannot be combined in usage.)
//
//            IN:   enumIndex  indicate the position which the enumeration starts
//
//        OUTPUT:   pProcessInfo
//
// RETURN STATUS:   NVAPI_OK - completed request, and potentially have more entry
//                  NVAPI_END_ENUMERATION - no more entry
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - invalid argument
//
///////////////////////////////////////////////////////////////////////////////

#define NV_APPENUMFLAG_READ         0x00000000
#define NV_APPENUMFLAG_READERASE    0x00000001
#define NV_APPENUMFLAG_READACTIVE   0x00000002

typedef enum
{
    NVAPI_API_OPENGL = 1,
    NVAPI_API_DX9    = 2,
    NVAPI_API_DX10   = 3,
    NVAPI_API_DX9_CUDA  = 4,
    NVAPI_API_DX10_CUDA = 5,
    NVAPI_API_OPENGL_CUDA = 6,
} NVAPI_API_TYPE;


typedef struct
{
    NvU32                           version;
    NVAPI_API_TYPE                  APIType;
    NvU32                           processId;
    NvU64                           openTime;
    NvU64                           closeTime;
    NvU64                           averageFrameRate;
    char                            exeName[NVAPI_LONG_STRING_MAX];
} NVAPI_PROCESS_POLL_INFO;
#define NVAPI_PROCESS_POLL_INFO_VER         MAKE_NVAPI_VERSION(NVAPI_PROCESS_POLL_INFO, 1)


NVAPI_INTERFACE NvAPI_EnumAppStatistics(NvU32 enumIndex, NvU32 flags, NVAPI_PROCESS_POLL_INFO *pProcessInfo);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetAppStatistics
//
//   DESCRIPTION:   This API lets caller to lets us poll the driver for
//                  any 3D contexts that have been created/destroyed. This information
//                  will be collected by the GeForce Experience client, and sent to
//                  our servers for data-mining purposes. The client would get all entries at once
//                  (Both executed and running apps are treated the same.  Running app would have 0 closeTime.)
//                  (Time is defined as is a count of 100-nanosecond intervals since January 1, 1601)
//                  (Operation mode is specified by Flags. )
//
//  SUPPORTED OS: Windows Vista and higher
//
//         INPUT:   Flags       reserved for future use, (must be 0)
//
//        IN/OUT:   pNum        in(the number of entries in pProcessInfo array)
//                              out(the number of entries being filled)
//
//        OUTPUT:   pProcessInfo    an array of NVAPI_PROCESS_POLL_INFO
//
// RETURN STATUS:   NVAPI_OK - completed request, and potentially have more entry
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - invalid argument
//
///////////////////////////////////////////////////////////////////////////////
#define NVAPI_MAX_PROCESS_INFO_ENTRIES  16

NVAPI_INTERFACE NvAPI_GetAppStatistics(NvU32 *pNum, NvU32 flags, NVAPI_PROCESS_POLL_INFO *pProcessInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetPstateLimitsInfo
//
// DESCRIPTION:   This retrieves the list of p-state limiting factors for the specified physical GPU.
//                      numLimits is the number of limiting factors returned
//                For each limiting factor:
//                      limitId is a unique identifier for each limiting factor
//                      limitType is a flag that indicates how the limit is applied (minimum, maximum or both)
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_INVALID_ARGUMENT - pDynamicPstatesInfo is NULL
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the INFO struct is not supported
//
///////////////////////////////////////////////////////////////////////////////
#define NVAPI_MAX_PSTATE_LIMITS                 64

//
// Any new values must be added to the end
//
typedef enum
{
    NVAPI_PSTATE_LIMIT_PERFMON,
    NVAPI_PSTATE_LIMIT_NO_CLIENT,
    NVAPI_PSTATE_LIMIT_SCREEN_SAVER,
    NVAPI_PSTATE_LIMIT_NO_HIRES,
    NVAPI_PSTATE_LIMIT_OS_LEVEL,
    NVAPI_PSTATE_LIMIT_SPDIFF_GLITCH,
    NVAPI_PSTATE_LIMIT_DISPLAY_GLITCH,
    NVAPI_PSTATE_LIMIT_UNLOAD_DRIVER,
    NVAPI_PSTATE_LIMIT_POWERMIZER,
    NVAPI_PSTATE_LIMIT_STRESSTEST_FAILURE,
    NVAPI_PSTATE_LIMIT_RC_ERROR,
    NVAPI_PSTATE_LIMIT_MIN_FAN_LEVEL,
    NVAPI_PSTATE_LIMIT_MCLK_CLONE,
    NVAPI_PSTATE_LIMIT_OVERLAY,
    NVAPI_PSTATE_LIMIT_HIGHRES,
    NVAPI_PSTATE_LIMIT_BANDWIDTHFACTOR,
    NVAPI_PSTATE_LIMIT_HD_FRAMEDROP_WAR,
    NVAPI_PSTATE_LIMIT_ISMODEPOSSIBLE,
    NVAPI_PSTATE_LIMIT_HYBRID,
    NVAPI_PSTATE_LIMIT_INVALID_SYSCON,
    NVAPI_PSTATE_LIMIT_STRESSTEST_SETUP,
    NVAPI_PSTATE_LIMIT_FORCED,
    NVAPI_PSTATE_LIMIT_FORCED_DACPERFTEST,
    NVAPI_PSTATE_LIMIT_FORCED_ACSHMOO,
    NVAPI_PSTATE_LIMIT_FORCED_STRESSTEST,
    NVAPI_PSTATE_LIMIT_POWERMIZER_HARD,
    NVAPI_PSTATE_LIMIT_THERMAL,
    NVAPI_PSTATE_LIMIT_SYSPERF,
    NVAPI_PSTATE_LIMIT_PWR_SUPPLY_CAPACITY,
    NVAPI_PSTATE_LIMIT_SW_BATTPOWER,
    NVAPI_PSTATE_LIMIT_EXT_PERF_CONTROL,
    NVAPI_PSTATE_LIMIT_MXM_ACPOWER,
    NVAPI_PSTATE_LIMIT_AUX_POWER,
    NVAPI_PSTATE_LIMIT_SHORT_VBLANK,
    NVAPI_PSTATE_LIMIT_POWER_BALANCE
} NVAPI_PSTATE_LIMIT;

#define NVAPI_PSTATE_LIMIT_UNDEFINED            0xff

#define NVAPI_PSTATE_LIMIT_TYPE_MIN             1
#define NVAPI_PSTATE_LIMIT_TYPE_MAX             2
#define NVAPI_PSTATE_LIMIT_TYPE_BOTH            3

typedef struct
{
    NvU8        limitId;
    NvU8        limitType;
} NV_GPU_PSTATE_LIMIT_INFO;

typedef struct
{
    NvU32       version;        // Structure version
    NvU32       numLimits;
    NV_GPU_PSTATE_LIMIT_INFO    limitInfoList[NVAPI_MAX_PSTATE_LIMITS];
} NV_GPU_PSTATE_LIMITS_INFO;
#define NV_GPU_PSTATE_LIMITS_INFO_VER MAKE_NVAPI_VERSION(NV_GPU_PSTATE_LIMITS_INFO,1)

NVAPI_INTERFACE NvAPI_GPU_GetPstateLimitsInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_PSTATE_LIMITS_INFO *pLimitsInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetPstateActiveLimits
//
// DESCRIPTION:   This retrieves the list of active p-state limiting factors for the specified physical GPU.
//                      numLimits is the number of limiting factors returned
//                For each limiting factor:
//                      limitId is a unique identifier for the limiting factor
//                      pstate is the pstate limit set for the limiting factor
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_INVALID_ARGUMENT - pDynamicPstatesInfo is NULL
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the INFO struct is not supported
//
///////////////////////////////////////////////////////////////////////////////
typedef struct
{
    NvU8        limitId;
    NvU8        pstate;
} NV_GPU_PSTATE_LIMIT_STATUS;

typedef struct
{
    NvU32       version;        // Structure version
    NvU32       numLimits;
    NV_GPU_PSTATE_LIMIT_STATUS    limitStatusList[NVAPI_MAX_PSTATE_LIMITS];
} NV_GPU_PSTATE_ACTIVE_LIMITS;
#define NV_GPU_PSTATE_ACTIVE_LIMITS_VER MAKE_NVAPI_VERSION(NV_GPU_PSTATE_ACTIVE_LIMITS,1)

NVAPI_INTERFACE NvAPI_GPU_GetPstateActiveLimits(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_PSTATE_ACTIVE_LIMITS *pActiveLimits);


#define NVAPI_GPIO_SIZE_QUERY_ARRAY 0x00000020

typedef enum
{
    NVAPI_GPIO_DIRECTION_INPUT,
    NVAPI_GPIO_DIRECTION_OUTPUT
} NVAPI_GPIO_DIRECTION;

typedef struct
{
    NvU32         version;
    NvU32         gpioPinCount;
    NvU32         gpioLegalPins[NVAPI_GPIO_SIZE_QUERY_ARRAY];
} NV_GPU_GPIO_LEGAL_PINS;
#define NV_GPU_GPIO_LEGAL_PINS_VER MAKE_NVAPI_VERSION(NV_GPU_GPIO_LEGAL_PINS,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GPIOQueryLegalPins
//
// PARAMETERS:    hPhysicalGpu(IN)        - GPU selection.
//                pgpioLegalPins          - pointer to a versioned structure to get number of the pin(s) associated with the
//                                          CUSTOMER_ASYNCRW functions and an array of size NVAPI_GPIO_SIZE_QUERY_ARRAY in
//                                          which the legal pin numbers are retrieved. These legal pin numbers are to be used
//                                          while performing read and write operations on the GPIO port.
//
// DESCRIPTION:   This function will return the number of available gpio customer asyncrw instance.
//
//  SUPPORTED OS: Windows XP and higher
//
// HOW TO USE:    NV_GPU_GPIO_LEGAL_PINS gpioLegalPins = {0};
//                gpioLegalPins.version = NV_GPU_GPIO_LEGAL_PINS_VER;
//                ret = NvAPI_GPU_GPIOQueryLegalPins(hPhysicalGpu, &gpioLegalPins);
//                On call success:
//                The gpioLegalPins.gpioPinCount would contain some integer (On my G96 it contains 3)
//                The gpioLegalPins.gpioLegalPins array would contain some values (on my G96 it contains 0xd, 0xe & 0xf, others 0) to be used
//                in NvAPI_GPU_GPIOReadFromPin & NvAPI_GPU_GPIOWriteToPin calls respectively.
//
// RETURN STATUS:
//                NVAPI_OK - completed request
//                NVAPI_ERROR - miscellaneous error occurred
//                NVAPI_NOT_SUPPORTED - this feature is not supported on this GPU
//                NVAPI_INVALID_HANDLE - physical GPU not found
//                NVAPI_INVALID_ARGUMENT - invalid arugument passed
//                NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//                NVAPI_API_NOT_INITIALIZED - nvapi not initialized
//                NVAPI_INCOMPATIBLE_STRUCT_VERSION - structure(s) passed not initialized with proper version data
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GPIOQueryLegalPins(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_GPIO_LEGAL_PINS *pgpioLegalPins);

typedef struct
{
    NvU32         version;
    NvU32         gpioPinNumber;
    NvU32         gpioDataReadWrite;
    NVAPI_GPIO_DIRECTION         gpioDirection;
} NV_GPU_GPIO_PIN_DATA;
#define NV_GPU_GPIO_PIN_DATA_VER MAKE_NVAPI_VERSION(NV_GPU_GPIO_PIN_DATA,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GPIOReadFromPin
//
// PARAMETERS:    hPhysicalGpu(IN)        - GPU selection.
//                pgpioReadPin            - pointer to a versioned structure to pass gpio pin number from which the data is
//                                          to be read, the GPIO direction and the variable in which the data is collected.
//                                          The gpioPinNumber parameter is selected from pgpioLegalPins array by calling
//                                          NvAPI_GPU_GPIOQueryLegalPins.
//
// DESCRIPTION:   This function reads the data from the specified gpio pin.
//
//  SUPPORTED OS: Windows XP and higher
//
// HOW TO USE:    First make NvAPI_GPU_GPIOQueryLegalPins call as shown above
//                NV_GPU_GPIO_PIN_DATA gpioReadPin = {0};
//                gpioReadPin.version = NV_GPU_GPIO_PIN_DATA_VER;
//                gpioReadPin.gpioDirection = NVAPI_GPIO_DIRECTION_INPUT;
//                gpioReadPin.gpioPinNumber = any legal pin data from gpioLegalPins array after successful call to NvAPI_GPU_GPIOQueryLegalPins
//                ret = NvAPI_GPU_GPIOReadFromPin(hPhysicalGpu, &gpioReadPin);
//                On call success:
//                The gpioReadPin.gpioDataReadWrite would contain the data value read (0 or 1) from the specified pin.
//
// RETURN STATUS:
//                NVAPI_OK - completed request
//                NVAPI_ERROR - miscellaneous error occurred
//                NVAPI_INVALID_HANDLE - physical GPU not found
//                NVAPI_INVALID_ARGUMENT - invalid arugument passed
//                NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//                NVAPI_API_NOT_INITIALIZED - nvapi not initialized
//                NVAPI_INCOMPATIBLE_STRUCT_VERSION - structure(s) passed not initialized with proper version data
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GPIOReadFromPin(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_GPIO_PIN_DATA *pgpioReadPin);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GPIOWriteToPin
//
// PARAMETERS:    hPhysicalGpu(IN)        - GPU selection.
//                pgpioWritePin           - pointer to a versioned structure to pass gpio pin number to which the data is
//                                          to be written, the GPIO direction and the data value. The gpioPinNumber parameter
//                                          is selected from pgpioLegalPins array by calling NvAPI_GPU_GPIOQueryLegalPins.
//
// DESCRIPTION:   This function writes the data to the specified gpio pin.
//
//  SUPPORTED OS: Windows XP and higher
//
// HOW TO USE:    First make NvAPI_GPU_GPIOQueryLegalPins call as shown above
//                NV_GPU_GPIO_PIN_DATA gpioWritePin = {0};
//                gpioWritePin.version = NV_GPU_GPIO_PIN_DATA_VER;
//                gpioWritePin.gpioDirection = NVAPI_GPIO_DIRECTION_OUTPUT;
//                gpioWritePin.gpioPinNumber = any legal pin data from gpioLegalPins array after successful call to NvAPI_GPU_GPIOQueryLegalPins
//                gpioWritePin.gpioDataReadWrite = any bit value (0 or 1)
//                ret = NvAPI_GPU_GPIOReadFromPin(hPhysicalGpu, &gpioReadPin);
//                On call success:
//                The gpioWritePin.gpioDataReadWrite value (0 or 1) is written to the specified pin.
//
// RETURN STATUS:
//                NVAPI_OK - completed request
//                NVAPI_ERROR - miscellaneous error occurred
//                NVAPI_INVALID_HANDLE - physical GPU not found
//                NVAPI_INVALID_ARGUMENT - invalid arugument passed
//                NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//                NVAPI_API_NOT_INITIALIZED - nvapi not initialized
//                NVAPI_INCOMPATIBLE_STRUCT_VERSION - structure(s) passed not initialized with proper version data
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GPIOWriteToPin(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_GPIO_PIN_DATA *pgpioWritePin);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetHDCPSupportStatus
//
// DESCRIPTION: Returns information on a GPU's HDCP support status
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_INVALID_ARGUMENT - pGetGpuHdcpSupportStatus is NULL
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the INFO struct is not supported
//
///////////////////////////////////////////////////////////////////////////////

typedef enum _NV_GPU_HDCP_FUSE_STATE
{
    NV_GPU_HDCP_FUSE_STATE_UNKNOWN  = 0,
    NV_GPU_HDCP_FUSE_STATE_DISABLED = 1,
    NV_GPU_HDCP_FUSE_STATE_ENABLED  = 2,
} NV_GPU_HDCP_FUSE_STATE;

typedef enum _NV_GPU_HDCP_KEY_SOURCE
{
    NV_GPU_HDCP_KEY_SOURCE_UNKNOWN    = 0,
    NV_GPU_HDCP_KEY_SOURCE_NONE       = 1,
    NV_GPU_HDCP_KEY_SOURCE_CRYPTO_ROM = 2,
    NV_GPU_HDCP_KEY_SOURCE_SBIOS      = 3,
    NV_GPU_HDCP_KEY_SOURCE_I2C_ROM    = 4,
    NV_GPU_HDCP_KEY_SOURCE_FUSES      = 5,
} NV_GPU_HDCP_KEY_SOURCE;

typedef enum _NV_GPU_HDCP_KEY_SOURCE_STATE
{
    NV_GPU_HDCP_KEY_SOURCE_STATE_UNKNOWN = 0,
    NV_GPU_HDCP_KEY_SOURCE_STATE_ABSENT  = 1,
    NV_GPU_HDCP_KEY_SOURCE_STATE_PRESENT = 2,
} NV_GPU_HDCP_KEY_SOURCE_STATE;

typedef struct
{
    NvU32                        version;               // Structure version
    NV_GPU_HDCP_FUSE_STATE       hdcpFuseState;         // GPU's HDCP fuse state
    NV_GPU_HDCP_KEY_SOURCE       hdcpKeySource;         // GPU's HDCP key source
    NV_GPU_HDCP_KEY_SOURCE_STATE hdcpKeySourceState;    // GPU's HDCP key source state
} NV_GPU_GET_HDCP_SUPPORT_STATUS;

#define NV_GPU_GET_HDCP_SUPPORT_STATUS_VER MAKE_NVAPI_VERSION(NV_GPU_GET_HDCP_SUPPORT_STATUS,1)

NVAPI_INTERFACE NvAPI_GPU_GetHDCPSupportStatus(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_GET_HDCP_SUPPORT_STATUS *pGetHDCPSupportStatus);


typedef struct
{
    NvU32 version;                          // Structure version

    // HDCP diagnostic information
    struct
    {
        NvU32 bGpuCapable              : 1; // GPU is HDCP capable (no errors detected, everything present)
        NvU32 bGpuFusePresent          : 1; // GPU HDCP fuse register set

        NvU32 bDfpCapable              : 1; // Display is HDCP capable
        NvU32 bDfpAllowed              : 1; // VBIOS allows HDCP on display
        NvU32 bDfpDualLink             : 1; // Is attach point dual-link capable

        NvU32 bRomError                : 1; // HDCP hardware detected an error with the rom
        NvU32 bDownstreamChecksumError : 1; // Set if hardware reports that its checksum BIST of its downstream HDCP keys failed

        NV_HDCP_PACKET packet;              // HDCP packet of information:
                                            // Only the following parts of the HDCP packet are populated:
                                            //      bStatus, hdcpStatus, cS, kP, aN, aKsv, dKsv, vP, mP, numBKSVs,
                                            //      bKsvList (bKsv, first 1 or 2 indices of bKsvList).
                                            // Use the packet.flFlags property to check which fields are valid/invalid.
    } hdcp;

    // HDMI diagnostic information for display
    struct
    {
        NvU32 bGpuCapable              : 1; // GPU is HDMI capable (indicates fuses are set)

        NvU32 bDfpCapable              : 1; // Display is HDMI capable
        NvU32 bDfpAllowed              : 1; // VBIOS allows HDMI on display
        NvU32 bDfpDualLink             : 1; // Is display dual-link capable
    } hdmi;

} NV_HDCP_HDMI_DIAGNOSTICS;

#define NV_GET_HDCP_HDMI_DIAGNOSTICS_VER MAKE_NVAPI_VERSION(NV_HDCP_HDMI_DIAGNOSTICS,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetHdcpHdmiDiagnostics
//
// DESCRIPTION: Returns diagnostic information on display HDCP and HDMI capabilities
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_INVALID_ARGUMENT - pGetGpuHdcpSupportStatus is NULL
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the INFO struct is not supported
//    NVAPI_EXPECTED_DIGITAL_FLAT_PANEL: outputId is not associated with digital flat panel.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetHdcpHdmiDiagnostics(NvPhysicalGpuHandle hPhysicalGpu, NvU32 displayId, NV_HDCP_HDMI_DIAGNOSTICS *pHdcpHdmiDiagnostics);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetACPIIdFromOutputId
//
// PARAMETERS:      hPhysicalGpu(IN)        - GPU selection.
//                  pOutputId(IN)           - pointer to the array of OutputIds with max size 16
//                  uOutputIdCount(IN)      - Number of OutputIds in the OutputId array
//                  pACPIid(OUT)            - pointer to the array of ACPIIds with max size 16
//                   
// DESCRIPTION: Returns corresponding ACPIIds for the given Display OutputIds
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: 
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//                  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//                  NVAPI_NOT_SUPPORTED - DVC feature is not supported on the selected GPU
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetACPIIdFromOutputId(NvPhysicalGpuHandle hPhysicalGpu, NvU32 pOutputId[NVAPI_MAX_ACPI_IDS], NvU32 uOutputIdCount, NvU32 pACPIid[NVAPI_MAX_ACPI_IDS] );

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetOutputIdFromACPIId
//
// PARAMETERS:      hPhysicalGpu(IN)        - GPU selection.
//                  pACPIid(IN)             - pointer to the array of ACPIIds with max size 16
//                  uACPIidCount(IN)        - Number of ACPIids in the ACPIId array
//                  pOutputId(OUT)          - pointer to the array of OutputIds with max size 16
//
// DESCRIPTION: Returns corresponding ACPIId for the given Display OutputId
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// RETURN STATUS: 
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//                  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//                  NVAPI_NOT_SUPPORTED - DVC feature is not supported on the selected GPU
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetOutputIdFromACPIId(NvPhysicalGpuHandle hPhysicalGpu, NvU32 pACPIid[NVAPI_MAX_ACPI_IDS], NvU32 uACPIidCount, NvU32 pOutputId[NVAPI_MAX_ACPI_IDS]);



#define MAX_VIDEO_SURFACE_COUNT 64

#define NV_MAX_VID_PP_INSTANCE 8

typedef struct _NV_VIDEO_DECODE_STREAM_INFO
{
    NvU32   streamIndex;                    // (IN)  select stream
    NvU32   processID;                      // (OUT) app process id
    NvU32   streamSrcWidth;                 // (OUT) width
    NvU32   streamSrcHeight;                // (OUT) height
    NvU32   streamFormat;                   // (OUT) Stream encode format
}NV_VIDEO_DECODE_STREAM_INFO;

typedef struct _NV_VIDEO_DXVA_INFO
{
    NvU32   version;                        // (IN)version info
    NvU32   dxvaObjectCount;                // no of dxva object created
    NV_VIDEO_DECODE_STREAM_INFO streamInfo[NV_MAX_VID_STREAMS];
} NV_VIDEO_DXVA_INFO;

#define NV_VIDEO_DXVA_INFO_VER  MAKE_NVAPI_VERSION(NV_VIDEO_DXVA_INFO,1)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Video_GetDXVAInfo
//
// DESCRIPTION:     This API is used to retrieve dxva decode information for swak
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS:      hNvDisplay(IN)          - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated
//                                            from NvAPI_EnumNVidiaDisplayHandle().
//                  pDxvaInfo(OUT)          - structure for retrieving dxva information
// RETURN STATUS:   NVAPI_OK, NVAPI_INVALID_ARGUMENT, NVAPI_API_NOT_INTIALIZED, NVAPI_INCOMPATIBLE_STRUCT_VERSION, NVAPI_ERROR
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Video_GetDXVAInfo(NvDisplayHandle hNvDisplay, NV_VIDEO_DXVA_INFO *pDxvaInfo);

typedef struct  _NV_VIDEO_OVERLAY_INFO
{
    NvU32   version;                        // (IN)version info
    NvU8    overlayInUse;                   // (OUT) boolean:Is overaly in use
    NvU32   overlaySurfaceCount;            // (OUT) Number of overlay surfaces created
} NV_VIDEO_OVERLAY_INFO;

#define NV_VIDEO_OVERLAY_INFO_VER  MAKE_NVAPI_VERSION(NV_VIDEO_OVERLAY_INFO,1)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Video_GetOverlayInfo
//
// DESCRIPTION:     This API is used to retrieve video overlay information for swak
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS:      hNvDisplay(IN)          - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated
//                                            from NvAPI_EnumNVidiaDisplayHandle().
//                  pVideoOverlayInfo(OUT)  - structure for retrieving video overlay information
// RETURN STATUS:   NVAPI_OK, NVAPI_INVALID_ARGUMENT, NVAPI_API_NOT_INTIALIZED, NVAPI_INCOMPATIBLE_STRUCT_VERSION, NVAPI_ERROR
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Video_GetOverlayInfo(NvDisplayHandle hNvDisplay, NV_VIDEO_OVERLAY_INFO *pVideoOverlayInfo);

typedef struct _NV_VIDEO_SURFACE_INFO
{
    NvU32   surfaceWidth;                 // (OUT) width
    NvU32   surfaceHeight;                // (OUT) height
    NvU32   surfaceFormat;                // (OUT) FOURCC format
    NvU32   surfaceSize;                  // (OUT) size in KB
}NV_VIDEO_SURFACE_INFO;

typedef struct _NV_VIDEO_GET_SURFACE_COUNT
{
    NvU32   version;                      // (IN)version info
    NvU32   surfaceFormat;                // (IN) FOURCC format
    NvU32   videoSurfaceCount;            // (OUT) videoSurfaceCount
} NV_VIDEO_GET_SURFACE_COUNT;

#define NV_VIDEO_GET_SURFACE_COUNT_VER  MAKE_NVAPI_VERSION(NV_VIDEO_GET_SURFACE_COUNT,1)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Video_GetVideoSurfaceCount
//
// DESCRIPTION:     This API is used to get the video surface count for different FOURCC
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS:      hNvDisplay(IN)          - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated
//                                            from NvAPI_EnumNVidiaDisplayHandle().
//                  pVideoSurfaceCount(OUT) - structure for retrieving video surface count
// RETURN STATUS:   NVAPI_OK, NVAPI_INVALID_ARGUMENT, NVAPI_API_NOT_INTIALIZED, NVAPI_INCOMPATIBLE_STRUCT_VERSION, NVAPI_ERROR
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Video_GetVideoSurfaceCount(NvDisplayHandle hNvDisplay, NV_VIDEO_GET_SURFACE_COUNT *pVideoSurfaceCount);

typedef struct  _NV_VIDEO_GET_SURFACE_INFO
{
    NvU32   version;                                            // (IN) version info
    NvU32   surfaceFormat;                                      // (IN) FOURCC format
    NvU32   startSurfCount;                                     // (IN) starting surface count
    NvU32   videoSurfaceCount;                                  // (OUT) videoSurfaceCount
    NV_VIDEO_SURFACE_INFO  surfaceInfo[MAX_VIDEO_SURFACE_COUNT];// (OUT) video Surface information
} NV_VIDEO_GET_SURFACE_INFO;

#define NV_VIDEO_GET_SURFACE_INFO_VER  MAKE_NVAPI_VERSION(NV_VIDEO_GET_SURFACE_INFO,1)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Video_GetVideoSurfaceInfo
//
// DESCRIPTION:     This API is used to get the detailed information for video surfaces of a given FOURCC
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS:      hNvDisplay(IN)          - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated
//                                            from NvAPI_EnumNVidiaDisplayHandle().
//                  pVideoSurfaceInfo(OUT)  - structure for retrieving detailed information for video surfaces of given FOURCC
// RETURN STATUS:   NVAPI_OK, NVAPI_INVALID_ARGUMENT, NVAPI_API_NOT_INTIALIZED, NVAPI_INCOMPATIBLE_STRUCT_VERSION, NVAPI_ERROR
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Video_GetVideoSurfaceInfo(NvDisplayHandle hNvDisplay, NV_VIDEO_GET_SURFACE_INFO *pVideoSurfaceInfo);

typedef struct _NV_VIDEO_STREAM_STATE
{
    NvU32   streamIndex;                                            // (OUT) Stream Index
    NvU32   surfaceWidth;                                           // (OUT) width
    NvU32   surfaceHeight;                                          // (OUT) height
    NvU8    gdiDisplayName[32];                                     // (OUT) gdiName corresponding to the video window
    NVAPI_GET_VIDEO_STATE_COMPONENT vidComponent[NVAPI_VIDEO_STATE_COMPONENT_ID_LAST];
}NV_VIDEO_STREAM_STATE;

typedef struct _NV_VIDEO_STATE_INFO
{
    NvU32                   version;                            // (IN) version info
    NvU32                   streamCount;                        // (OUT) number of DXVAVideoProcessDevice created
    NV_VIDEO_STREAM_STATE   streamInfo[NV_MAX_VID_PP_INSTANCE];
}NV_VIDEO_STATE_INFO;

#define NV_VIDEO_STATE_INFO_VER  MAKE_NVAPI_VERSION(NV_VIDEO_STATE_INFO,2)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Video_GetVideoStateInfo
//
// DESCRIPTION:     This API is used to retrieve state information for different video streams
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// PARAMETERS:      hNvDisplay(IN)          - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated
//                                            from NvAPI_EnumNVidiaDisplayHandle().
//                  pVideoStateInfo(OUT)    - structure for state inforamtion for different video streams
// RETURN STATUS:   NVAPI_OK, NVAPI_INVALID_ARGUMENT, NVAPI_API_NOT_INTIALIZED, NVAPI_INCOMPATIBLE_STRUCT_VERSION, NVAPI_ERROR
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Video_GetVideoStateInfo(NvDisplayHandle hNvDisplay, NV_VIDEO_STATE_INFO *pVideoStateInfo);

typedef enum _NV_VIDEO_QUERY_ID
{
    NV_VIDEO_GET_DXVA_INFO,
    NV_VIDEO_GET_OVERLAY_INFO,
    NV_VIDEO_GET_VIDEO_SURFACE_COUNT,
    NV_VIDEO_GET_SURFACE_DETAIL,
    NV_VIDEO_GET_STATE_INFO,
    NV_VIDEO_GET_COMMAND_LAST
} NV_VIDEO_QUERY_ID;

typedef struct _NV_VIDEO_GET_INFO
{
    NvU32               version;            // (IN) version info
    NV_VIDEO_QUERY_ID   queryID;            // (IN) query type
    union
    {
        NV_VIDEO_DXVA_INFO          getDxvaInfo;
        NV_VIDEO_OVERLAY_INFO       getOverlayInfo;
        NV_VIDEO_GET_SURFACE_COUNT  getVideoSurfaceCount;
        NV_VIDEO_GET_SURFACE_INFO   getVideoSurfaceInfo;
        NV_VIDEO_STATE_INFO         getVideoStateInfo;
    };
} NV_VIDEO_GET_INFO;

#define NV_VIDEO_GET_INFO_VER  MAKE_NVAPI_VERSION(NV_VIDEO_GET_INFO,1)


typedef enum
{
    NV_DISPLAY_POWER_SAVING_NOT_SUPPORTED = -1,
    NV_DISPLAY_POWER_SAVING_DISABLED = 0,
    NV_DISPLAY_POWER_SAVING_ENABLED = 1
} NV_DISPLAY_POWER_SAVING;

///////////////////////////////////////////////////////////////////////////////
//
// Notes about Display Power Saving feature :
//
// This feature works only on LVDS panels and requires that to be active.
// The feature is system specific and can be controlled independent
// of whether the LVDS panel is active.
//
// To control the nvDPS through NVAPI interface, the following registry value
// has to be added:
// only for internal use - DWORD nvDPSSettings = 0x786002B in the same location where BINARY RMGpuId exists.
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_SYS_GetDisplayPowerSavingState
//
// PARAMETERS:     pState - Pointer to NV_DISPLAY_POWER_SAVING variable receiving Power Saving State
//
// DESCRIPTION:    This API queries the current Display Power Saving state
//
//  SUPPORTED OS: Windows XP and higher
//
// HOW TO USE:     NV_DISPLAY_POWER_SAVING State;
//                 ret = NvAPI_SYS_GetDisplayPowerSavingState(&State);
//                 On call success:
//                 State would either be NV_DISPLAY_POWER_SAVING_ENABLED or NV_DISPLAY_POWER_SAVING_DISABLED
//
// RETURN STATUS:
//                 NVAPI_OK - completed request
//                 NVAPI_ERROR - miscellaneous error occurred
//                 NVAPI_NOT_SUPPORTED - Display Power Saving feature is not available on the target hardware
//                 NVAPI_INVALID_ARGUMENT - invalid argument passed
//                 NVAPI_API_NOT_INTIALIZED - nvapi not initialized
//                 NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_GetDisplayPowerSavingState(NV_DISPLAY_POWER_SAVING *pState);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_SYS_SetDisplayPowerSavingState
//
// PARAMETERS:     State - NV_DISPLAY_POWER_SAVING_DISABLED or NV_DISPLAY_POWER_SAVING_ENABLED
//
// DESCRIPTION:    This API sets the current Display Power Saving state
//
//  SUPPORTED OS: Windows XP and higher
//
// HOW TO USE:     NV_DISPLAY_POWER_SAVING State = either NV_DISPLAY_POWER_SAVING_ENABLED or NV_DISPLAY_POWER_SAVING_DISABLED;
//                 ret = NvAPI_SYS_SetDisplayPowerSavingState(State);
//                 On call success:
//                 Display Power Saving feature would be enabled or disabled
//
// RETURN STATUS:
//                 NVAPI_OK - completed request
//                 NVAPI_ERROR - miscellaneous error occurred
//                 NVAPI_NOT_SUPPORTED - Display Power Saving feature is not available on the target hardware
//                 NVAPI_INVALID_ARGUMENT - invalid argument passed
//                 NVAPI_API_NOT_INTIALIZED - nvapi not initialized
//                 NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_SetDisplayPowerSavingState(NV_DISPLAY_POWER_SAVING State);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_SYS_NotifySBiosDisplaySwitch
//
// PARAMETERS:     ulDevicesMask(IN) - Display device mask.
//
// DESCRIPTION:    This API notifies SBIOS of a display switch to display devices specified by ulDevicesMask
//
//  SUPPORTED OS: Windows XP and higher
// HOW TO USE:     ret = NvAPI_NotifySBiosDisplaySwitch(ulDevicesMask);
//                 On call success:
//                 SBIOS will be notified of a display switch to the ulDevicesMask specified display devices.
//
// RETURN STATUS:
//                 NVAPI_OK - completed request
//                 NVAPI_ERROR - miscellaneous error occurred
//                 NVAPI_INVALID_ARGUMENT - invalid argument passed
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_NotifySBiosDisplaySwitch(NvU32 ulDevicesMask);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetSupportedSLIViews
// DESCRIPTION:     Based on the connected state obtained from NvAPI_GPU_GetConnectedSLIOutputs,
//                  this API lets caller enumerate the supported NVIDIA display views when SLI is active.
//                  If SLI is not active then this API returns all the supported nView modes. 
//                  Note : If client make a call with the GPU handle, which doesn't have any 
//                         connected monitors then this API returns NVAPI_NOT_SUPPORTED.
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      hPhysicalGpu(IN) - GPU selection
//                  pTargetViews(OUT) - Array of supported views. Can be NULL to retrieve the pViewCount first. 
//                  pViewCount(IN/OUT) - Count of supported views.
//                  
// RETURN STATUS: 
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter.
//                  NVAPI_NOT_SUPPORTED - This feature is not supported on the selected GPU.
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_GPU_GetSupportedSLIViews(NvPhysicalGpuHandle hPhysicalGpu, NV_TARGET_VIEW_MODE pTargetViews[NVAPI_MAX_VIEW_MODES], NvU32 *pViewCount);

 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_SetTopologyFocusDisplayAndView
// DESCRIPTION:     This API works on the active display GPU and will let the calling app switch 
//                    focus display, and accepts a path info to specify single, clone or dualview.
//                   Note : If SLI is not active then this API returns NVAPI_NO_ACTIVE_SLI_TOPOLOGY.
//
//  SUPPORTED OS: Windows Vista and higher
//                      
// PARAMETERS:      hLogicalGPU(IN) - Active logical gpu topology containing more than one physical gpus.
//                  focusDisplayOutputId(IN) - Connected display output Id on the target GPU which should be focused.
//                  pPathInfo(IN) - Pointer to NV_VIEW_PATH_INFO, specifying device properties in this view.
//                                    The first device entry in the array is the physical primary.
//                                    The device entry with the lowest source id is the desktop primary.
//                  displayView(IN)- Display view selected from NV_TARGET_VIEW_MODE.
//                  
// RETURN STATUS: 
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter.
//                  NVAPI_NO_ACTIVE_SLI_TOPOLOGY - SLI is not active on this device.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetTopologyFocusDisplayAndView(NvLogicalGpuHandle hLogicalGPU, NvU32 focusDisplayOutputId, NV_DISPLAY_PATH_INFO *pPathInfo, NV_TARGET_VIEW_MODE displayView);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_CreateUnAttachedDisplayFromDisplay
//
// DESCRIPTION:     This function will unattach an active display if it is not GDI primary
//
//  SUPPORTED OS: Windows XP and higher
//                     
// PARAMETERS:      hNvDisplay (IN) - Active display handle
//                  pNvUnAttachedDisplayHandle (OUT) - Pointer to the unattached display handle                  
//                  
// RETURN STATUS: 
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - invalid input parameter
//                  NVAPI_EXPECTED_DISPLAY_HANDLE - hNvDisplay is not a valid display handle
//                  NVAPI_EXPECTED_NON_PRIMARY_DISPLAY_HANDLE - the GDI primary handle passed                  
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_CreateUnAttachedDisplayFromDisplay(NvDisplayHandle hNvDisplay, NvUnAttachedDisplayHandle *pNvUnAttachedDisp);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetDriverModel
//
// PARAMETERS:      hPhysicalGpu(IN)        - GPU selection.
//                  pDriverModel(OUT)       - pointer to the Driver Model
//
// DESCRIPTION: Sets Driver Model(pDriverModel) corresponding to the GPU
//              Win7
//                  If GPU is G84 or above - 0x00001100 (corresponds to WDDM 1.1)
//                  Otherwise              - 0x00001000 (corresponds to WDDM 1.0)
//              Vista
//                  Always                 - 0x00001000 (corresponds to WDDM 1.0)
//              WinXP                      - Not Supported
//
//  SUPPORTED OS: Windows Vista and higher
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//                  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//                  NVAPI_INVALID_HANDLE - Invalid handle
//                  NVAPI_API_NOT_INTIALIZED - NvAPI not initialized
//                  NVAPI_NOT_SUPPORTED - Only for Win7 & Vista
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetDriverModel(NvPhysicalGpuHandle hPhysicalGpu, NvU32* pDriverModel);


typedef enum
{
    NV_COMPUTE_GPU_TOPOLOGY_PHYSICS_CAPABLE     = 0x00000001,   // This is Read only GPU flag - Physics capable GPU.
    NV_COMPUTE_GPU_TOPOLOGY_PHYSICS_ENABLE      = 0x00000002,   // This is Read/Write GPU flag - indicates GPU is already enabled for physics.
                                                                // Application can use this flag to request physics to be enabled on this GPU.
                                                                // No ENABLE flag indicates DISABLE Physics on this GPU.
                                                                // By default driver will enable the most preferred GPU for physics and this flag will indicate that state.
    NV_COMPUTE_GPU_TOPOLOGY_PHYSICS_DEDICATED   = 0x00000004,   // This is Read only GPU flag - Physics enabled GPU which is *dedicated* for physics indicates
                                                                // this compute capable GPU was automatically made usable for Physx on CUDA.
    NV_COMPUTE_GPU_TOPOLOGY_PHYSICS_RECOMMENDED = 0x00000008,   // This is Read only GPU flag - Physics GPU which is recommended by the driver.
    
} NV_COMPUTE_GPU_TOPOLOGY_FLAGS;

typedef struct
{
    NvU32 version;  //version 
    NvU32 gpuCount; //total number of compute capable GPUs

    struct 
    {
        NvPhysicalGpuHandle  hPhysicalGpu;      //Compute capable physical gpu handle
        NvU32                flags;             //one or more flags from NV_COMPUTE_GPU_TOPOLOGY_FLAGS

    } computeGpus[NVAPI_MAX_GPU_PER_TOPOLOGY];  //array of compute capable physical GPUs.

} NV_COMPUTE_GPU_TOPOLOGY;

#define NV_COMPUTE_GPU_TOPOLOGY_VER  MAKE_NVAPI_VERSION(NV_COMPUTE_GPU_TOPOLOGY,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_GPU_CudaEnumComputeCapableGpus
//
// DESCRIPTION:    This API enumerates one or more GPUs which are compute capable.
//                 Compute capable GPUs does not necessarily mean usable with CUDA. Applications can make compute capable GPU compute usable by:
//                  1. Enabling Physx using NvAPI_GPU_PhysxSetState OR
//                  2. Enable atleast one display using NvAPI_CreateDisplayFromUnAttachedDisplay on the unattached display handle for the compute GPU.
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:     pPhysicsTopo(OUT) - An array of compute capable gpus.
//
// RETURN STATUS: 
//    NVAPI_OK                          - completed request. The gpuCount indicates if one or more compute capable GPUs are found.
//                                          gpuCount = 1 if atleast one compute capable GPU is found.
//    NVAPI_INCOMPATIBLE_STRUCT_VERSION - structure version is not supported, initialize to NV_COMPUTE_GPU_TOPOLOGY_VER.
//    NVAPI_ERROR                       - Enumeration of the GPUs failed. Make sure atleast one NVIDIA GPU exists in the system.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_CudaEnumComputeCapableGpus(NV_COMPUTE_GPU_TOPOLOGY *pComputeTopo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_GPU_PhysxSetState
//
// DESCRIPTION:    This API allows Compute capable GPUs to be enabled or disabled for Physics using the NV_COMPUTE_GPU_TOPOLOGY_PHYSICS_ENABLE flag.
//                 This API resets the physics enabled GPUs based on the GPUs in the array with NV_COMPUTE_GPU_TOPOLOGY_PHYSICS_ENABLE flag set.
//                 The application should first enumerate all the compute capable GPUs using NvAPI_GPU_CudaEnumComputeCapableGpus.
//                 Then set NV_COMPUTE_GPU_TOPOLOGY_PHYSICS_ENABLE flag only on GPUs to be enabled for Physics. This API ignores all other flags.
//                 This API also allows GPUs to be disabled for Physics - all GPUs without NV_COMPUTE_GPU_TOPOLOGY_PHYSICS_ENABLE flag will be disabled for Physics. 
//                 The Physx driver will persist the applied physics GPU selection across reboots.
//                 This API will activate driver reload to switch GPUs in and out of NV_COMPUTE_GPU_TOPOLOGY_PHYSICS_DEDICATED state based 
//                 on the compute usable state of the GPU. Thus this API will ensure that the Physx selected GPU will always be usable for Physx.
//                 On Vista the calling app must run in elevated mode for the Physx GPU selection to succeed. 
//                 This API resets the default physics driver state if called with pComputeTopo set to NULL.
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:     pComputeTopo(IN/OUT) - An array of compute capable GPUs retrieved from NvAPI_GPU_EnumComputeCapableGpus 
//
// RETURN STATUS: 
//    NVAPI_OK                          - completed request. The gpuCount indicates if one or more physics capable GPU got enabled for physics.
//    NVAPI_ERROR                       - Unable to update the Physx driver state. Install the Physx driver component.
//    NVAPI_INVALID_COMBINATION         - More than one GPU cannot be enabled together for physics. Enable only one physics capable GPU.
//    NVAPI_INVALID_ARGUMENT            - Invalid gpuCount or no physx GPU enabled in pPhysicsTopo passed into this API.
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE- hPhysicalGpu is not a physical GPU handle.
//    NVAPI_EXPECTED_COMPUTE_GPU_HANDLE - hPhysicalGpu is not a compute capable physical GPU handle.
//    NVAPI_NOT_SUPPORTED               - Physx is not supported. Make sure Phsyx software version 8.9.4.0 or higher is installed or uninstall the Phsyx software.
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_PhysxSetState(NV_COMPUTE_GPU_TOPOLOGY *pComputeTopo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_GPU_PhysxQueryRecommendedState
//
// DESCRIPTION:    This API allows application to query the recommended Phsyx GPU from the driver.
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:     pComputeTopo(IN/OUT)     - IN: The full array or a subset of the array of compute capable GPUs retrieved from NvAPI_GPU_EnumComputeCapableGpus 
//                                            OUT: The flag NV_COMPUTE_GPU_TOPOLOGY_PHYSICS_RECOMMENDED will be set on the recommeded GPU in computeGpus array.
//                 pPhysicalComputeGpu(OUT) - Can be NULL. In case of a valid ptr this will also point to the recommended compute GPU.
//
// RETURN STATUS: 
//    NVAPI_OK                          - completed request. Based on the input gpuCount of one of the recommended GPU will get selected. 
//    NVAPI_INVALID_ARGUMENT            - Invalid input gpuCount.
//    NVAPI_EXPECTED_COMPUTE_GPU_HANDLE - hPhysicalGpu is not a compute capable physical GPU handle.
//    NVAPI_NOT_SUPPORTED               - Physx is not supported. Make sure Phsyx software version 8.9.4.0 or higher is installed or uninstall the Phsyx software.
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_PhysxQueryRecommendedState(NV_COMPUTE_GPU_TOPOLOGY *pComputeTopo, NvPhysicalGpuHandle *pPhysicalComputeGpu);


typedef enum 
{ 
    NV_DEEP_IDLE_NOT_SUPPORTED = -1, 
    NV_DEEP_IDLE_DISABLE      = 0, 
    NV_DEEP_IDLE_ENABLE       = 1 
} NV_DEEP_IDLE_STATE;

///////////////////////////////////////////////////////////////////////////////
//
// Notes about GPU Deep Idle feature :
//
// This feature currently works only in simulation mode on G9x via a registry key.
// In the simulation mode, the clocks will be lowered but there won't be a true
// "deep idle" state.
//
// To control the GPU Deep Idle through NVAPI interface, the following registry value
// has to be added:
// only for internal use - DWORD DeepIdleSim = 0 (disable simulation) or 1 (enable simulation)
//                                             in the location where RmGpuId for dGPU exists.   
// 
/////////////////////////////////////////////////////////////////////////////// 

//  SUPPORTED OS: Windows XP and higher
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_GPU_GetDeepIdleState
//
// PARAMETERS:     hLogicalGpu(IN) - logical GPU selection
//                 pState(OUT) - Pointer to NV_DEEP_IDLE_STATE variable receiving GPU Deep Idle State
//
// DESCRIPTION:    This API queries the current GPU Deep Idle state
//
//
// HOW TO USE:     NV_DEEP_IDLE_STATE State;
//                 ret = NvAPI_GPU_GetDeepIdleState(hLogicalGpu, &State);
//                 On call success:
//                 State would either be NV_DEEP_IDLE_ENABLE or NV_DEEP_IDLE_DISABLE 
// 
// RETURN STATUS: 
//                 NVAPI_OK - completed request
//                 NVAPI_ERROR - miscellaneous error occurred
//                 NVAPI_NOT_SUPPORTED - GPU Deep Idle feature is not available on the target hardware
//                 NVAPI_INVALID_HANDLE - logical GPU not found
//                 NVAPI_INVALID_ARGUMENT - invalid argument passed
//                 NVAPI_API_NOT_INTIALIZED - nvapi not initialized
//                 NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//                 NVAPI_EXPECTED_LOGICAL_GPU_HANDLE - handle passed is not a logical GPU handle  
// 
/////////////////////////////////////////////////////////////////////////////// 
NVAPI_INTERFACE NvAPI_GPU_GetDeepIdleState(NvLogicalGpuHandle hLogicalGpu, NV_DEEP_IDLE_STATE *pState);

//  SUPPORTED OS: Windows XP and higher
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_GPU_SetDeepIdleState
//
// PARAMETERS:     hLogicalGpu(IN) - logical GPU selection
//                 pState(IN) - NV_DEEP_IDLE_STATE variable inidicating the state to be set
//
// DESCRIPTION:    This API sets the GPU Deep Idle state
//
// HOW TO USE:     NV_DEEP_IDLE State = either NV_DEEP_IDLE_ENABLE or NV_DEEP_IDLE_DISABLE;
//                 ret = NvAPI_GPU_SetDeepIdleState(hLogicalGpu, State);
//                 On call success:
//                 GPU Deep Idle feature would either be enabled or disabled
//
// RETURN STATUS:
//                 NVAPI_OK - completed request
//                 NVAPI_ERROR - miscellaneous error occurred
//                 NVAPI_NOT_SUPPORTED - GPU Deep Idle feature is not available on the target hardware
//                 NVAPI_INVALID_HANDLE - logical GPU not found
//                 NVAPI_INVALID_ARGUMENT - invalid argument passed
//                 NVAPI_API_NOT_INTIALIZED - nvapi not initialized
//                 NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//                 NVAPI_EXPECTED_LOGICAL_GPU_HANDLE - handle passed is not a logical GPU handle 
// 
/////////////////////////////////////////////////////////////////////////////// 
NVAPI_INTERFACE NvAPI_GPU_SetDeepIdleState(NvLogicalGpuHandle hLogicalGpu, NV_DEEP_IDLE_STATE State);

//  SUPPORTED OS: Windows Vista and higher

typedef enum 
{ 
    NV_DEEP_IDLE_STATISTICS_MODE_NH,    // No heads
    NV_DEEP_IDLE_STATISTICS_MODE_VE,    // Vblank extended
    NV_DEEP_IDLE_STATISTICS_MODE_FO     // FB Off
} NV_DEEP_IDLE_STATISTICS_MODE;

typedef struct
{
    NvU32   version;                    // Structure version
    NvU32   attempts;                   // Number of attempts made to enter Deep Idle
    NvU32   entries;                    // Number of successful entries into Deep Idle
    NvU32   exits;                      // Number of exits out of Deep Idle
    NvU32   time;                       // Amount of time in microseconds spent in Deep Idle
    NvU32   maxEntryLatency;            // maximum latency (in microseconds) for entering Deep Idle
    NvU32   maxExitLatency;             // maximum latency (in microseconds) for exiting Deep Idle
    NvU32   veFrames;                   // number of frames spent in Deep Idle (VE mode only)
    NvU32   veVblankExits;              // number of Deep Idle exits due to end of vblank (VE mode only)
    NvU32   veDeepL1Exits;              // number of Deep Idle exits due to Deep L1 exit (VE mode only)
} NV_DEEP_IDLE_STATISTICS;
#define NV_DEEP_IDLE_STATISTICS_VER MAKE_NVAPI_VERSION(NV_DEEP_IDLE_STATISTICS,1)

/////////////////////////////////////////////////////////////////////////////// 
// 
// FUNCTION NAME:  NvAPI_GPU_SetDeepIdleStatisticsMode
//
// PARAMETERS:     hPhysicalGpu(IN) - GPU selection
//                 Mode(IN)         - NV_DEEP_IDLE_STATISTICS_MODE variable indicating which flavor of Deep Idle for which to collect information
//                 bReset(IN)       - Boolean indicating whether or not all current statistics for the specified mode should be reset to 0
//
// DESCRIPTION:    This API returns statistics about GPU Deep Idle activity
//
// HOW TO USE:     When gathering Deep Idle statistics, call this function first to specify
//                 the Deep Idle flavor of interest and clear previous statistics if desired.
//
// RETURN STATUS:
//                 NVAPI_OK - completed request
//                 NVAPI_ERROR - miscellaneous error occurred
//                 NVAPI_NOT_SUPPORTED - GPU Deep Idle feature is not available on the target hardware
//                 NVAPI_INVALID_HANDLE - logical GPU not found
//                 NVAPI_INVALID_ARGUMENT - invalid argument passed
//                 NVAPI_API_NOT_INTIALIZED - nvapi not initialized
//                 NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//                 NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE- hPhysicalGpu is not a physical GPU handle.
//
/////////////////////////////////////////////////////////////////////////////// 
NVAPI_INTERFACE NvAPI_GPU_SetDeepIdleStatisticsMode(NvPhysicalGpuHandle hPhysicalGpu, NV_DEEP_IDLE_STATISTICS_MODE Mode, NvU32 bReset);

//  SUPPORTED OS: Windows Vista and higher
/////////////////////////////////////////////////////////////////////////////// 
// 
// FUNCTION NAME:  NvAPI_GPU_GetDeepIdleStatistics
//
// PARAMETERS:     hPhysicalGpu(IN) - GPU selection
//                 pStatistics(OUT) - NV_DEEP_IDLE_STATISTICS variable containing Deep Idle activity information
//
// DESCRIPTION:    This API returns statistics about GPU Deep Idle activity
//
// HOW TO USE:     Call this function to get the current statistics information for the Deep Idle
//                 flavor that was specified in the call to NvAPI_GPU_SetDeepIdleStatisticsMode.
//
// RETURN STATUS:
//                 NVAPI_OK - completed request
//                 NVAPI_ERROR - miscellaneous error occurred
//                 NVAPI_NOT_SUPPORTED - GPU Deep Idle feature is not available on the target hardware
//                 NVAPI_INVALID_HANDLE - logical GPU not found
//                 NVAPI_INVALID_ARGUMENT - invalid argument passed
//                 NVAPI_API_NOT_INTIALIZED - nvapi not initialized
//                 NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//                 NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE- hPhysicalGpu is not a physical GPU handle.
//
/////////////////////////////////////////////////////////////////////////////// 
NVAPI_INTERFACE NvAPI_GPU_GetDeepIdleStatistics(NvPhysicalGpuHandle hPhysicalGpu, NV_DEEP_IDLE_STATISTICS *pStatistics);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_CreateConfigurationProfileRegistryKey
//
//  SUPPORTED OS: Windows Vista and higher
//
// DESCRIPTION:   Creates new configuration registry key for current application.
//
//                If there was no configuration profile prior to the function call, 
//                tries to create brand new configuration profile registry key 
//                for a given application and fill it with default values. 
//                If an application already had a configuration profile registry key, does nothing. 
//                Name of the key is automatically determined as the name of the executable that calls this function.
//                Because of this, application executable should have distinct and unique name.
//                If the application is using only one version of DirectX, than the default profile type will be appropriate.
//                If the application is using more than one version of DirectX from same executable,
//                it should use appropriate profile type for each configuration profile.
//
// PARAMETERS:    registryProfileType(IN) - Type of profile that application wants to create.
//                                          Should be one of the symbolic constants defined in NV_STEREO_REGISTRY_PROFILE_TYPE.
//                                          Any other value will cause function to do nothing and return NV_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED.
//
// HOW TO USE:    When there is a need for an application to have default stereo parameter values,
//                use this function to create a key where they will be stored.
//
// RETURN STATUS:
//                NVAPI_OK - Key exists in the registry.
//                NVAPI_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED - This profile type is not supported.
//                NVAPI_STEREO_REGISTRY_ACCESS_FAILED - Access to registry failed.
//                NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//                NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//                NVAPI_ERROR - Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////

typedef enum _NV_StereoRegistryProfileType
{
    NVAPI_STEREO_DEFAULT_REGISTRY_PROFILE, // Default registry configuration profile.
    NVAPI_STEREO_DX9_REGISTRY_PROFILE,     // Separate registry configuration profile for DX9 executable.
    NVAPI_STEREO_DX10_REGISTRY_PROFILE     // Separate registry configuration profile for DX10 executable.
} NV_STEREO_REGISTRY_PROFILE_TYPE;

NVAPI_INTERFACE NvAPI_Stereo_CreateConfigurationProfileRegistryKey(NV_STEREO_REGISTRY_PROFILE_TYPE registryProfileType);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_DeleteConfigurationProfileRegistryKey
//
//  SUPPORTED OS: Windows Vista and higher
//
// DESCRIPTION:   Removes configuration registry key for current application.
//
//                If an application already had a configuration profile prior to the function call, 
//                this function will try to remove application's configuration profile registry key from the registry. 
//                If there was no configuration profile registry key prior to the function call, 
//                the function will do nothing and will not report an error. 
//  
// PARAMETERS:    registryProfileType(IN) - Type of profile that application wants to delete.
//                                          Should be one of the symbolic constants defined in NV_STEREO_REGISTRY_PROFILE_TYPE.
//                                          Any other value will cause function to do nothing and return NV_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED.
//
// RETURN STATUS:
//                NVAPI_OK - Key does not exist in the registry any more.
//                NVAPI_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED - This profile type is not supported.
//                NVAPI_STEREO_REGISTRY_ACCESS_FAILED - Access to registry failed.
//                NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//                NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//                NVAPI_ERROR - Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_DeleteConfigurationProfileRegistryKey(NV_STEREO_REGISTRY_PROFILE_TYPE registryProfileType);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_SetConfigurationProfileValue
//
// PARAMETERS:    registryProfileType(IN) - Type of profile that application wants to access.
//                                          Should be one of the symbolic constants defined in NV_STEREO_REGISTRY_PROFILE_TYPE.
//                                          Any other value will cause function to do nothing and return NV_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED.
//                valueRegistryID(IN)     - ID of the value that is being set.
//                                          Should be one of the symbolic constants defined in NV_STEREO_REGISTRY_PROFILE_TYPE.
//                                          Any other value will cause function to do nothing and return NVAPI_STEREO_REGISTRY_VALUE_NOT_SUPPORTED.
//                pValue(IN)              - Address of the value that is being set. 
//                                          Should be either address of a DWORD or of a float, 
//                                          dependent on the type of the stereo parameter whose value is being set. 
//                                          The API will then cast that address to DWORD* 
//                                          and write whatever is in those 4 bytes as a DWORD to the registry. 
//
//  SUPPORTED OS: Windows Vista and higher
//
// DESCRIPTION:   Sets given parameter value under the application's registry key. 
//
//                If the value does not exist under the application's registry key, 
//                the value will be created under the key. 
//
// RETURN STATUS:
//                NVAPI_OK - Value is written to registry.
//                NVAPI_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED - This profile type is not supported.
//                NVAPI_STEREO_REGISTRY_VALUE_NOT_SUPPORTED - This value is not supported.
//                NVAPI_STEREO_REGISTRY_ACCESS_FAILED - Access to registry failed.
//                NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//                NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//                NVAPI_ERROR - Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////

typedef enum _NV_StereoRegistryID
{
    NVAPI_CONVERGENCE_ID,         // Symbolic constant for convergence registry ID.
    NVAPI_FRUSTUM_ADJUST_MODE_ID, // Symbolic constant for frustum adjust mode registry ID.
} NV_STEREO_REGISTRY_ID;

NVAPI_INTERFACE NvAPI_Stereo_SetConfigurationProfileValue(NV_STEREO_REGISTRY_PROFILE_TYPE registryProfileType, NV_STEREO_REGISTRY_ID valueRegistryID, void *pValue);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_DeleteConfigurationProfileValue
//
// PARAMETERS:    registryProfileType(IN) - Type of profile that application wants to access.
//                                          Should be one of the symbolic constants defined in NV_STEREO_REGISTRY_PROFILE_TYPE.
//                                          Any other value will cause function to do nothing and return NV_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED.
//                valueRegistryID(IN)     - ID of the value that is being deleted.
//                                          Should be one of the symbolic constants defined in NV_STEREO_REGISTRY_PROFILE_TYPE.
//                                          Any other value will cause function to do nothing and return NVAPI_STEREO_REGISTRY_VALUE_NOT_SUPPORTED.
//
//  SUPPORTED OS: Windows Vista and higher
//
// DESCRIPTION:   Removes given value from application's configuration profile registry key. 
//
//                If there is no such value, the function will do nothing and will not report an error. 
//
// RETURN STATUS:
//                NVAPI_OK - Value does not exist in registry any more.
//                NVAPI_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED - This profile type is not supported.
//                NVAPI_STEREO_REGISTRY_VALUE_NOT_SUPPORTED - This value is not supported.
//                NVAPI_STEREO_REGISTRY_ACCESS_FAILED - Access to registry failed.
//                NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//                NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//                NVAPI_ERROR - Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_DeleteConfigurationProfileValue(NV_STEREO_REGISTRY_PROFILE_TYPE registryProfileType, NV_STEREO_REGISTRY_ID valueRegistryID);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_Enable
//
//  SUPPORTED OS: Windows Vista and higher
//
// DESCRIPTION:   Enables stereo mode in the registry. 
//                Call to this function affects entire system.
//                Calls to functions that require stereo enabled with stereo disabled will have no effect,
//                and will return apropriate error code.
//
// RETURN STATUS:
//                NVAPI_OK - Stereo is now enabled.
//                NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//                NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//                NVAPI_ERROR - Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_Enable(void);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_Disable
//
//  SUPPORTED OS: Windows Vista and higher
//
// DESCRIPTION:   Disables stereo mode in the registry. 
//                Call to this function affects entire system.
//                Calls to functions that require stereo enabled with stereo disabled will have no effect,
//                and will return apropriate error code.
//
// RETURN STATUS:
//                NVAPI_OK - Stereo is now disabled.
//                NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//                NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//                NVAPI_ERROR - Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_Disable(void);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_IsEnabled
//
// PARAMETERS:    pIsStereoEnabled(OUT)  - Address where result of the inquiry will be placed.
//
//  SUPPORTED OS: Windows Vista and higher
//
// DESCRIPTION:   Checks if stereo mode is enabled in the registry. 
//
// RETURN STATUS:
//                NVAPI_OK - Check was sucessfully completed and result reflects current state of stereo availability.
//                NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//                NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//                NVAPI_ERROR - Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_IsEnabled(NvU8 *pIsStereoEnabled);



#if defined(_D3D9_H_) || defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_CreateHandleFromIUnknown
//
// PARAMETERS:    pDevice(IN) - Pointer to IUnknown interface that IDirect3DDevice9* in DX9, ID3D10Device*.
//                pStereoHandle(OUT) - Pointer to newly created stereo handle.
//
//  SUPPORTED OS: Windows Vista and higher
//
// DESCRIPTION:   Creates stereo handle, that is used in subsequent calls related to given device interface. 
//                This must be called before any other NvAPI_Stereo_ function for that handle.
//                Multiple devices can be used at one time using multiple calls to this function (one per each device).
//
// HOW TO USE:    After the Direct3D device is created, create stereo handle.
//                On call success:
//                Use all other NvAPI_Stereo_ functions that have stereo handle as first parameter.
//                After the device interface correspondent to the stereo handle is destroyed, 
//                application should call NvAPI_DestroyStereoHandle for that stereo handle.
//
// RETURN STATUS:
//                NVAPI_OK - Stereo handle is created for given device interface.
//                NVAPI_INVALID_ARGUMENT - Provided device interface is invalid.
//                NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//                NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//                NVAPI_ERROR - Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_CreateHandleFromIUnknown(IUnknown *pDevice, StereoHandle *pStereoHandle);
#endif // defined(_D3D9_H_) || defined(__d3d10_h__)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_DestroyHandle
//
// PARAMETERS:    stereoHandle(IN) - Stereo handle that is to be destroyed.
//
//  SUPPORTED OS: Windows Vista and higher
//
// DESCRIPTION:   Destroys stereo handle created with one of NvAPI_Stereo_CreateHandleFrom functions. 
//                This should be called after device corresponding to the handle has been destroyed.
//
// RETURN STATUS:
//                NVAPI_OK - Stereo handle is destroyed.
//                NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//                NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//                NVAPI_ERROR - Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_DestroyHandle(StereoHandle stereoHandle);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_Activate
//
// PARAMETERS:    stereoHandle(IN) - Stereo handle correspondent to device interface.
//
//  SUPPORTED OS: Windows Vista and higher
//
// DESCRIPTION:   Activates stereo for device interface correspondent to given stereo handle.
//                Activating stereo will be possible only if stereo was enabled previously in the registry.
//                Calls to all functions that require stereo activated  
//                with stereo deactivated will have no effect and will return appropriate error code.
//
// HOW TO USE:    After the stereo handle for device interface is created via successfull call to appropriate NvAPI_Stereo_CreateHandleFrom function.
//
// RETURN STATUS:
//                NVAPI_OK - Stereo is turned on.
//                NVAPI_STEREO_INVALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again.
//                NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//                NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//                NVAPI_ERROR - Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_Activate(StereoHandle stereoHandle);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_Deactivate
//
// PARAMETERS:    stereoHandle(IN) - Stereo handle correspondent to device interface.
//
//  SUPPORTED OS: Windows Vista and higher
//
// DESCRIPTION:   Deactivates stereo for given device interface.
//                Calls to all functions that require stereo activated  
//                with stereo deactivated will have no effect and will return appropriate error code.
//
// HOW TO USE:    After the stereo handle for device interface is created via successfull call to appropriate NvAPI_Stereo_CreateHandleFrom function.
//
// RETURN STATUS:
//                NVAPI_OK - Stereo is turned off.
//                NVAPI_STEREO_INVALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again.
//                NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//                NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//                NVAPI_ERROR - Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_Deactivate(StereoHandle stereoHandle);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_IsActivated
//
// PARAMETERS:    stereoHandle(IN) - Stereo handle correspondent to device interface.
//                pIsStereoOn(IN)  - Address where result of the inquiry will be placed.
//
//  SUPPORTED OS: Windows Vista and higher
//
// DESCRIPTION:   Checks if stereo is activated for given device interface. 
//
// HOW TO USE:    After the stereo handle for device interface is created via successfull call to appropriate NvAPI_Stereo_CreateHandleFrom function.
//
// RETURN STATUS:
//                NVAPI_OK - Check was sucessfully completed and result reflects current state of stereo (on/off).
//                NVAPI_STEREO_INVALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again.
//                NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//                NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//                NVAPI_ERROR - Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_IsActivated(StereoHandle stereoHandle, NvU8 *pIsStereoOn);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_GetSeparation
//
// PARAMETERS:    stereoHandle(IN)           - Stereo handle correspondent to device interface.
//                pSeparationPercentage(OUT) - Address of @c float type variable to store current separation percentage in.
//
//  SUPPORTED OS: Windows Vista and higher
//
// DESCRIPTION:   Gets current separation value (in percents). 
//
// HOW TO USE:    After the stereo handle for device interface is created via successfull call to appropriate NvAPI_Stereo_CreateHandleFrom function.
//
// RETURN STATUS:
//                NVAPI_OK - Retrieval of separation percentage was successfull.
//                NVAPI_STEREO_INVALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again.
//                NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//                NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//                NVAPI_ERROR - Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_GetSeparation(StereoHandle stereoHandle, float *pSeparationPercentage);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_SetSeparation
//
// PARAMETERS:    stereoHandle(IN)            - Stereo handle correspondent to device interface.
//                newSeparationPercentage(IN) - New value for separation percentage.
//
//  SUPPORTED OS: Windows Vista and higher
//
// DESCRIPTION:   Sets separation to given percentage. 
//
// HOW TO USE:    After the stereo handle for device interface is created via successfull call to appropriate NvAPI_Stereo_CreateHandleFrom function.
//
// RETURN STATUS:
//                NVAPI_OK - Setting of separation percentage was successfull.
//                NVAPI_STEREO_INVALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again.
//                NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//                NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//                NVAPI_STEREO_PARAMETER_OUT_OF_RANGE - Given separation percentage is out of [0..100] range.
//                NVAPI_ERROR - Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_SetSeparation(StereoHandle stereoHandle, float newSeparationPercentage);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_DecreaseSeparation
//
// PARAMETERS:    stereoHandle(IN) - Stereo handle correspondent to device interface.
//
//  SUPPORTED OS: Windows Vista and higher
//
// DESCRIPTION:   Decreases separation for given device interface (same like Ctrl+F3 hotkey).
//
// HOW TO USE:    After the stereo handle for device interface is created via successfull call to appropriate NvAPI_Stereo_CreateHandleFrom function.
//
// RETURN STATUS:
//                NVAPI_OK - Decrease of separation percentage was successfull.
//                NVAPI_STEREO_INVALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again.
//                NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//                NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//                NVAPI_ERROR - Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_DecreaseSeparation(StereoHandle stereoHandle);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_IncreaseSeparation
//
// PARAMETERS:    stereoHandle(IN) - Stereo handle correspondent to device interface.
//
//  SUPPORTED OS: Windows Vista and higher
//
// DESCRIPTION:   Increases separation for given device interface (same like Ctrl+F4 hotkey).
//
// HOW TO USE:    After the stereo handle for device interface is created via successfull call to appropriate NvAPI_Stereo_CreateHandleFrom function.
//
// RETURN STATUS:
//                NVAPI_OK - Increase of separation percentage was successfull.
//                NVAPI_STEREO_INVALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again.
//                NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//                NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//                NVAPI_ERROR - Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_IncreaseSeparation(StereoHandle stereoHandle);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_GetConvergence
//
// PARAMETERS:    stereoHandle(IN)  - Stereo handle correspondent to device interface.
//                pConvergence(OUT) - Address of @c float type variable to store current convergence value in.
//
//  SUPPORTED OS: Windows Vista and higher
//
// DESCRIPTION:   Gets current convergence value. 
//
// HOW TO USE:    After the stereo handle for device interface is created via successfull call to appropriate NvAPI_Stereo_CreateHandleFrom function.
//
// RETURN STATUS:
//                NVAPI_OK - Retrieval of convergence value was successfull.
//                NVAPI_STEREO_INVALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again.
//                NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//                NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//                NVAPI_ERROR - Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_GetConvergence(StereoHandle stereoHandle, float *pConvergence);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_SetConvergence
//
// PARAMETERS:    stereoHandle(IN)             - Stereo handle correspondent to device interface.
//                newConvergencePercentage(IN) - New value for convergence.
//
//  SUPPORTED OS: Windows Vista and higher
//
// DESCRIPTION:   Sets convergence to given value. 
//
// HOW TO USE:    After the stereo handle for device interface is created via successfull call to appropriate NvAPI_Stereo_CreateHandleFrom function.
//
// RETURN STATUS:
//                NVAPI_OK - Setting of convergence value was successfull.
//                NVAPI_STEREO_INVALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again.
//                NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//                NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//                NVAPI_ERROR - Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_SetConvergence(StereoHandle stereoHandle, float newConvergencePercentage);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_DecreaseConvergence
//
// PARAMETERS:    stereoHandle(IN) - Stereo handle correspondent to device interface.
//
//  SUPPORTED OS: Windows Vista and higher
//
// DESCRIPTION:   Decreases convergence for given device interface (same like Ctrl+F5 hotkey).
//
// HOW TO USE:    After the stereo handle for device interface is created via successfull call to appropriate NvAPI_Stereo_CreateHandleFrom function.
//
// RETURN STATUS:
//                NVAPI_OK - Decrease of convergence was successfull.
//                NVAPI_STEREO_INVALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again.
//                NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//                NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//                NVAPI_ERROR - Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_DecreaseConvergence(StereoHandle stereoHandle);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_IncreaseConvergence
//
// PARAMETERS:    stereoHandle(IN) - Stereo handle correspondent to device interface.
//
//  SUPPORTED OS: Windows Vista and higher
//
// DESCRIPTION:   Increases convergence for given device interface (same like Ctrl+F5 hotkey).
//
// HOW TO USE:    After the stereo handle for device interface is created via successfull call to appropriate NvAPI_Stereo_CreateHandleFrom function.
//
// RETURN STATUS:
//                NVAPI_OK - Increase of convergence was successfull.
//                NVAPI_STEREO_INVALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again.
//                NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//                NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//                NVAPI_ERROR - Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_IncreaseConvergence(StereoHandle stereoHandle);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_GetFrustumAdjustMode
//
// PARAMETERS:    stereoHandle(IN)        - Stereo handle correspondent to device interface.
//                pFrustumAdjustMode(OUT) - Address of the NV_FRUSTUM_ADJUST_MODE type variable to store current frustum value in.
//
//  SUPPORTED OS: Windows Vista and higher
//
// DESCRIPTION:   Gets current frustum adjust mode value. 
//
// HOW TO USE:    After the stereo handle for device interface is created via successfull call to appropriate NvAPI_Stereo_CreateHandleFrom function.
//
// RETURN STATUS:
//                NVAPI_OK - Retrieval of frustum adjust mode was successfull.
//                NVAPI_STEREO_INVALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again.
//                NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//                NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//                NVAPI_ERROR - Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////

typedef enum _NV_FrustumAdjustMode
{
    NVAPI_NO_FRUSTUM_ADJUST,    // Do not adjust frustum.
    NVAPI_FRUSTUM_STRETCH,      // Stretch images in X.
    NVAPI_FRUSTUM_CLEAR_EDGES   // Clear corresponding edges for each eye.
} NV_FRUSTUM_ADJUST_MODE;

NVAPI_INTERFACE NvAPI_Stereo_GetFrustumAdjustMode(StereoHandle stereoHandle, NV_FRUSTUM_ADJUST_MODE *pFrustumAdjustMode);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_SetFrustumAdjustMode
//
// PARAMETERS:    stereoHandle(IN)               - Stereo handle correspondent to device interface.
//                newFrustumAdjustModeValue (IN) - New value for frustum adjust mode.
//                                                 Should be one of the symbolic constants defined in NV_FRUSTUM_ADJUST_MODE.
//                                                 Any other value will cause function to do nothing and return NVAPI_STEREO_FRUSTUM_ADJUST_MODE_NOT_SUPPORTED.
//
//  SUPPORTED OS: Windows Vista and higher
//
// DESCRIPTION:   Sets current frustum adjust mode value. 
//
// HOW TO USE:    After the stereo handle for device interface is created via successfull call to appropriate NvAPI_Stereo_CreateHandleFrom function.
//
// RETURN STATUS:
//                NVAPI_OK - Retrieval of frustum adjust mode was successfull.
//                NVAPI_STEREO_INVALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again.
//                NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//                NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//                NVAPI_STEREO_FRUSTUM_ADJUST_MODE_NOT_SUPPORTED - Given frustum adjust mode is not supported.
//                NVAPI_ERROR - Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_SetFrustumAdjustMode(StereoHandle stereoHandle, NV_FRUSTUM_ADJUST_MODE newFrustumAdjustModeValue);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_CaptureJpegImage
//
// PARAMETERS:    stereoHandle(IN) - Stereo handle correspondent to device interface.
//                quality(IN)      - Quality of the JPEG image to be captured. Integer value betweeen 0 and 100.
//
//  SUPPORTED OS: Windows Vista and higher
//
// DESCRIPTION:   Captures current stereo image in JPEG stereo format with given quality. 
//                Only the last capture call per flip will be effective.
//
// HOW TO USE:    After the stereo handle for device interface is created via successfull call to appropriate NvAPI_Stereo_CreateHandleFrom function.
//
// RETURN STATUS:
//                NVAPI_OK - Image captured.
//                NVAPI_STEREO_INVALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again.
//                NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//                NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//                NVAPI_STEREO_PARAMETER_OUT_OF_RANGE - Given quality is out of [0..100] range.
//                NVAPI_ERROR - Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_CaptureJpegImage(StereoHandle stereoHandle, NvU32 quality);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_CapturePngImage
//
// PARAMETERS:    stereoHandle(IN) - Stereo handle correspondent to device interface.
//
//  SUPPORTED OS: Windows Vista and higher
//
// DESCRIPTION:   Captures current stereo image in PNG stereo format. 
//                Only the last capture call per flip will be effective.
//
// HOW TO USE:    After the stereo handle for device interface is created via successfull call to appropriate NvAPI_Stereo_CreateHandleFrom function.
//
// RETURN STATUS:
//                NVAPI_OK - Image captured.
//                NVAPI_STEREO_INVALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again.
//                NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//                NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//                NVAPI_ERROR - Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_CapturePngImage(StereoHandle stereoHandle);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_ReverseStereoBlitControl
//
// PARAMETERS:    stereoHandle(IN) - Stereo handle correspondent to device interface.
//                TurnOn(IN)       != 0  - turns on, 
//                                 == 0  - turns off 
//
//  SUPPORTED OS: Windows Vista and higher
//
// DESCRIPTION:   Turns on/off reverse stereo blit
//
// HOW TO USE:    After the stereo handle for device interface is created via successfull call to appropriate 
//                NvAPI_Stereo_CreateHandleFrom function.
//                After reversed stereo blit control turned on blit from stereo surface will
//                produce right eye image in the left side of the destination surface and left
//                eye image in the right side of the destination surface
//                In DX9 Dst surface has to be created as render target and StretchRect has to be used.
//                Conditions:
//                1. DstWidth == 2*SrcWidth
//                2. DstHeight == SrcHeight
//                3. Src surface is actually stereo surface.
//                4. SrcRect must be {0,0,SrcWidth,SrcHeight}
//                5. DstRect must be {0,0,DstWidth,DstHeight}
//
//                In DX10 ResourceCopyRegion has to be used 
//                Conditions:
//                1. DstWidth == 2*SrcWidth
//                2. DstHeight == SrcHeight
//                3. dstX == 0,
//                4. dstY == 0,
//                5. dstZ == 0,
//                6  SrcBox: left=top=front==0;
//                           right==SrcWidth; bottom==SrcHeight; back==1;
//
// RETURN STATUS:
//                NVAPI_OK - Retrieval of frustum adjust mode was successfull.
//                NVAPI_STEREO_INVALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again.
//                NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//                NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//                NVAPI_ERROR - Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_ReverseStereoBlitControl(StereoHandle hStereoHandle, NvU8 TurnOn);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_SetNotificationMessage
//
// PARAMETERS:    stereoHandle(IN) - Stereo handle correspondent to device interface.
//                hWnd(IN)         - Window HWND that will be notified when user changed stereo driver state.
//                                   Actual HWND must be cast to an NvU64.
//                messageID(IN)    - MessageID of the message that will be posted to hWnd
//
//  SUPPORTED OS: Windows Vista and higher
//
// DESCRIPTION:   Setup notification message that stereo driver will use to notify application
//                when user changes stereo driver state. 
//                Call this API with NULL hWnd to prohibit notification.
//
//
// HOW TO USE:    After the stereo handle for device interface is created via successfull call to appropriate
//                NvAPI_Stereo_CreateHandleFrom function.
//                
//                When user changes stereo state Activated or Deactivated, separation or conversion
//                stereo driver will post defined message with the folloing parameters
//          
//                wParam == MAKEWPARAM(l, h) where l == 0 if stereo is deactivated
//                                                      1 if stereo is deactivated
//                                                 h  - is current separation. 
//                                                      Actual separation is float(h*100.f/0xFFFF);
//                lParam                           is current conversion. 
//                                                      Actual conversion is *(float*)&lParam
//
// RETURN STATUS:
//                NVAPI_OK - Notification set.
//                NVAPI_STEREO_INVALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again.
//                NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//                NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//                NVAPI_ERROR - Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_SetNotificationMessage(StereoHandle hStereoHandle, NvU64 hWnd,NvU64 messageID);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_SetActiveEye
//
// PARAMETERS:    stereoHandle(IN) - Stereo handle correspondent to device interface.
//                StereoEye(IN)    - Defines active eye in Direct stereo mode
//
//  SUPPORTED OS: Windows Vista and higher
//      
// DESCRIPTION:   Set BackBuffer to left or right in Direct stereo mode.
//                  
// HOW TO USE:    After the stereo handle for device interface is created via successfull call to appropriate 
//                NvAPI_Stereo_CreateHandleFrom function.
//
// RETURN STATUS:
//                NVAPI_OK - Active eye is set.
//                NVAPI_STEREO_INVALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again.
//                NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//                NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//                NVAPI_INVALID_ARGUMENT - StereoEye parameter has not allowed value.
//                NVAPI_SET_NOT_ALLOWED  - Current stereo mode is not Direct
//                NVAPI_ERROR - Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////
typedef enum _NV_StereoActiveEye
{
    NVAPI_STEREO_EYE_RIGHT = 1,
    NVAPI_STEREO_EYE_LEFT = 2,
} NV_STEREO_ACTIVE_EYE;

NVAPI_INTERFACE NvAPI_Stereo_SetActiveEye(StereoHandle hStereoHandle, NV_STEREO_ACTIVE_EYE eye);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_SetDriverMode
//
// PARAMETERS:    stereoHandle(IN) - Stereo handle correspondent to device interface.
//                mode(IN)         - Defines stereo driver mode: Direct or Automatic
//
//  SUPPORTED OS: Windows Vista and higher
//      
// DESCRIPTION:   Set stereo driver mode: Direct or Automatic
//                  
// HOW TO USE:    After the stereo handle for device interface is created via successfull call to appropriate 
//                NvAPI_Stereo_CreateHandleFrom function and before any other DirectX call.
//                Applyed only for DX10 and up.
//
// RETURN STATUS:
//                NVAPI_OK - Active eye is set.
//                NVAPI_STEREO_INVALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again.
//                NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//                NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//                NVAPI_INVALID_ARGUMENT - StereoEye parameter has not allowed value.
//                NVAPI_SET_NOT_ALLOWED  - DX interface is not DX10 and up.
//                NVAPI_ERROR - Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////
typedef enum _NV_StereoDriverMode
{
    NVAPI_STEREO_DRIVER_MODE_AUTOMATIC=0,
    NVAPI_STEREO_DRIVER_MODE_DIRECT   =1,
} NV_STEREO_DRIVER_MODE;

NVAPI_INTERFACE NvAPI_Stereo_SetDriverMode(StereoHandle hStereoHandle, NV_STEREO_DRIVER_MODE mode );

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_GetEyeSeparation
//
// PARAMETERS:    stereoHandle(IN) - Stereo handle correspondent to device interface.
//                pSeparation(OUT) - Eye separation.
//
//  SUPPORTED OS: Windows Vista and higher
//      
// DESCRIPTION:   Return eye separation as <between eye distance>/<phisical screen width> ratio 
//                  
// HOW TO USE:    After the stereo handle for device interface is created via successfull call to appropriate 
//                NvAPI_Stereo_CreateHandleFrom function and before any other DirectX call.
//                Applyed only for DX10 and up.
//
// RETURN STATUS:
//                NVAPI_OK - Active eye is set.
//                NVAPI_STEREO_INVALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again.
//                NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//                NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//                NVAPI_ERROR - Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_GetEyeSeparation(StereoHandle hStereoHandle,  float *pSeparation );

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_IsWindowedModeSupported
//
// PARAMETERS:    bSupported(OUT)   != 0  - supported, 
//                                  == 0  - is not supported 
//
//  SUPPORTED OS: Windows Vista and higher
//
// DESCRIPTION:   Return availibilty of windowed mode stereo
//
// HOW TO USE:    
//
// RETURN STATUS:
//                NVAPI_OK - Retrieval of frustum adjust mode was successfull.
//                NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//                NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//                NVAPI_ERROR - Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_IsWindowedModeSupported(NvU8* bSupported);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D_LinearizeDepthForAO,
//
// PARAMETERS:    pDevice             (IN)       
//                pInputDepthStencil  (IN)   - Depth-stencil surface.
//                ZNear               (IN)   - z near
//                ZFar                (IN)   - z far
//                MinZ                (IN)   - min. z
//                MaxZ                (IN)   - max. z
// 
// DESCRIPTION:   Computes Linear Z. Linearized Z will be stored in a driver-internal buffer (float32).
//
// HOW TO USE:    Call this when rendering opaque objects is done, or before the depth buffer is cleared.
//
// RETURN STATUS:
//
///////////////////////////////////////////////////////////////////////////////
#if (defined(_D3D9_H_) || defined(__d3d10_h__)) && defined(__cplusplus)
//  SUPPORTED OS: Windows XP and higher
NVAPI_INTERFACE NvAPI_D3D_LinearizeDepthForAO(IUnknown *pDevice, IUnknown *pInputDepthStencil, float ZNear, float ZFar, float MinZ, float MaxZ);
#endif (defined(_D3D9_H_) || defined(__d3d10_h__)) && defined(__cplusplus)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_RenderAO,
//                NvAPI_D3D10_RenderAO
//
// PARAMETERS:    pDevice              (IN)       
//                pOutputRT            (IN)  - destination render targets
//                                             IDirect3DSurface9* for DX9
//                                             ID3D10RenderTargetView* for DX10
//                FOVY                 (IN)  - Field of view in Y = 2*atan(1/proj[5]), 
//                                             where proj[5] = ZNear/(h/2), h = screen height in world coord.
//                pInputDepthStencil   (IN)  - depth to be linearized. Use this parameter to perform RenderLinearZ/RenderAO by a single call
//                                             IDirect3DSurface9* for DX9
//                                             ID3D10Resource* for DX10
//                ZNear,ZFar,ZMin,ZMax (IN)  - parameters for depth linearization.
//
// DESCRIPTION:   Computes AO and apply AO to pTargetRT/pTargetRTV
//                Optionally, this call can compute linear depth buffer if pInputDepthStencil is not null.
//                If pInputDepthStencil is null, depth is not linearized by this RenderAO call, and
//                AO will be rendered from the existing linear depth buffer (typically linearized  by previous 
//                NvAPI_D3D9/10_LinearizeDepth call). In this case, ZNear,ZFar,ZMin, and ZMax will be ignored
//
// HOW TO USE:    Call this before rendering transparencies, or before present.
//
// RETURN STATUS:
//
///////////////////////////////////////////////////////////////////////////////
#if (defined(_D3D9_H_) || defined(__d3d10_h__)) && defined(__cplusplus)
//  SUPPORTED OS: Windows XP and higher
NVAPI_INTERFACE NvAPI_D3D_RenderAO(IUnknown *pDevice, IUnknown *pOutputRT, float FOVY, IUnknown *pInputDepthStencil, float ZNear, float ZFar, float MinZ, float MaxZ);
#endif (defined(_D3D9_H_) || defined(__d3d10_h__)) && defined(__cplusplus)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D_SetAOParams
//                NvAPI_D3D_GetAOParams
//
// PARAMETERS:    pDevice (IN)       
//                pParams (IN)  for NvAPI_D3D_SetAOParams();
//                pParams (OUT) for NvAPI_D3D_GetAOParams();
//
// DESCRIPTION:   get/set AO parameters
//                  
// HOW TO USE:    Call this before transparency rendering, or before present.
//
// RETURN STATUS:
//
///////////////////////////////////////////////////////////////////////////////
//  SUPPORTED OS: Windows XP and higher

#if (defined(_D3D9_H_) || defined(__d3d10_h__)) && defined(__cplusplus)
typedef enum
{
    NVAPIAO_LOW     = 0,
    NVAPIAO_MEDIUM  = 1,
    NVAPIAO_HIGH    = 2,
    NVAPIAO_UNKNOWN = 0x10000,
} NVAPIAO_Quality;

typedef enum
{
    NVAPIAO_NORMALFREE  = 0,
    NVAPIAO_USENORMAL   = 1,
} NVAPIAO_ShaderType;

typedef enum
{
    NVAPIAO_DISABLED         = 0,
    NVAPIAO_DEMO_VSPLIT      = 1,
    NVAPIAO_DEMO_HSPLIT      = 2,
    NVAPIAO_DEMO_VWIPER      = 3,
    NVAPIAO_DEMO_PIP0        = 4,
    NVAPIAO_DEMO_PIP1        = 5,
    NVAPIAO_DEMO_VCOLUMNS    = 6,
    NVAPIAO_DISPLAY_LINEARZ  = 100,
} NVAPIAO_DebugMode;

typedef struct
{
    NvU32               version;                   // NVAPIAOParam version = NVAPIAOPARAM_VERSION1
    NVAPIAO_Quality     quality;                   // default = low.           // quality = low/med/high 
    NVAPIAO_ShaderType  shaderType;                // default = normalfree.    // shaderType = usenormal, normalfree 
    float               strength;                  // default = 1.0            // the greater the darker 
    float               angleBias;                 // default = 0              // degrees 
    float               radius;                    // default = 3.             // normalized by ZNear, i.e., radius =3 makes the AO radius= 3*ZNear 
    float               fallOffDistOfHalfStrength; // default = 500.           // normalized by ZNear, i.e., fallOffDistOfHalfStrength=500 makes AO fall off into half of fallOffAmount at Z=ZNear*500 
    float               fallOffAmount;             // defulat = 0              // 0=no AO fall off, 1=full attenuation. 
    float               blurRadius;                // defulat = 10 pixels      // 
    float               blurSharpness;             // default = 0.3            // 0.2~1.0 
    NvU32               disableBlending;           // [bool] default = false   // disable multiplying AO to target
    NVAPIAO_DebugMode   debugMode;
} NVAPIAOParam;

#define NVAPIAOPARAM_VERSION1  MAKE_NVAPI_VERSION(NVAPIAOParam,1)

//  SUPPORTED OS: Windows XP and higher
NVAPI_INTERFACE NvAPI_D3D_SetAOParams(IUnknown *pDevice, NVAPIAOParam *pParam);

//  SUPPORTED OS: Windows XP and higher
NVAPI_INTERFACE NvAPI_D3D_GetAOParams(IUnknown *pDevice, NVAPIAOParam *pParam);

#endif //#if defined(_D3D9_H_) || defined(__d3d10_h__)

/////////////////////////////////////////////////////////////////////////
// Video Input Output (VIO) API
/////////////////////////////////////////////////////////////////////////


typedef NvU32   NVVIOOWNERID;                               // Unique identifier for VIO owner (process identifier or NVVIOOWNERID_NONE)
#define NVVIOOWNERID_NONE                   0               // Unregistered ownerId

typedef enum _NVVIOOWNERTYPE                                // Owner type for device
{
    NVVIOOWNERTYPE_NONE                             ,       //  No owner for device
    NVVIOOWNERTYPE_APPLICATION                      ,       //  Application owns device
    NVVIOOWNERTYPE_DESKTOP                          ,       //  Desktop transparent mode owns device (not applicable for video input)
}NVVIOOWNERTYPE;

// Access rights for NvAPI_VIO_Open()
#define NVVIO_O_READ                        0x00000000      // Read access             (not applicable for video output)
#define NVVIO_O_WRITE_EXCLUSIVE             0x00010001      // Write exclusive access  (not applicable for video input)

#define NVVIO_VALID_ACCESSRIGHTS            (NVVIO_O_READ              | \
                                             NVVIO_O_WRITE_EXCLUSIVE   )

              
// VIO_DATA.ulOwnerID high-bit is set only if device has been initialized by VIOAPI
// examined at NvAPI_GetCapabilities|NvAPI_VIO_Open to determine if settings need to be applied from registry or POR state read
#define NVVIO_OWNERID_INITIALIZED  0x80000000

// VIO_DATA.ulOwnerID next-bit is set only if device is currently in exclusive write access mode from NvAPI_VIO_Open()
#define NVVIO_OWNERID_EXCLUSIVE    0x40000000
                                              
// VIO_DATA.ulOwnerID lower bits are:
//  NVGVOOWNERTYPE_xxx enumerations indicating use context
#define NVVIO_OWNERID_TYPEMASK     0x0FFFFFFF // mask for NVVIOOWNERTYPE_xxx              
//---------------------------------------------------------------------
// Enumerations
//---------------------------------------------------------------------

// Video signal format and resolution
typedef enum _NVVIOSIGNALFORMAT
{
    NVVIOSIGNALFORMAT_NONE,							// Invalid signal format 
    NVVIOSIGNALFORMAT_487I_59_94_SMPTE259_NTSC,     // 01  487i    59.94Hz  (SMPTE259) NTSC
    NVVIOSIGNALFORMAT_576I_50_00_SMPTE259_PAL,      // 02  576i    50.00Hz  (SMPTE259) PAL
    NVVIOSIGNALFORMAT_1035I_59_94_SMPTE260,         // 03  1035i   59.94Hz  (SMPTE260)
    NVVIOSIGNALFORMAT_1035I_60_00_SMPTE260,         // 04  1035i   60.00Hz  (SMPTE260)
    NVVIOSIGNALFORMAT_1080I_50_00_SMPTE295,         // 05  1080i   50.00Hz  (SMPTE295)
    NVVIOSIGNALFORMAT_1080I_60_00_SMPTE274,         // 06  1080i   60.00Hz  (SMPTE274)
    NVVIOSIGNALFORMAT_1080I_59_94_SMPTE274,         // 07  1080i   59.94Hz  (SMPTE274)
    NVVIOSIGNALFORMAT_1080I_50_00_SMPTE274,         // 08  1080i   50.00Hz  (SMPTE274)
    NVVIOSIGNALFORMAT_1080P_30_00_SMPTE274,         // 09  1080p   30.00Hz  (SMPTE274)
    NVVIOSIGNALFORMAT_1080P_29_97_SMPTE274,         // 10  1080p   29.97Hz  (SMPTE274)
    NVVIOSIGNALFORMAT_1080P_25_00_SMPTE274,         // 11  1080p   25.00Hz  (SMPTE274)
    NVVIOSIGNALFORMAT_1080P_24_00_SMPTE274,         // 12  1080p   24.00Hz  (SMPTE274)
    NVVIOSIGNALFORMAT_1080P_23_976_SMPTE274,        // 13  1080p   23.976Hz (SMPTE274)
    NVVIOSIGNALFORMAT_720P_60_00_SMPTE296,          // 14  720p    60.00Hz  (SMPTE296)
    NVVIOSIGNALFORMAT_720P_59_94_SMPTE296,          // 15  720p    59.94Hz  (SMPTE296)
    NVVIOSIGNALFORMAT_720P_50_00_SMPTE296,          // 16  720p    50.00Hz  (SMPTE296)
    NVVIOSIGNALFORMAT_1080I_48_00_SMPTE274,         // 17  1080I   48.00Hz  (SMPTE274)
    NVVIOSIGNALFORMAT_1080I_47_96_SMPTE274,         // 18  1080I   47.96Hz  (SMPTE274)
    NVVIOSIGNALFORMAT_720P_30_00_SMPTE296,          // 19  720p    30.00Hz  (SMPTE296)
    NVVIOSIGNALFORMAT_720P_29_97_SMPTE296,          // 20  720p    29.97Hz  (SMPTE296)
    NVVIOSIGNALFORMAT_720P_25_00_SMPTE296,          // 21  720p    25.00Hz  (SMPTE296)
    NVVIOSIGNALFORMAT_2048P_30_00_SMPTE372,         // 22  2048p   30.00Hz  (SMPTE372)
    NVVIOSIGNALFORMAT_2048P_29_97_SMPTE372,         // 23  2048p   29.97Hz  (SMPTE372)
    NVVIOSIGNALFORMAT_2048I_60_00_SMPTE372,         // 24  2048i   60.00Hz  (SMPTE372)
    NVVIOSIGNALFORMAT_2048I_59_94_SMPTE372,         // 25  2048i   59.94Hz  (SMPTE372)
    NVVIOSIGNALFORMAT_2048P_25_00_SMPTE372,         // 26  2048p   25.00Hz  (SMPTE372)
    NVVIOSIGNALFORMAT_2048I_50_00_SMPTE372,         // 27  2048i   50.00Hz  (SMPTE372)
    NVVIOSIGNALFORMAT_2048P_24_00_SMPTE372,         // 28  2048p   24.00Hz  (SMPTE372)
    NVVIOSIGNALFORMAT_2048P_23_98_SMPTE372,         // 29  2048p   23.98Hz  (SMPTE372)
    NVVIOSIGNALFORMAT_2048I_48_00_SMPTE372,         // 30  2048i   48.00Hz  (SMPTE372)
    NVVIOSIGNALFORMAT_2048I_47_96_SMPTE372,         // 31  2048i   47.96Hz  (SMPTE372)
    
    NVVIOSIGNALFORMAT_1080PSF_25_00_SMPTE274,       // 32  1080PsF 25.00Hz  (SMPTE274)
    NVVIOSIGNALFORMAT_1080PSF_29_97_SMPTE274,       // 33  1080PsF 29.97Hz  (SMPTE274)
    NVVIOSIGNALFORMAT_1080PSF_30_00_SMPTE274,       // 34  1080PsF 30.00Hz  (SMPTE274)
    NVVIOSIGNALFORMAT_1080PSF_24_00_SMPTE274,       // 35  1080PsF 24.00Hz  (SMPTE274)
    NVVIOSIGNALFORMAT_1080PSF_23_98_SMPTE274,       // 36  1080PsF 23.98Hz  (SMPTE274)
    
    NVVIOSIGNALFORMAT_END                           // 37  To indicate end of signal format list
}NVVIOSIGNALFORMAT;

// SMPTE standards format
typedef enum _NVVIOVIDEOSTANDARD
{
    NVVIOVIDEOSTANDARD_SMPTE259                        ,       // SMPTE259
    NVVIOVIDEOSTANDARD_SMPTE260                        ,       // SMPTE260
    NVVIOVIDEOSTANDARD_SMPTE274                        ,       // SMPTE274
    NVVIOVIDEOSTANDARD_SMPTE295                        ,       // SMPTE295
    NVVIOVIDEOSTANDARD_SMPTE296                        ,       // SMPTE296
    NVVIOVIDEOSTANDARD_SMPTE372                        ,       // SMPTE372
}NVVIOVIDEOSTANDARD;

// HD or SD video type
typedef enum _NVVIOVIDEOTYPE
{
    NVVIOVIDEOTYPE_SD                                  ,       // Standard-definition (SD)
    NVVIOVIDEOTYPE_HD                                  ,       // High-definition     (HD)
}NVVIOVIDEOTYPE;

// Interlace mode
typedef enum _NVVIOINTERLACEMODE 
{
    NVVIOINTERLACEMODE_PROGRESSIVE                     ,       // Progressive               (p)
    NVVIOINTERLACEMODE_INTERLACE                       ,       // Interlace                 (i)
    NVVIOINTERLACEMODE_PSF                             ,       // Progressive Segment Frame (psf)
}NVVIOINTERLACEMODE;

// Video data format
typedef enum _NVVIODATAFORMAT
{
    NVVIODATAFORMAT_UNKNOWN   = -1                     ,       // Invalid DataFormat
    NVVIODATAFORMAT_R8G8B8_TO_YCRCB444                 ,       // R8:G8:B8                => YCrCb  (4:4:4)
    NVVIODATAFORMAT_R8G8B8A8_TO_YCRCBA4444             ,       // R8:G8:B8:A8             => YCrCbA (4:4:4:4)
    NVVIODATAFORMAT_R8G8B8Z10_TO_YCRCBZ4444            ,       // R8:G8:B8:Z10            => YCrCbZ (4:4:4:4)
    NVVIODATAFORMAT_R8G8B8_TO_YCRCB422                 ,       // R8:G8:B8                => YCrCb  (4:2:2)
    NVVIODATAFORMAT_R8G8B8A8_TO_YCRCBA4224             ,       // R8:G8:B8:A8             => YCrCbA (4:2:2:4)
    NVVIODATAFORMAT_R8G8B8Z10_TO_YCRCBZ4224            ,       // R8:G8:B8:Z10            => YCrCbZ (4:2:2:4)
    NVVIODATAFORMAT_X8X8X8_444_PASSTHRU                ,       // R8:G8:B8                => RGB    (4:4:4)
    NVVIODATAFORMAT_X8X8X8A8_4444_PASSTHRU             ,       // R8:G8:B8:A8             => RGBA   (4:4:4:4)
    NVVIODATAFORMAT_X8X8X8Z10_4444_PASSTHRU            ,       // R8:G8:B8:Z10            => RGBZ   (4:4:4:4)
    NVVIODATAFORMAT_X10X10X10_444_PASSTHRU             ,       // Y10:CR10:CB10           => YCrCb  (4:4:4)
    NVVIODATAFORMAT_X10X8X8_444_PASSTHRU               ,       // Y10:CR8:CB8             => YCrCb  (4:4:4)
    NVVIODATAFORMAT_X10X8X8A10_4444_PASSTHRU           ,       // Y10:CR8:CB8:A10         => YCrCbA (4:4:4:4)
    NVVIODATAFORMAT_X10X8X8Z10_4444_PASSTHRU           ,       // Y10:CR8:CB8:Z10         => YCrCbZ (4:4:4:4)
    NVVIODATAFORMAT_DUAL_R8G8B8_TO_DUAL_YCRCB422       ,       // R8:G8:B8 + R8:G8:B8     => YCrCb  (4:2:2 + 4:2:2)
    NVVIODATAFORMAT_DUAL_X8X8X8_TO_DUAL_422_PASSTHRU   ,       // Y8:CR8:CB8 + Y8:CR8:CB8 => YCrCb  (4:2:2 + 4:2:2)
    NVVIODATAFORMAT_R10G10B10_TO_YCRCB422              ,       // R10:G10:B10             => YCrCb  (4:2:2)
    NVVIODATAFORMAT_R10G10B10_TO_YCRCB444              ,       // R10:G10:B10             => YCrCb  (4:4:4)
    NVVIODATAFORMAT_X12X12X12_444_PASSTHRU             ,       // X12:X12:X12             => XXX    (4:4:4)
    NVVIODATAFORMAT_Y12CR12CB12_TO_YCRCB422            ,       // Y12:CR12:CB12           => YCrCb  (4:2:2)
    NVVIODATAFORMAT_Y10CR10CB10_TO_YCRCB422            ,       // Y10:CR10:CB10           => YCrCb  (4:2:2)
    NVVIODATAFORMAT_Y8CR8CB8_TO_YCRCB422               ,       // Y8:CR8:CB8              => YCrCb  (4:2:2)
    NVVIODATAFORMAT_Y10CR8CB8A10_TO_YCRCBA4224         ,       // Y10:CR8:CB8:A10         => YCrCbA (4:2:2:4)
    NVVIODATAFORMAT_R10G10B10_TO_RGB444                ,       // R10:G10:B10             => RGB    (4:4:4)
    NVVIODATAFORMAT_R12G12B12_TO_YCRCB444              ,       // R12:G12:B12             => YCrCb  (4:4:4)
    NVVIODATAFORMAT_R12G12B12_TO_YCRCB422              ,       // R12:G12:B12             => YCrCb  (4:2:2)
    NVVIODATAFORMAT_X12X12X12_422_PASSTHRU             ,       // X12:X12:X12             => XXX    (4:2:2)
}NVVIODATAFORMAT;

// Video output area
typedef enum _NVVIOOUTPUTAREA
{
    NVVIOOUTPUTAREA_FULLSIZE                           ,       // Output to entire video resolution (full size)
    NVVIOOUTPUTAREA_SAFEACTION                         ,       // Output to centered 90% of video resolution (safe action)
    NVVIOOUTPUTAREA_SAFETITLE                          ,       // Output to centered 80% of video resolution (safe title)
}NVVIOOUTPUTAREA;

// Synchronization source
typedef enum _NVVIOSYNCSOURCE
{
    NVVIOSYNCSOURCE_SDISYNC                            ,       // SDI Sync  (Digital input)
    NVVIOSYNCSOURCE_COMPSYNC                           ,       // COMP Sync (Composite input)
}NVVIOSYNCSOURCE;

// Composite synchronization type
typedef enum _NVVIOCOMPSYNCTYPE
{
    NVVIOCOMPSYNCTYPE_AUTO                             ,       // Auto-detect
    NVVIOCOMPSYNCTYPE_BILEVEL                          ,       // Bi-level signal
    NVVIOCOMPSYNCTYPE_TRILEVEL                         ,       // Tri-level signal
}NVVIOCOMPSYNCTYPE;

// Video input output status
typedef enum _NVVIOINPUTOUTPUTSTATUS
{
    NVINPUTOUTPUTSTATUS_OFF                            ,       // Not in use
    NVINPUTOUTPUTSTATUS_ERROR                          ,       // Error detected
    NVINPUTOUTPUTSTATUS_SDI_SD                         ,       // SDI (standard-definition)
    NVINPUTOUTPUTSTATUS_SDI_HD                         ,       // SDI (high-definition)
}NVVIOINPUTOUTPUTSTATUS;

// Synchronization input status
typedef enum _NVVIOSYNCSTATUS
{
    NVVIOSYNCSTATUS_OFF                                ,       // Sync not detected
    NVVIOSYNCSTATUS_ERROR                              ,       // Error detected
    NVVIOSYNCSTATUS_SYNCLOSS                           ,       // Genlock in use, format mismatch with output
    NVVIOSYNCSTATUS_COMPOSITE                          ,       // Composite sync
    NVVIOSYNCSTATUS_SDI_SD                             ,       // SDI sync (standard-definition)
    NVVIOSYNCSTATUS_SDI_HD                             ,       // SDI sync (high-definition)
}NVVIOSYNCSTATUS;

//Video Capture Status
typedef enum _NVVIOCAPTURESTATUS
{
    NVVIOSTATUS_STOPPED                                ,       // Sync not detected
    NVVIOSTATUS_RUNNING                                ,       // Error detected
    NVVIOSTATUS_ERROR                                  ,       // Genlock in use, format mismatch with output
}NVVIOCAPTURESTATUS;

//Video Capture Status
typedef enum _NVVIOSTATUSTYPE
{
    NVVIOSTATUSTYPE_IN                                 ,       // Input Status
    NVVIOSTATUSTYPE_OUT                                ,       // Output Status
}NVVIOSTATUSTYPE;

#define NVAPI_MAX_VIO_DEVICES                 8   // Assumption, maximum 4 SDI input and 4 SDI output cards supported on a system
#define NVAPI_MAX_VIO_JACKS                   4   // 4 physical jacks supported on each SDI input card.
#define NVAPI_MAX_VIO_CHANNELS_PER_JACK       2   // Each physical jack an on SDI input card can have
                                                  // two "channels" in the case of "3G" VideoFormats, as specified
                                                  // by SMPTE 425; for non-3G VideoFormats, only the first channel within
                                                  // a physical jack is valid
#define NVAPI_MAX_VIO_STREAMS                 4   // 4 Streams, 1 per physical jack
#define NVAPI_MIN_VIO_STREAMS                 1   
#define NVAPI_MAX_VIO_LINKS_PER_STREAM        2   // SDI input supports a max of 2 links per stream
#define NVAPI_MAX_FRAMELOCK_MAPPING_MODES     20
#define NVAPI_GVI_MIN_RAW_CAPTURE_IMAGES      1   // Min number of capture images         
#define NVAPI_GVI_MAX_RAW_CAPTURE_IMAGES      32  // Max number of capture images 
#define NVAPI_GVI_DEFAULT_RAW_CAPTURE_IMAGES  5   // Default number of capture images

// Data Signal notification events. These need a event handler in RM.
// Register/Unregister and PopEvent NVAPI's are already available.

// Device configuration
typedef enum _NVVIOCONFIGTYPE
{
    NVVIOCONFIGTYPE_IN                                 ,       // Input Status
    NVVIOCONFIGTYPE_OUT                                ,       // Output Status
}NVVIOCONFIGTYPE;

typedef enum _NVVIOCOLORSPACE
{
    NVVIOCOLORSPACE_UNKNOWN,
    NVVIOCOLORSPACE_YCBCR,
    NVVIOCOLORSPACE_YCBCRA,
    NVVIOCOLORSPACE_YCBCRD,
    NVVIOCOLORSPACE_GBR,
    NVVIOCOLORSPACE_GBRA,
    NVVIOCOLORSPACE_GBRD,
} NVVIOCOLORSPACE;

// Component sampling
typedef enum _NVVIOCOMPONENTSAMPLING
{
    NVVIOCOMPONENTSAMPLING_UNKNOWN,
    NVVIOCOMPONENTSAMPLING_4444,
    NVVIOCOMPONENTSAMPLING_4224,
    NVVIOCOMPONENTSAMPLING_444,
    NVVIOCOMPONENTSAMPLING_422
} NVVIOCOMPONENTSAMPLING;

typedef enum _NVVIOBITSPERCOMPONENT
{
    NVVIOBITSPERCOMPONENT_UNKNOWN,
    NVVIOBITSPERCOMPONENT_8,
    NVVIOBITSPERCOMPONENT_10,
    NVVIOBITSPERCOMPONENT_12,
} NVVIOBITSPERCOMPONENT;

typedef enum _NVVIOLINKID 
{
    NVVIOLINKID_UNKNOWN,
    NVVIOLINKID_A,
    NVVIOLINKID_B,
    NVVIOLINKID_C,
    NVVIOLINKID_D
} NVVIOLINKID;

//---------------------------------------------------------------------
// Structures
//---------------------------------------------------------------------

#define NVVIOCAPS_VIDOUT_SDI                0x00000001      // Supports Serial Digital Interface (SDI) output
#define NVVIOCAPS_SYNC_INTERNAL             0x00000100      // Supports Internal timing source
#define NVVIOCAPS_SYNC_GENLOCK              0x00000200      // Supports Genlock timing source
#define NVVIOCAPS_SYNCSRC_SDI               0x00001000      // Supports Serial Digital Interface (SDI) synchronization input
#define NVVIOCAPS_SYNCSRC_COMP              0x00002000      // Supports Composite synchronization input
#define NVVIOCAPS_OUTPUTMODE_DESKTOP        0x00010000      // Supports Desktop transparent mode
#define NVVIOCAPS_OUTPUTMODE_OPENGL         0x00020000      // Supports OpenGL application mode
#define NVVIOCAPS_VIDIN_SDI                 0x00100000      // Supports Serial Digital Interface (SDI) input

#define NVVIOCLASS_SDI                      0x00000001      // SDI-class interface: SDI output with two genlock inputs

// Device capabilities
typedef struct _NVVIOCAPS
{
    NvU32             version;                              // Structure version
    NvAPI_String      adapterName;                          // Graphics adapter name
    NvU32             adapterClass;                         // Graphics adapter classes (NVVIOCLASS_SDI mask)
    NvU32             adapterCaps;                          // Graphics adapter capabilities (NVVIOCAPS_* mask)
    NvU32             dipSwitch;                            // On-board DIP switch settings bits
    NvU32             dipSwitchReserved;                    // On-board DIP switch settings reserved bits
    NvU32             boardID;                              // Board ID
    struct                                                  //
    {                                                       // Driver version
        NvU32          majorVersion;                        // Major version
        NvU32          minorVersion;                        // Minor version
    } driver;                                               //
    struct                                                  //
    {                                                       // Firmware version
        NvU32          majorVersion;                        // Major version
        NvU32          minorVersion;                        // Minor version
    } firmWare;                                             //
    NVVIOOWNERID      ownerId;                              // Unique identifier for owner of video output (NVVIOOWNERID_INVALID if free running)
    NVVIOOWNERTYPE    ownerType;                            // Owner type (OpenGL application or Desktop mode)
} NVVIOCAPS;

#define NVVIOCAPS_VER   MAKE_NVAPI_VERSION(NVVIOCAPS,1)

// Input channel status
typedef struct _NVVIOCHANNELSTATUS
{
    NvU32                  smpte352;                         // 4-byte SMPTE 352 video payload identifier
    NVVIOSIGNALFORMAT      signalFormat;                     // Signal format
    NVVIOBITSPERCOMPONENT  bitsPerComponent;                 // Bits per component
    NVVIOCOMPONENTSAMPLING samplingFormat;                   // Sampling format
    NVVIOCOLORSPACE        colorSpace;                       // Color space
    NVVIOLINKID            linkID;                           // Link ID
} NVVIOCHANNELSTATUS;

// Input device status
typedef struct _NVVIOINPUTSTATUS
{
    NVVIOCHANNELSTATUS     vidIn[NVAPI_MAX_VIO_JACKS][NVAPI_MAX_VIO_CHANNELS_PER_JACK];     // Video input status per channel within a jack
    NVVIOCAPTURESTATUS     captureStatus;                  // status of video capture
} NVVIOINPUTSTATUS;

// Output device status
typedef struct _NVVIOOUTPUTSTATUS
{
    NVVIOINPUTOUTPUTSTATUS	vid1Out;                        // Video 1 output status
    NVVIOINPUTOUTPUTSTATUS	vid2Out;                        // Video 2 output status
    NVVIOSYNCSTATUS			sdiSyncIn;                      // SDI sync input status
    NVVIOSYNCSTATUS			compSyncIn;                     // Composite sync input status
    NvU32					syncEnable;                     // Sync enable (TRUE if using syncSource)
    NVVIOSYNCSOURCE			syncSource;                     // Sync source
    NVVIOSIGNALFORMAT		syncFormat;                     // Sync format
    NvU32					frameLockEnable;                // Framelock enable flag
    NvU32					outputVideoLocked;              // Output locked status
    NvU32					dataIntegrityCheckErrorCount;   // Data integrity check error count
    NvU32					dataIntegrityCheckEnabled;      // Data integrity check status enabled 
    NvU32					dataIntegrityCheckFailed;       // Data integrity check status failed 
    NvU32                   uSyncSourceLocked;              // genlocked to framelocked to ref signal
    NvU32                   uPowerOn;                       // TRUE: indicates there is sufficient power
} NVVIOOUTPUTSTATUS;

// Video device status.
typedef struct _NVVIOSTATUS
{
    NvU32				  version;                        // Structure version
    NVVIOSTATUSTYPE       nvvioStatusType;                // Input or Output status
    union                                                   
    {
        NVVIOINPUTSTATUS  inStatus;                       //  Input device status
        NVVIOOUTPUTSTATUS outStatus;                      //  Output device status
    }vioStatus;                                      
} NVVIOSTATUS;

#define NVVIOSTATUS_VER   MAKE_NVAPI_VERSION(NVVIOSTATUS,1)

// Output region
typedef struct _NVVIOOUTPUTREGION
{
    NvU32              x;                                    // Horizontal origin in pixels
    NvU32              y;                                    // Vertical origin in pixels
    NvU32              width;                                // Width of region in pixels
    NvU32              height;                               // Height of region in pixels
} NVVIOOUTPUTREGION;

// Gamma ramp (8-bit index)
typedef struct _NVVIOGAMMARAMP8
{
    NvU16              uRed[256];                            // Red channel gamma ramp (8-bit index, 16-bit values)
    NvU16              uGreen[256];                          // Green channel gamma ramp (8-bit index, 16-bit values)
    NvU16              uBlue[256];                           // Blue channel gamma ramp (8-bit index, 16-bit values)
} NVVIOGAMMARAMP8;

// Gamma ramp (10-bit index)
typedef struct _NVVIOGAMMARAMP10
{
    NvU16              uRed[1024];                           // Red channel gamma ramp (10-bit index, 16-bit values)
    NvU16              uGreen[1024];                         // Green channel gamma ramp (10-bit index, 16-bit values)
    NvU16              uBlue[1024];                          // Blue channel gamma ramp (10-bit index, 16-bit values)
} NVVIOGAMMARAMP10;

// Sync delay
typedef struct _NVVIOSYNCDELAY
{
    NvU32              version;                              // Structure version
    NvU32              horizontalDelay;                      // Horizontal delay in pixels
    NvU32              verticalDelay;                        // Vertical delay in lines
} NVVIOSYNCDELAY;

#define NVVIOSYNCDELAY_VER   MAKE_NVAPI_VERSION(NVVIOSYNCDELAY,1)


// Video mode information
typedef struct _NVVIOVIDEOMODE
{
    NvU32                horizontalPixels;                   // Horizontal resolution (in pixels)
    NvU32                verticalLines;                      // Vertical resolution for frame (in lines)
    float                fFrameRate;                         // Frame rate
    NVVIOINTERLACEMODE   interlaceMode;                      // Interlace mode 
    NVVIOVIDEOSTANDARD   videoStandard;                      // SMPTE standards format
    NVVIOVIDEOTYPE       videoType;                          // HD or SD signal classification
} NVVIOVIDEOMODE;

// Signal format details
typedef struct _NVVIOSIGNALFORMATDETAIL
{
    NVVIOSIGNALFORMAT    signalFormat;                       // Signal format enumerated value
    NVVIOVIDEOMODE       videoMode;                          // Video mode for signal format
}NVVIOSIGNALFORMATDETAIL;

// Buffer formats
#define NVVIOBUFFERFORMAT_R8G8B8                  0x00000001   // R8:G8:B8
#define NVVIOBUFFERFORMAT_R8G8B8Z24               0x00000002   // R8:G8:B8:Z24
#define NVVIOBUFFERFORMAT_R8G8B8A8                0x00000004   // R8:G8:B8:A8       
#define NVVIOBUFFERFORMAT_R8G8B8A8Z24             0x00000008   // R8:G8:B8:A8:Z24
#define NVVIOBUFFERFORMAT_R16FPG16FPB16FP         0x00000010   // R16FP:G16FP:B16FP
#define NVVIOBUFFERFORMAT_R16FPG16FPB16FPZ24      0x00000020   // R16FP:G16FP:B16FP:Z24
#define NVVIOBUFFERFORMAT_R16FPG16FPB16FPA16FP    0x00000040   // R16FP:G16FP:B16FP:A16FP
#define NVVIOBUFFERFORMAT_R16FPG16FPB16FPA16FPZ24 0x00000080   // R16FP:G16FP:B16FP:A16FP:Z24

// Data format details
typedef struct _NVVIODATAFORMATDETAIL
{
    NVVIODATAFORMAT   dataFormat;                              // Data format enumerated value
    NvU32             vioCaps;                                 // Data format capabilities (NVVIOCAPS_* mask)
}NVVIODATAFORMATDETAIL;

// Colorspace conversion
typedef struct _NVVIOCOLORCONVERSION
{   
    NvU32       version;                                    //  Structure version
    float       colorMatrix[3][3];                          //  Output[n] =
    float       colorOffset[3];                             //  Input[0] * colorMatrix[n][0] +
    float       colorScale[3];                              //  Input[1] * colorMatrix[n][1] +
                                                            //  Input[2] * colorMatrix[n][2] +
                                                            //  OutputRange * colorOffset[n]
                                                            //  where OutputRange is the standard magnitude of
                                                            //  Output[n][n] and colorMatrix and colorOffset 
                                                            //  values are within the range -1.0 to +1.0
    NvU32      compositeSafe;                               //  compositeSafe constrains luminance range when using composite output
} NVVIOCOLORCONVERSION;

#define NVVIOCOLORCONVERSION_VER   MAKE_NVAPI_VERSION(NVVIOCOLORCONVERSION,1)

// Gamma correction
typedef struct _NVVIOGAMMACORRECTION
{
    NvU32            version;                               // Structure version
    NvU32            vioGammaCorrectionType;                // Gamma correction type (8-bit or 10-bit)
    union                                                   // Gamma correction:
    {                                                       
        NVVIOGAMMARAMP8  gammaRamp8;                        // Gamma ramp (8-bit index, 16-bit values)
        NVVIOGAMMARAMP10 gammaRamp10;                       // Gamma ramp (10-bit index, 16-bit values)
    }gammaRamp;                                      
    float            fGammaValueR;							// Red Gamma value within gamma ranges. 0.5 - 6.0
    float            fGammaValueG;							// Green Gamma value within gamma ranges. 0.5 - 6.0
    float            fGammaValueB;							// Blue Gamma value within gamma ranges. 0.5 - 6.0
} NVVIOGAMMACORRECTION;

#define NVVIOGAMMACORRECTION_VER   MAKE_NVAPI_VERSION(NVVIOGAMMACORRECTION,1)

#define MAX_NUM_COMPOSITE_RANGE      2                      // maximum number of ranges per channel

typedef struct _NVVIOCOMPOSITERANGE
{
    NvU32   uRange;
    NvU32   uEnabled;
    NvU32   uMin;
    NvU32   uMax;
} NVVIOCOMPOSITERANGE;


// Device configuration (fields masks indicating NVVIOCONFIG fields to use for NvVioGet/Set/Test/CreateDefaultConfig())
#define NVVIOCONFIG_SIGNALFORMAT            0x00000001      // dwFields: signalFormat
#define NVVIOCONFIG_DATAFORMAT              0x00000002      // dwFields: dataFormat
#define NVVIOCONFIG_OUTPUTREGION            0x00000004      // dwFields: outputRegion
#define NVVIOCONFIG_OUTPUTAREA              0x00000008      // dwFields: outputArea
#define NVVIOCONFIG_COLORCONVERSION         0x00000010      // dwFields: colorConversion
#define NVVIOCONFIG_GAMMACORRECTION         0x00000020      // dwFields: gammaCorrection
#define NVVIOCONFIG_SYNCSOURCEENABLE        0x00000040      // dwFields: syncSource and syncEnable
#define NVVIOCONFIG_SYNCDELAY               0x00000080      // dwFields: syncDelay
#define NVVIOCONFIG_COMPOSITESYNCTYPE       0x00000100      // dwFields: compositeSyncType
#define NVVIOCONFIG_FRAMELOCKENABLE         0x00000200      // dwFields: EnableFramelock
#define NVVIOCONFIG_422FILTER               0x00000400      // dwFields: bEnable422Filter
#define NVVIOCONFIG_COMPOSITETERMINATE      0x00000800      // dwFields: bCompositeTerminate
#define NVVIOCONFIG_DATAINTEGRITYCHECK      0x00001000      // dwFields: bEnableDataIntegrityCheck
#define NVVIOCONFIG_CSCOVERRIDE             0x00002000      // dwFields: colorConversion override
#define NVVIOCONFIG_FLIPQUEUELENGTH         0x00004000      // dwFields: flipqueuelength control
#define NVVIOCONFIG_ANCTIMECODEGENERATION   0x00008000      // dwFields: bEnableANCTimeCodeGeneration
#define NVVIOCONFIG_COMPOSITE               0x00010000      // dwFields: bEnableComposite
#define NVVIOCONFIG_ALPHAKEYCOMPOSITE       0x00020000      // dwFields: bEnableAlphaKeyComposite
#define NVVIOCONFIG_COMPOSITE_Y             0x00040000      // dwFields: compRange
#define NVVIOCONFIG_COMPOSITE_CR            0x00080000      // dwFields: compRange
#define NVVIOCONFIG_COMPOSITE_CB            0x00100000      // dwFields: compRange
#define NVVIOCONFIG_FULL_COLOR_RANGE        0x00200000      // dwFields: bEnableFullColorRange
#define NVVIOCONFIG_RGB_DATA                0x00400000      // dwFields: bEnableRGBData
#define NVVIOCONFIG_RESERVED_SDIOUTPUTENABLE         0x00800000      // dwFields: bEnableSDIOutput
#define NVVIOCONFIG_STREAMS                 0x01000000      // dwFields: streams

// Don't forget to update NVVIOCONFIG_VALIDFIELDS in NvVIOApiInternals.h when NVVIOCONFIG_ALLFIELDS changes.
#define NVVIOCONFIG_ALLFIELDS   ( NVVIOCONFIG_SIGNALFORMAT          | \
                                  NVVIOCONFIG_DATAFORMAT            | \
                                  NVVIOCONFIG_OUTPUTREGION          | \
                                  NVVIOCONFIG_OUTPUTAREA            | \
                                  NVVIOCONFIG_COLORCONVERSION       | \
                                  NVVIOCONFIG_GAMMACORRECTION       | \
                                  NVVIOCONFIG_SYNCSOURCEENABLE      | \
                                  NVVIOCONFIG_SYNCDELAY             | \
                                  NVVIOCONFIG_COMPOSITESYNCTYPE     | \
                                  NVVIOCONFIG_FRAMELOCKENABLE       | \
                                  NVVIOCONFIG_422FILTER             | \
                                  NVVIOCONFIG_COMPOSITETERMINATE    | \
                                  NVVIOCONFIG_DATAINTEGRITYCHECK    | \
                                  NVVIOCONFIG_CSCOVERRIDE           | \
                                  NVVIOCONFIG_FLIPQUEUELENGTH       | \
                                  NVVIOCONFIG_ANCTIMECODEGENERATION | \
                                  NVVIOCONFIG_COMPOSITE             | \
                                  NVVIOCONFIG_ALPHAKEYCOMPOSITE     | \
                                  NVVIOCONFIG_COMPOSITE_Y           | \
                                  NVVIOCONFIG_COMPOSITE_CR          | \
                                  NVVIOCONFIG_COMPOSITE_CB          | \
                                  NVVIOCONFIG_FULL_COLOR_RANGE      | \
                                  NVVIOCONFIG_RGB_DATA              | \
                                  NVVIOCONFIG_RESERVED_SDIOUTPUTENABLE | \
                                  NVVIOCONFIG_STREAMS)

#define NVVIOCONFIG_VALIDFIELDS  ( NVVIOCONFIG_SIGNALFORMAT          | \
                                   NVVIOCONFIG_DATAFORMAT            | \
                                   NVVIOCONFIG_OUTPUTREGION          | \
                                   NVVIOCONFIG_OUTPUTAREA            | \
                                   NVVIOCONFIG_COLORCONVERSION       | \
                                   NVVIOCONFIG_GAMMACORRECTION       | \
                                   NVVIOCONFIG_SYNCSOURCEENABLE      | \
                                   NVVIOCONFIG_SYNCDELAY             | \
                                   NVVIOCONFIG_COMPOSITESYNCTYPE     | \
                                   NVVIOCONFIG_FRAMELOCKENABLE       | \
                                   NVVIOCONFIG_RESERVED_SDIOUTPUTENABLE | \
                                   NVVIOCONFIG_422FILTER             | \
                                   NVVIOCONFIG_COMPOSITETERMINATE    | \
                                   NVVIOCONFIG_DATAINTEGRITYCHECK    | \
                                   NVVIOCONFIG_CSCOVERRIDE           | \
                                   NVVIOCONFIG_FLIPQUEUELENGTH       | \
                                   NVVIOCONFIG_ANCTIMECODEGENERATION | \
                                   NVVIOCONFIG_COMPOSITE             | \
                                   NVVIOCONFIG_ALPHAKEYCOMPOSITE     | \
                                   NVVIOCONFIG_COMPOSITE_Y           | \
                                   NVVIOCONFIG_COMPOSITE_CR          | \
                                   NVVIOCONFIG_COMPOSITE_CB          | \
                                   NVVIOCONFIG_FULL_COLOR_RANGE      | \
                                   NVVIOCONFIG_RGB_DATA              | \
                                   NVVIOCONFIG_RESERVED_SDIOUTPUTENABLE | \
                                   NVVIOCONFIG_STREAMS)

#define NVVIOCONFIG_DRIVERFIELDS ( NVVIOCONFIG_OUTPUTREGION          | \
                                   NVVIOCONFIG_OUTPUTAREA            | \
                                   NVVIOCONFIG_COLORCONVERSION       | \
                                   NVVIOCONFIG_FLIPQUEUELENGTH)

#define NVVIOCONFIG_GAMMAFIELDS  ( NVVIOCONFIG_GAMMACORRECTION       )

#define NVVIOCONFIG_RMCTRLFIELDS ( NVVIOCONFIG_SIGNALFORMAT          | \
                                   NVVIOCONFIG_DATAFORMAT            | \
                                   NVVIOCONFIG_SYNCSOURCEENABLE      | \
                                   NVVIOCONFIG_COMPOSITESYNCTYPE     | \
                                   NVVIOCONFIG_FRAMELOCKENABLE       | \
                                   NVVIOCONFIG_422FILTER             | \
                                   NVVIOCONFIG_COMPOSITETERMINATE    | \
                                   NVVIOCONFIG_DATAINTEGRITYCHECK    | \
                                   NVVIOCONFIG_COMPOSITE             | \
                                   NVVIOCONFIG_ALPHAKEYCOMPOSITE     | \
                                   NVVIOCONFIG_COMPOSITE_Y           | \
                                   NVVIOCONFIG_COMPOSITE_CR          | \
                                   NVVIOCONFIG_COMPOSITE_CB)

#define NVVIOCONFIG_RMSKEWFIELDS ( NVVIOCONFIG_SYNCDELAY             )

#define NVVIOCONFIG_ALLOWSDIRUNNING_FIELDS ( NVVIOCONFIG_DATAINTEGRITYCHECK     | \
                                             NVVIOCONFIG_SYNCDELAY              | \
                                             NVVIOCONFIG_CSCOVERRIDE            | \
                                             NVVIOCONFIG_ANCTIMECODEGENERATION  | \
                                             NVVIOCONFIG_COMPOSITE              | \
                                             NVVIOCONFIG_ALPHAKEYCOMPOSITE      | \
                                             NVVIOCONFIG_COMPOSITE_Y            | \
                                             NVVIOCONFIG_COMPOSITE_CR           | \
                                             NVVIOCONFIG_COMPOSITE_CB)
                                             
 #define NVVIOCONFIG_RMMODESET_FIELDS ( NVVIOCONFIG_SIGNALFORMAT         | \
                                        NVVIOCONFIG_DATAFORMAT           | \
                                        NVVIOCONFIG_SYNCSOURCEENABLE     | \
                                        NVVIOCONFIG_FRAMELOCKENABLE      | \
                                        NVVIOCONFIG_COMPOSITESYNCTYPE )                                            
                                             

// Output device configuration
// No members can be deleted from below structure. Only add new members at the 
// end of the structure
typedef struct _NVVIOOUTPUTCONFIG
{
    NVVIOSIGNALFORMAT    signalFormat;                         // Signal format for video output
    NVVIODATAFORMAT      dataFormat;                           // Data format for video output
    NVVIOOUTPUTREGION    outputRegion;                         // Region for video output (Desktop mode)
    NVVIOOUTPUTAREA      outputArea;                           // Usable resolution for video output (safe area)
    NVVIOCOLORCONVERSION colorConversion;                      // Color conversion.
    NVVIOGAMMACORRECTION gammaCorrection;
    NvU32                syncEnable;                           // Sync enable (TRUE to use syncSource)
    NVVIOSYNCSOURCE      syncSource;                           // Sync source
    NVVIOSYNCDELAY       syncDelay;                            // Sync delay
    NVVIOCOMPSYNCTYPE    compositeSyncType;                    // Composite sync type
    NvU32                frameLockEnable;                      // Flag indicating whether framelock was on/off
    NvU32                psfSignalFormat;                      // Inidcates whether contained format is PSF Signal format
    NvU32                enable422Filter;                      // Enables/Disables 4:2:2 filter
    NvU32                compositeTerminate;                   // Composite termination
    NvU32                enableDataIntegrityCheck;             // Enable data integrity check: true - enable, false - disable
    NvU32                cscOverride;                          // Use provided CSC color matrix to overwrite 
    NvU32                flipQueueLength;                      // Number of buffers used for the internal flipqueue
    NvU32                enableANCTimeCodeGeneration;          // Enable SDI ANC time code generation
    NvU32                enableComposite;                      // Enable composite
    NvU32                enableAlphaKeyComposite;              // Enable Alpha key composite
    NVVIOCOMPOSITERANGE  compRange;                            // Composite ranges
    NvU8                 reservedData[256];                    // Inicates last stored SDI output state TRUE-ON / FALSE-OFF
    NvU32                enableFullColorRange;                 // Flag indicating Full Color Range
    NvU32                enableRGBData;                        // Indicates data is in RGB format
} NVVIOOUTPUTCONFIG;

// Stream configuration
typedef struct _NVVIOSTREAM
{
    NvU32                   bitsPerComponent;                     // Bits per component
    NVVIOCOMPONENTSAMPLING  sampling;                             // Sampling   
    NvU32                   expansionEnable;                      // Enable/disable 4:2:2->4:4:4 expansion
    NvU32                   numLinks;                             // Number of active links
    struct
    {
        NvU32               jack;                                 // This stream's link[i] will use the specified (0-based) channel within the
        NvU32               channel;                              // specified (0-based) jack
    } links[NVAPI_MAX_VIO_LINKS_PER_STREAM];
} NVVIOSTREAM;

// Input device configuration
typedef struct _NVVIOINPUTCONFIG
{
    NvU32                numRawCaptureImages;                  // numRawCaptureImages is the number of frames to keep in the capture queue. 
                                                               // must be between NVAPI_GVI_MIN_RAW_CAPTURE_IMAGES and NVAPI_GVI_MAX_RAW_CAPTURE_IMAGES, 
    NVVIOSIGNALFORMAT    signalFormat;                         // Signal format.
                                                               // Please note that both numRawCaptureImages and signalFormat should be set together.
    NvU32                numStreams;                           // Number of active streams.
    NVVIOSTREAM          streams[NVAPI_MAX_VIO_STREAMS];       // Stream configurations
} NVVIOINPUTCONFIG;

typedef struct _NVVIOCONFIG
{
    NvU32                version;                              // Structure version
    NvU32                fields;                               // Caller sets to NVVIOCONFIG_* mask for fields to use
    NVVIOCONFIGTYPE      nvvioConfigType;                      // Input or Output configuration
    union                                                   
    {
        NVVIOINPUTCONFIG  inConfig;                            //  Input device configuration
        NVVIOOUTPUTCONFIG outConfig;                           //  Output device configuration
    }vioConfig; 
} NVVIOCONFIG;

#define NVVIOCONFIG_VER   MAKE_NVAPI_VERSION(NVVIOCONFIG,1)

typedef struct
{
    NvPhysicalGpuHandle					hPhysicalGpu;					//handle to Physical GPU (This could be NULL for GVI device if its not binded)
    NvVioHandle                         hVioHandle;                     //handle to SDI Input/Output device
    NvU32                               vioId;                          //device Id of SDI Input/Output device
    NvU32                               outputId;						//deviceMask of the SDI display connected to GVO device. 
                                                                        //outputId will be 0 for GVI device.
} NVVIOTOPOLOGYTARGET;													

typedef struct _NV_VIO_TOPOLOGY
{
    NvU32                       version;
    NvU32                       vioTotalDeviceCount;                    //How many vio targets are valid
    NVVIOTOPOLOGYTARGET         vioTarget[NVAPI_MAX_VIO_DEVICES];       //Array of vio targets
}NV_VIO_TOPOLOGY, NVVIOTOPOLOGY;

#define NV_VIO_TOPOLOGY_VER  MAKE_NVAPI_VERSION(NV_VIO_TOPOLOGY,1)
#define NVVIOTOPOLOGY_VER    MAKE_NVAPI_VERSION(NVVIOTOPOLOGY,1)

//---------------------------------------------------------------------
// Function:    NvAPI_VIO_GetCapabilities
//
// Description: Determine graphics adapter video I/O capabilities.
//
//  SUPPORTED OS: Windows XP and higher
//
// Parameters:  NvVioHandle[IN] - The caller provides the SDI device handle as input.
//              pAdapterCaps[OUT] - Pointer to receive capabilities
//
// Returns:     NVAPI_OK                          - Success
//              NVAPI_API_NOT_INTIALIZED          - NVAPI Not Initialized
//              NVAPI_INVALID_ARGUMENT            - Arguments passed to API are not valid
//              NVAPI_INCOMPATIBLE_STRUCT_VERSION - NVVIOCAPS struct version used by the app is not compatible
//              NVAPI_NOT_SUPPORTED                - Video I/O not supported
//              NVAPI_ERROR                       - NVAPI Random errors
//---------------------------------------------------------------------
NVAPI_INTERFACE NvAPI_VIO_GetCapabilities(NvVioHandle     hVioHandle,
                                          NVVIOCAPS       *pAdapterCaps);

//---------------------------------------------------------------------
// Function:    NvAPI_VIO_Open
//
// Description: Open graphics adapter for video I/O operations
//              using the OpenGL application interface.  Read operations
//              are permitted in this mode by multiple clients, but Write 
//              operations are application exclusive.
//
//  SUPPORTED OS: Windows XP and higher
//
// Parameters:  NvVioHandle[IN]     - The caller provides the SDI output device handle as input.
//              vioClass[IN]        - Class interface (NVVIOCLASS_* value)
//              ownerType[IN]       - user should specify the ownerType ( NVVIOOWNERTYPE_APPLICATION or NVVIOOWNERTYPE_DESKTOP)
//
// Returns:     NVAPI_OK                          - Success
//              NVAPI_API_NOT_INTIALIZED          - NVAPI Not Initialized
//              NVAPI_INVALID_ARGUMENT            - Arguments passed to API are not valid
//              NVAPI_NOT_SUPPORTED                - Video I/O not supported
//              NVAPI_ERROR                       - NVAPI Random errors
//              NVAPI_DEVICE_BUSY                 - Access denied for requested access
//---------------------------------------------------------------------
NVAPI_INTERFACE NvAPI_VIO_Open(NvVioHandle       hVioHandle,
                               NvU32             vioClass,
                               NVVIOOWNERTYPE    ownerType);
 
//---------------------------------------------------------------------
// Function:    NvAPI_VIO_Close
//
// Description: Closes graphics adapter for Graphics to Video operations
//              using the OpenGL application interface.  Closing an 
//              OpenGL handle releases the device.
//
//  SUPPORTED OS: Windows XP and higher
//
// Parameters:  NvVioHandle[IN]  - The caller provides the SDI output device handle as input.
//              bRelease         - boolean value to decide on keeping or releasing ownership
//
// Returns:     NVAPI_OK                          - Success
//              NVAPI_API_NOT_INTIALIZED          - NVAPI Not Initialized
//              NVAPI_INVALID_ARGUMENT            - Arguments passed to API are not valid
//              NVAPI_NOT_SUPPORTED                - Video I/O not supported
//              NVAPI_ERROR                       - NVAPI Random errors
//              NVAPI_DEVICE_BUSY                 - Access denied for requested access
//---------------------------------------------------------------------
NVAPI_INTERFACE NvAPI_VIO_Close(NvVioHandle       hVioHandle,
                                NvU32             bRelease);

//---------------------------------------------------------------------
// Function:    NvAPI_VIO_Status
//
// Description: Get Video I/O LED status.
//
//  SUPPORTED OS: Windows XP and higher
//
// Parameters:  NvVioHandle[IN] - The caller provides the SDI device handle as input.
//              pStatus(OUT)   - returns pointer to the NVVIOSTATUS
//
// Returns:     NVAPI_OK                          - Success
//              NVAPI_API_NOT_INTIALIZED          - NVAPI Not Initialized
//              NVAPI_INVALID_ARGUMENT            - Arguments passed to API are not valid
//              NVAPI_INCOMPATIBLE_STRUCT_VERSION - Invalid structure version
//              NVAPI_NOT_SUPPORTED               - Video I/O not supported
//              NVAPI_ERROR                       - NVAPI Random errors
//---------------------------------------------------------------------
NVAPI_INTERFACE NvAPI_VIO_Status(NvVioHandle     hVioHandle, 
                                 NVVIOSTATUS     *pStatus);

//---------------------------------------------------------------------
// Function:    NvAPI_VIO_SyncFormatDetect
//
// Description: Detects Video I/O incoming sync video format.
//
//  SUPPORTED OS: Windows XP and higher
//
// Parameters:  NvVioHandle[IN] - The caller provides the SDI device handle as input.
//              pWait(OUT)     - Pointer to receive milliseconds to wait 
//                               before VIOStatus will return detected 
//                               syncFormat.
//
// Returns:     NVAPI_OK                          - Success
//              NVAPI_API_NOT_INTIALIZED          - NVAPI Not Initialized
//              NVAPI_INVALID_ARGUMENT            - Arguments passed to API are not valid
//              NVAPI_NOT_SUPPORTED               - Video I/O not supported
//              NVAPI_ERROR                       - NVAPI Random errors
//---------------------------------------------------------------------
NVAPI_INTERFACE NvAPI_VIO_SyncFormatDetect(NvVioHandle hVioHandle,
                                           NvU32       *pWait);

//---------------------------------------------------------------------
// Function:    NvAPI_VIO_GetConfig
//
// Description: Get Graphics to Video configuration.
//
//  SUPPORTED OS: Windows XP and higher
//
// Parameters:  NvVioHandle[IN] - The caller provides the SDI device handle as input.
//              pConfig(OUT)    - Pointer to Graphics to Video configuration
//
// Returns:     NVAPI_OK                          - Success
//              NVAPI_API_NOT_INTIALIZED          - NVAPI Not Initialized
//              NVAPI_INVALID_ARGUMENT            - Arguments passed to API are not valid
//              NVAPI_INCOMPATIBLE_STRUCT_VERSION - Invalid structure version
//              NVAPI_NOT_SUPPORTED               - Video I/O not supported
//              NVAPI_ERROR                       - NVAPI Random errors
//---------------------------------------------------------------------
NVAPI_INTERFACE NvAPI_VIO_GetConfig(NvVioHandle        hVioHandle,
                                    NVVIOCONFIG        *pConfig); 

//---------------------------------------------------------------------
// Function:    NvAPI_VIO_SetConfig
//
// Description: Set Graphics to Video configuration.
//
//  SUPPORTED OS: Windows XP and higher
//
// Parameters:  NvVioHandle[IN]     - The caller provides the SDI device handle as input.
//              pConfig(IN)         - Pointer to Graphics to Video config
//
// Returns:     NVAPI_OK                          - Success
//              NVAPI_API_NOT_INTIALIZED          - NVAPI Not Initialized
//              NVAPI_INVALID_ARGUMENT            - Arguments passed to API are not valid
//              NVAPI_INCOMPATIBLE_STRUCT_VERSION - Stucture version invalid
//              NVAPI_NOT_SUPPORTED               - Video I/O not supported
//              NVAPI_ERROR                       - NVAPI Random errors
//              NVAPI_DEVICE_BUSY                 - Access denied for requested access
//---------------------------------------------------------------------
NVAPI_INTERFACE NvAPI_VIO_SetConfig(NvVioHandle            hVioHandle,
                                    const NVVIOCONFIG      *pConfig);

//---------------------------------------------------------------------
// Function:    NvAPI_VIO_SetCSC
//
// Description: Set colorspace conversion parameters.
//
//  SUPPORTED OS: Windows XP and higher
//
// Parameters:  NvVioHandle[IN]     - The caller provides the SDI device handle as input.
//              pCSC(IN)            - Pointer to CSC parameters
//
// Returns:     NVAPI_OK                          - Success
//              NVAPI_API_NOT_INTIALIZED          - NVAPI Not Initialized
//              NVAPI_INVALID_ARGUMENT            - Arguments passed to API are not valid
//              NVAPI_INCOMPATIBLE_STRUCT_VERSION - Stucture version invalid
//              NVAPI_NOT_SUPPORTED               - Video I/O not supported
//              NVAPI_ERROR                       - NVAPI Random errors
//              NVAPI_DEVICE_BUSY                 - Access denied for requested access
//---------------------------------------------------------------------
NVAPI_INTERFACE NvAPI_VIO_SetCSC(NvVioHandle           hVioHandle,
                                 NVVIOCOLORCONVERSION  *pCSC);

//---------------------------------------------------------------------
// Function:    NvAPI_VIO_GetCSC
//
// Description: Get colorspace conversion parameters.
//
//  SUPPORTED OS: Windows XP and higher
//
// Parameters:  NvVioHandle[IN]     - The caller provides the SDI device handle as input.
//              pCSC(OUT)           - Pointer to CSC parameters
//
// Returns:     NVAPI_OK                          - Success
//              NVAPI_API_NOT_INTIALIZED          - NVAPI Not Initialized
//              NVAPI_INVALID_ARGUMENT            - Arguments passed to API are not valid
//              NVAPI_INCOMPATIBLE_STRUCT_VERSION - Stucture version invalid
//              NVAPI_NOT_SUPPORTED               - Video I/O not supported
//              NVAPI_ERROR                       - NVAPI Random errors
//---------------------------------------------------------------------
NVAPI_INTERFACE NvAPI_VIO_GetCSC(NvVioHandle           hVioHandle,
                                 NVVIOCOLORCONVERSION  *pCSC);

//---------------------------------------------------------------------
// Function:    NvAPI_VIO_SetGamma
//
// Description: Set gamma conversion parameters.
//
//  SUPPORTED OS: Windows XP and higher
//
// Parameters:  NvVioHandle[IN]     - The caller provides the SDI device handle as input.
//              pGamma(IN)          - Pointer to gamma parameters
//
// Returns:     NVAPI_OK                          - Success
//              NVAPI_API_NOT_INTIALIZED          - NVAPI Not Initialized
//              NVAPI_INVALID_ARGUMENT            - Arguments passed to API are not valid
//              NVAPI_INCOMPATIBLE_STRUCT_VERSION - Stucture version invalid
//              NVAPI_NOT_SUPPORTED               - Video I/O not supported
//              NVAPI_ERROR                       - NVAPI Random errors
//              NVAPI_DEVICE_BUSY                 - Access denied for requested access
//---------------------------------------------------------------------
NVAPI_INTERFACE NvAPI_VIO_SetGamma(NvVioHandle           hVioHandle,
                                   NVVIOGAMMACORRECTION  *pGamma);

//---------------------------------------------------------------------
// Function:    NvAPI_VIO_GetGamma
//
// Description: Get gamma conversion parameters.
//
//  SUPPORTED OS: Windows XP and higher
//
// Parameters:  NvVioHandle[IN]     - The caller provides the SDI device handle as input.
//              pGamma(OUT)         - Pointer to gamma parameters
//
// Returns:     NVAPI_OK                          - Success
//              NVAPI_API_NOT_INTIALIZED          - NVAPI Not Initialized
//              NVAPI_INVALID_ARGUMENT            - Arguments passed to API are not valid
//              NVAPI_INCOMPATIBLE_STRUCT_VERSION - Stucture version invalid
//              NVAPI_NOT_SUPPORTED               - Video I/O not supported
//              NVAPI_ERROR                       - NVAPI Random errors
//---------------------------------------------------------------------
NVAPI_INTERFACE NvAPI_VIO_GetGamma(NvVioHandle           hVioHandle,
                                   NVVIOGAMMACORRECTION* pGamma);
 
//---------------------------------------------------------------------
// Function:    NvAPI_VIO_SetSyncDelay
//
// Description: Set sync delay parameters.
//
//  SUPPORTED OS: Windows XP and higher
//
// Parameters:  NvVioHandle[IN] - The caller provides the SDI device handle as input.
//              pSyncDelay(IN)  - const Pointer to sync delay parameters
//
// Returns:     NVAPI_OK                          - Success
//              NVAPI_API_NOT_INTIALIZED          - NVAPI Not Initialized
//              NVAPI_INVALID_ARGUMENT            - Arguments passed to API are not valid
//              NVAPI_INCOMPATIBLE_STRUCT_VERSION - Stucture version invalid
//              NVAPI_ERROR                       - NVAPI Random errors
//              NVAPI_DEVICE_BUSY                 - Access denied for requested access
//---------------------------------------------------------------------
NVAPI_INTERFACE NvAPI_VIO_SetSyncDelay(NvVioHandle            hVioHandle,
                                       const NVVIOSYNCDELAY   *pSyncDelay);

//---------------------------------------------------------------------
// Function:    NvAPI_VIO_GetSyncDelay
//
// Description: Get sync delay parameters.
//
//  SUPPORTED OS: Windows XP and higher
//
// Parameters:  NvVioHandle[IN]     - The caller provides the SDI device handle as input.
//              pSyncDelay(OUT)     - Pointer to sync delay parameters
//
// Returns:     NVAPI_OK                          - Success
//              NVAPI_API_NOT_INTIALIZED          - NVAPI Not Initialized
//              NVAPI_INVALID_ARGUMENT            - Arguments passed to API are not valid
//              NVAPI_INCOMPATIBLE_STRUCT_VERSION - Stucture version invalid
//              NVAPI_ERROR                       - NVAPI Random errors
//---------------------------------------------------------------------
NVAPI_INTERFACE NvAPI_VIO_GetSyncDelay(NvVioHandle      hVioHandle,
                                       NVVIOSYNCDELAY   *pSyncDelay);

//---------------------------------------------------------------------
// Function:    NvAPI_VIO_IsRunning
//
// Description: Determine if Video I/O is running.
//
//  SUPPORTED OS: Windows XP and higher
//
// Parameters:  NvVioHandle[IN]            - The caller provides the SDI device handle as input.
//
// Returns:     NVAPI_DRIVER_RUNNING       - Video I/O running
//              NVAPI_DRIVER_NOTRUNNING    - Video I/O not running
//---------------------------------------------------------------------
NVAPI_INTERFACE NvAPI_VIO_IsRunning(NvVioHandle   hVioHandle);

//---------------------------------------------------------------------
// Function:    NvAPI_VIO_Start
//
// Description: Start Video I/O.
//
//  SUPPORTED OS: Windows XP and higher
//
// Parameters:  NvVioHandle[IN]    - The caller provides the SDI device handle as input.
//
// Returns:     NVAPI_OK                          - Success
//              NVAPI_API_NOT_INTIALIZED          - NVAPI Not Initialized
//              NVAPI_INVALID_ARGUMENT            - Arguments passed to API are not valid
//              NVAPI_NOT_SUPPORTED               - Video I/O not supported
//              NVAPI_ERROR                       - NVAPI Random errors
//              NVAPI_DEVICE_BUSY                 - Access denied for requested access
//---------------------------------------------------------------------
NVAPI_INTERFACE NvAPI_VIO_Start(NvVioHandle     hVioHandle);

//---------------------------------------------------------------------
// Function:    NvAPI_VIO_Stop
//
// Description: Stop Video I/O.
//
//  SUPPORTED OS: Windows XP and higher
//
// Parameters:  NvVioHandle[IN]    - The caller provides the SDI device handle as input.
//
// Returns:     NVAPI_OK                          - Success
//              NVAPI_API_NOT_INTIALIZED          - NVAPI Not Initialized
//              NVAPI_INVALID_ARGUMENT            - Arguments passed to API are not valid
//              NVAPI_NOT_SUPPORTED               - Video I/O not supported
//              NVAPI_ERROR                       - NVAPI Random errors
//              NVAPI_DEVICE_BUSY                 - Access denied for requested access
//---------------------------------------------------------------------
NVAPI_INTERFACE NvAPI_VIO_Stop(NvVioHandle     hVioHandle);

                                               
//---------------------------------------------------------------------
// Function:    NvAPI_VIO_IsFrameLockModeCompatible
//
// Description: Checkes whether modes are compatible in framelock mode
//
//  SUPPORTED OS: Windows XP and higher
//
// Parameters:  NvVioHandle[IN]         - The caller provides the SDI device handle as input.
//              srcEnumIndex(IN)        - Source Enumeration index
//              destEnumIndex(IN)       - Destination Enumeration index
//              pbCompatible(OUT)       - Pointer to receive compatability
//
// Returns:     NVAPI_OK                          - Success
//              NVAPI_API_NOT_INTIALIZED          - NVAPI Not Initialized
//              NVAPI_INVALID_ARGUMENT            - Arguments passed to API are not valid
//              NVAPI_NOT_SUPPORTED               - Video I/O not supported
//              NVAPI_ERROR                       - NVAPI Random errors
//---------------------------------------------------------------------
NVAPI_INTERFACE NvAPI_VIO_IsFrameLockModeCompatible(NvVioHandle              hVioHandle,
                                                    NvU32                    srcEnumIndex,
                                                    NvU32                    destEnumIndex,
                                                    NvU32*                   pbCompatible);

//---------------------------------------------------------------------
// Function:    NvAPI_VIO_EnumDevices
//
// Description: Enumerate all valid SDI topologies
//
//  SUPPORTED OS: Windows XP and higher
//
// Parameters:  NvVioHandle[OUT]                  - User passes the pointer of NvVioHandle[] array to get handles to all the connected vio devices.
//              vioDeviceCount[OUT]               - User gets total number of VIO devices connected to the system.
//
// Returns:     NVAPI_OK                          - Success
//              NVAPI_API_NOT_INTIALIZED          - NVAPI Not Initialized
//              NVAPI_INVALID_ARGUMENT            - Arguments passed to API are not valid
//              NVAPI_ERROR                       - NVAPI Random errors
//              NVAPI_NVIDIA_DEVICE_NOT_FOUND     - No SDI Device found
//---------------------------------------------------------------------
NVAPI_INTERFACE NvAPI_VIO_EnumDevices(NvVioHandle       hVioHandle[NVAPI_MAX_VIO_DEVICES],
                                      NvU32             *vioDeviceCount);
                                                                                          

//---------------------------------------------------------------------
// Function:    NvAPI_VIO_QueryTopology
//
// Description: Enumerate all valid SDI topologies
//
//  SUPPORTED OS: Windows XP and higher
//
// Parameters:  pNvVIOTopology[OUT]       - User passes the pointer to NVVIOTOPOLOGY to fetch all valid SDI Topologies.
//
// Returns:     NVAPI_OK                          - Success
//              NVAPI_API_NOT_INTIALIZED          - NVAPI Not Initialized
//              NVAPI_INVALID_ARGUMENT            - Arguments passed to API are not valid
//              NVAPI_INCOMPATIBLE_STRUCT_VERSION - Invalid structure version
//              NVAPI_ERROR                       - NVAPI Random errors
//---------------------------------------------------------------------
NVAPI_INTERFACE NvAPI_VIO_QueryTopology(NV_VIO_TOPOLOGY   *pNvVIOTopology);


//---------------------------------------------------------------------
// Function:    NvAPI_VIO_EnumSignalFormats
//
// Description: Enumerate signal formats supported by Video I/O.
//
//  SUPPORTED OS: Windows XP and higher
//
// Parameters:  NvVioHandle[IN]          - The caller provides the SDI device handle as input.
//              enumIndex(IN)            - Enumeration index
//              pSignalFormatDetail(OUT) - Pointer to receive detail or NULL
//
// Returns:     NVAPI_OK                 - Success
//              NVAPI_END_ENUMERATION    - No more signal formats to enumerate
//---------------------------------------------------------------------
NVAPI_INTERFACE NvAPI_VIO_EnumSignalFormats(NvVioHandle              hVioHandle,
                                            NvU32                    enumIndex,
                                            NVVIOSIGNALFORMATDETAIL  *pSignalFormatDetail);
                                            
//---------------------------------------------------------------------
// Function:    NvAPI_VIO_EnumDataFormats
//
// Description: Enumerate data formats supported by Video I/O.
//
//  SUPPORTED OS: Windows XP and higher
//
// Parameters:  NvVioHandle[IN]        - The caller provides the SDI device handle as input.
//              enumIndex(IN)          - Enumeration index
//              pDataFormatDetail(OUT) - Pointer to receive detail or NULL
//
// Returns:     NVAPI_OK               - Success
//              NVAPI_END_ENUMERATION  - No more data formats to enumerate
//              NVAPI_NOT_SUPPORTED    - Unsupported NVVIODATAFORMAT_ enumeration
//---------------------------------------------------------------------
NVAPI_INTERFACE NvAPI_VIO_EnumDataFormats(NvVioHandle            hVioHandle,
                                          NvU32                  enumIndex,
                                          NVVIODATAFORMATDETAIL  *pDataFormatDetail);
                                                                                      

//  SUPPORTED OS: Windows XP and higher
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetTachReading
//
//   DESCRIPTION: This retrieves the tachometer reading for fan speed for the specified physical GPU.
//
//   PARAMETERS:   hPhysicalGpu(IN) - GPU selection.
//                 pValue(OUT)      - Pointer to a variable to get the tachometer reading
//   HOW TO USE:   NvU32 Value = 0;
//                 ret = NvAPI_GPU_GetTachReading(hPhysicalGpu, &Value);  
//                 On call success:
//                 Value would contain the tachometer reading   
//
// RETURN STATUS: 
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_NOT_SUPPORTED - functionality not supported 
//    NVAPI_API_NOT_INTIALIZED - nvapi not initialized
//    NVAPI_INVALID_ARGUMENT - invalid argument passed
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetTachReading(NvPhysicalGpuHandle hPhysicalGPU, NvU32 *pValue);


//
// NV_GET_SCALING_CAPS
//
// Interface structure used in NvAPI_GetScalingCaps call.
//
// This NvAPI_GetScalingCaps returns scaling capability info for the specified display device
//


typedef struct 
{
    NvU32   version;                                      // version
    NvU32   isGPUScalingAvailable                   : 1;  // if the GPU scaling mode available
    NvU32   isGPUFixedAspectRatioScalingAvailable   : 1;  // if the GPU Fixed-Aspect ratio scaling mode available
    NvU32   isMonitorScalingAvailable               : 1;  // if the monitor scaling mode available
    NvU32   isCenterScalingAvailable                : 1;  // if center scaling mode available
} NV_GET_SCALING_CAPS;

#define NV_GET_SCALING_CAPS_VER   MAKE_NVAPI_VERSION(NV_GET_SCALING_CAPS,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetScalingCaps
//
// PARAMETERS:    hNvDisplay(IN) - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                outputId(IN)   - The active display output id associated with the selected display handle hNvDisplay.
//                                 The outputid will have only one bit set. In case of clone or span this will indicate the display
//                                 outputId of the primary display that the GPU is driving.
//                pScalingCaps(OUT) - Pointer to struct NV_GET_SCALING_CAPS. Returns various scaling caps for a given displayId. 
//
//  SUPPORTED OS: Windows Vista and higher
//
// DESCRIPTION:   Returns all the scaling Caps of given display. Each member is used to disable the corresponding scaling feature. 
//                If the value of the member is true, caller does not care. 
//                If it is false, caller has to set the corresponding scaling option disabled. 
//
//                Note: NvAPI_GetScalingCaps() at present only supports "Monitor Scaling caps".
//                Other scaling caps are not implemented by DD.
//                
// RETURN STATUS: NVAPI_OK: call successful.
//                NVAPI_API_NOT_INTIALIZED: : NVAPI not initialized.
//                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found.
//                NVAPI_INCOMPATIBLE_STRUCT_VERSION - structure version is not supported, initialize to NV_GET_SCALING_CAPS_VER.
//                NVAPI_EXPECTED_DISPLAY_HANDLE: hNvDisplay is not a valid display handle.
//                NVAPI_INVALID_ARGUMENT: If outputId is zero.
//                NVAPI_INVALID_HANDLE: Invalid Display handle.
//                NVAPI_ERROR: Miscellenous errors.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetScalingCaps(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_GET_SCALING_CAPS *pScalingCaps);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetThermalTable
//
//  SUPPORTED OS: Mac OS X, Windows XP and higher
//
// DESCRIPTION:     Returns the list of thermal table entries for this GPU.
//                      ttVersion - version of thermal table 
//                      numEntries - number of thermal table entries returned
//
//
// RETURN STATUS: 
//    NVAPI_OK - completed request, *pTable contains the thermal table entries
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_NOT_SUPPORTED - not available on the target hardware
//    NVAPI_INVALID_ARGUMENT - pThermalTable is NULL
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//    NVAPI_INCOMPATIBLE_STRUCT_VERSION - NV_THERMAL_TABLE structure version mismatch
//
///////////////////////////////////////////////////////////////////////////////
#define NVAPI_GPU_THERMAL_TABLE_MAX_ENTRIES (256)
typedef struct
{
    NvU32   version;            // Structure version
    NvU32   flags;              // call with 0, reserved for future extensions 
    NvU32   ttVersion;
    NvU32   numEntries;
    NvU32   entryList[NVAPI_GPU_THERMAL_TABLE_MAX_ENTRIES];
} NV_GPU_THERMAL_TABLE;
#define NV_GPU_THERMAL_TABLE_VER MAKE_NVAPI_VERSION(NV_GPU_THERMAL_TABLE,1)

NVAPI_INTERFACE NvAPI_GPU_GetThermalTable(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_THERMAL_TABLE *pThermalTable);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetHybridControllerInfo
//
//  SUPPORTED OS: Windows XP and higher
//
// DESCRIPTION:     Returns the hybrid controller information
//                      present - true if the hybrid controller is present
//                      fwVersion - firmware version of the hybrid controller. 
//                                  Firmware version is zero if the hybrid controller is not present.
//
//
// RETURN STATUS: 
//    NVAPI_OK - completed request, *pTable contains the thermal table entries
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_INVALID_ARGUMENT - pHybridCOntrollerInfo is NULL
//    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////
typedef struct
{
    NvU32   version;            // Structure version
    NvU32   present;
    NvU32   fwVersion;
} NV_GPU_HYBRID_CONTROLLER_INFO;
#define NV_GPU_HYBRID_CONTROLLER_INFO_VER MAKE_NVAPI_VERSION(NV_GPU_HYBRID_CONTROLLER_INFO,1)

NVAPI_INTERFACE NvAPI_GPU_GetHybridControllerInfo(NvPhysicalGpuHandle hPhysicalGpu, 
                                                  NV_GPU_HYBRID_CONTROLLER_INFO *pHybridControllerInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_SYS_SetPostOutput
//
//  SUPPORTED OS: Windows XP and higher
//
// DESCRIPTION:     Sends byte value to motherboard POST output.
//                  This call works only on systems having GPUs with
//                  engineering VBIOS! Systems with production VBIOS
//                  will return NVAPI_NOT_SUPPORTED.
//                  Supported address range is 0x80-0x84.
//
// HOW TO USE:      ret = NvAPI_SYS_SetPostOutput(address, format, data);
//                      address - POST port I/O address
//                      format - format of data field
//                      data - value to display
//                              0-255 if _FORMAT_HEX
//                              0-99  if _FORMAT_BCD 
//                      (HEX->BCD conversion is performed by NvAPI)
//
//
// RETURN STATUS: 
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_INVALID_ADDRESS - address out of allowed range
//    NVAPI_INVALID_ARGUMENT - incorrect data value (see limits above)
//    NVAPI_NOT_SUPPORTED - call is not supported (on production VBIOS-es)
//    NVAPI_API_NOT_INTIALIZED - NvAPI not initialized
//
///////////////////////////////////////////////////////////////////////////////
typedef enum _NV_SYS_POST_PORT_FORMAT
{
    NVAPI_POST_PORT_FORMAT_HEX  = 0,
    NVAPI_POST_PORT_FORMAT_BCD,
} NVAPI_POST_PORT_FORMAT;

NVAPI_INTERFACE NvAPI_SYS_SetPostOutput(NvU32 address, NVAPI_POST_PORT_FORMAT format, NvU32 data);


typedef enum
{
    NV_FAN_SENSE_NOTSUPPORTED = 0, //fan sense not supported
    NV_FAN_SENSE_SUPPORTED = 1,    //fan sense supported
} NV_FAN_SENSE;

typedef struct
{
    NvU32   version;
    NvU32   coolerCount;
    NV_FAN_SENSE   supportFlag[NVAPI_MAX_COOLERS_PER_GPU];
} NV_GPU_FAN_SPIN_SENSE;
#define NV_GPU_FAN_SPIN_SENSE_VER MAKE_NVAPI_VERSION(NV_GPU_FAN_SPIN_SENSE, 1)

//  SUPPORTED OS: Mac OS X, Windows XP and higher
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME : NvAPI_GPU_QueryFanSpinSenseSupport
// 
// PARAMETERS    : hPhysicalGpu(IN)       - GPU selection 
//                 coolerIndexRequest(IN) - Index of the cooler (0 to NVAPI_MAX_COOLERS_PER_GPU-1) to retrieve info if 
//                                          any particular is of interest otherwise to retrieve info for all the cooler,
//                                          set coolerIndex to NVAPI_COOLER_TARGET_ALL.                                           
//                 pSpinSense(OUT)        - Pointer to the versioned structure NV_GPU_FAN_SPIN_SENSE in which the 
//                                          total count of the coolers associated with the GPU and their individual
//                                          fan spin sense support flags are retrieved.
//
// DESCRIPTION   : This function will return the fan spin sense info for a particular or all the coolers associated with a GPU.
//
// HOW TO USE    : NV_GPU_FAN_SPIN_SENSE spinSense = {0};
//                 coolerIndexRequest = NVAPI_COOLER_TARGET_ALL;
//                 spinSense.version = NV_GPU_FAN_SPIN_SENSE_VER;
//                 ret = NvAPI_GPU_QueryFanSpinSenseSupport(hPhysicalGpu, &spinSense);
//                 on call success:
//                 spinSense.count indicates the number of coolers associated with the GPU.
//                 spinSense.supportFlag array would contain the flag(1 = supported, 0 = not) for each of the 
//                 coolers associated with the GPU.                  
//                 
// RETURN STATUS:
//                 NVAPI_OK - completed request
//                 NVAPI_ERROR - miscellaneous error occurred
//                 NVAPI_NOT_SUPPORTED - this feature is not supported on this GPU
//                 NVAPI_INVALID_HANDLE - physical GPU not found
//                 NVAPI_INVALID_ARGUMENT - invalid arugument passed
//                 NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//                 NVAPI_API_NOT_INITIALIZED - nvapi not initialized
//                 NVAPI_INCOMPATIBLE_STRUCT_VERSION - structure passed not initialized with proper version data
// 
///////////////////////////////////////////////////////////////////////////////    
NVAPI_INTERFACE NvAPI_GPU_QueryFanSpinSenseSupport(NvPhysicalGpuHandle hPhysicalGpu, NvU32 coolerIndexRequest, NV_GPU_FAN_SPIN_SENSE *pSpinSense);


// 3D profile for one key cinema feature

#define NV_3D_MAX_RANGE         25

typedef enum
{
    NV_3D_PROPERTY_AS         = 1,  // Anti-Aliasing selector
    NV_3D_PROPERTY_AA         = 2,  // Anti-Aliasing setting
    NV_3D_PROPERTY_AF         = 3,  // Anisotropic filtering
    NV_3D_PROPERTY_MAX_FRAMES = 4,  // Maximum pre-rendered frames
    NV_3D_PROPERTY_TEX_FILTER = 5,  // Texture filtering
} NV_3D_PROPERTY;

typedef struct
{
    NvU32           version;                // [in] version
    NV_3D_PROPERTY  settingName;            // [in] 3d setting
    NvU32           flags;                  // [out] indicates whether the settings are read only
    NvU32           defaultValue;           // [out] default base value at driver install
    NvU32           currentValue;           // [in/out] current value or new value to update
} NV_3D_SETTING;

typedef struct
{
    NvU32           version;                // [in] version
    NV_3D_PROPERTY  settingName;            // [in] 3d setting
    NvU32           value[NV_3D_MAX_RANGE]; // [out] range of values as unique array of numbers
    NvU32           validRangeCount;        // [out] number of valid items in the property
} NV_3D_SETTING_RANGE;

#define NV_3D_PROFILE_VERSION           MAKE_NVAPI_VERSION(NV_3D_SETTING,1)
#define NV_3D_PROFILE_RANGE_VERSION     MAKE_NVAPI_VERSION(NV_3D_SETTING_RANGE,1)

/////////////////////////////////////////////////////////////////////////////// 
// 
// FUNCTION NAME:  NvAPI_3D_GetProperty 
// 
// PARAMETERS:     profileName - Which profile to access
//                 p3dSettings - Setting of 3D profile property 
// 
// DESCRIPTION:    This API gets the specific 3D profile property
//
//  SUPPORTED OS: Windows XP and higher
// HOW TO USE:     Set profileName to "Base Profile"
//                 Set 3D property name to settingName of NV_3D_SETTING
//                 On call success:
//                 It returns the specific profile property setting
// 
// RETURN STATUS:  NVAPI_OK - completed request 
//                 NVAPI_ERROR - miscellaneous error occurred
//                 NVAPI_INVALID_ARGUMENT - invalid argument passed
// 
/////////////////////////////////////////////////////////////////////////////// 
NVAPI_INTERFACE NvAPI_3D_GetProperty(NvAPI_ShortString szProfileName, NV_3D_SETTING* p3dSetting);

/////////////////////////////////////////////////////////////////////////////// 
// 
// FUNCTION NAME:  NvAPI_3D_SetProperty 
// 
// PARAMETERS:     profileName - Which profile to access
//                 p3dSettings - Setting of 3D profile property 
// 
// DESCRIPTION:    This API sets the specific 3D profile property
//
//  SUPPORTED OS: Windows XP and higher
// HOW TO USE:     Set profileName to "Base Profile"
//                 Set 3D property name to settingName of NV_3D_SETTING
//                 On call success:
//                 It return the specific profile property setting                  
// 
// RETURN STATUS:  NVAPI_OK - completed request 
//                 NVAPI_ERROR - miscellaneous error occurred
//                 NVAPI_INVALID_ARGUMENT - invalid argument passed
// 
/////////////////////////////////////////////////////////////////////////////// 
NVAPI_INTERFACE NvAPI_3D_SetProperty(NvAPI_ShortString szProfileName, NV_3D_SETTING* p3dSetting);

/////////////////////////////////////////////////////////////////////////////// 
// 
// FUNCTION NAME:  NvAPI_3D_GetPropertyRange 
// 
// PARAMETERS:     profileName - Which profile to access
//                 p3dsettingRange - Setting range of 3D profile property 
// 
// DESCRIPTION:    This API gets property setting range of the specific 3D profile 
//
//  SUPPORTED OS: Windows XP and higher
// HOW TO USE:     Set profileName to "Base Profile"
//                 Set 3D property name to settingName of NV_3D_SETTING_RANGE
//                 On call success:
//                 It returns the specific profile property setting                  
// 
// RETURN STATUS:  NVAPI_OK - completed request 
//                 NVAPI_ERROR - miscellaneous error occurred
//                 NVAPI_INVALID_ARGUMENT - invalid argument passed
// 
/////////////////////////////////////////////////////////////////////////////// 
NVAPI_INTERFACE NvAPI_3D_GetPropertyRange(NvAPI_ShortString szProfileName, NV_3D_SETTING_RANGE* p3dsettingRange);


typedef struct
{
    NvU32   version;

    NvU32   width;
    NvU32   height;
    NvU32   depth;
    NvU32   refresh;
    NvU32   format;
    NvU32   interlaced;
} NVAPI_DISPLAY_MODE;

//  SUPPORTED OS: Windows XP and higher
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME : NvAPI_Disp_EnumerateDisplayModes
// 
// PARAMETERS    : hNvDisplay (IN)          - NVIDIA display handle
//                 modeIndex  (IN)          - index for desired mode
//                 mode       (OUT)         - display mode at modeIndex of driver table
//
// DESCRIPTION   : Enumerate the entire mode table in the driver.
//
// HOW TO USE    : Call repeatedly with increasing modeIndex until NVAPI_END_ENUMERATION returns
//                 
// RETURN STATUS:
//                 NVAPI_OK                      - completed request
//                 NVAPI_ERROR                   - miscellaneous error occurred
//                 NVAPI_API_NOT_INTIALIZED      - must initialize first
//                 NVAPI_EXPECTED_DISPLAY_HANDLE - invalid hNvDisplay
//                 NVAPI_END_ENUMERATION         - modeIndex is greater than the number of modes in the driver table
// 
///////////////////////////////////////////////////////////////////////////////    
NVAPI_INTERFACE NvAPI_Disp_EnumerateDisplayModes(NvDisplayHandle hNvDisplay, NvU32 modeIndex, NVAPI_DISPLAY_MODE *mode);

///////////////////////////////////////////////////////////////////////////////
//             
// FUNCTION NAME: NvAPI_GPU_CreateStringHashFromPhysicalGpu
//
// PARAMETERS:    hPhysicalGpu (IN)   - GPU selection.
//                nSize (IN)          - size of pre-allocated string
//                szHash (OUT)        - pointer to pre-allocated string array.
//                                      If a value is written to the array it
//                                      will be NULL-terminated.
//                  
//  SUPPORTED OS: Windows XP
// DESCRIPTION:   This function creates a string hash that represents a
//                given physical GPU for the purpose of controlling which
//                GPU is used as the OpenGL multimon-buffer master GPU.
//
// HOW TO USE:    The string is stored in the app profile.  Later, when
//                an OGL app starts up, NvAPI_GPU_ConvertStringHashToPhysicalGpu
//                converts the string back into a GPU handle.
//                     
// RETURN STATUS: 
//                NVAPI_OK - completed request
//                NVAPI_ERROR - miscellaneous error occurred
//                NVAPI_INVALID_ARGUMENT - invalid input parameter
//                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - hPhysicalGpu is not a physical GPU handle.
//                NVAPI_STRING_TOO_SMALL - szHash is too small because the hash'd string exceeds (nSize+1) characters
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_CreateStringHashFromPhysicalGpu(NvPhysicalGpuHandle hPhysicalGpu, NvU32 nSize, NvAPI_String szHash);

///////////////////////////////////////////////////////////////////////////////

//

// FUNCTION NAME: NvAPI_GPU_ConvertStringHashToPhysicalGpu
//

// PARAMETERS:    szHash (OUT)        - pointer to null-terminated string hash
//                hPhysicalGpu (OUT)  - GPU selection
//                  
//  SUPPORTED OS: Windows XP
// DESCRIPTION:   This function converts to a physical GPU handle from a
//                string hash that was created by
//                NvAPI_GPU_CreateStringHashFromPhysicalGpu.  If the exact GPU
//                is not present then the "best match" GPU will be selected.
//

// RETURN STATUS: 

//                NVAPI_OK - completed request
//                NVAPI_ERROR - miscellaneous error occurred
//                NVAPI_INVALID_ARGUMENT - invalid input parameter
//                NVAPI_MATCHING_DEVICE_NOT_FOUND - none of the present devices are a close-enough match to szHash
//

///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_GPU_ConvertStringHashToPhysicalGpu(NvAPI_String szHash, NvPhysicalGpuHandle hPhysicalGpu);


//  SUPPORTED OS: Windows Vista and higher
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SYS_FixInvalidDriverState
//
//   DESCRIPTION: This function validates the current driver state, and will
//                do a driver reload if necessary
//
//   PARAMETERS:   None
//
// RETURN STATUS: 
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_NOT_SUPPORTED - functionality not supported 
//    NVAPI_API_NOT_INTIALIZED - nvapi not initialized
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_FixInvalidDriverState();

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Audio_EnumDeviceHandle
//
// PARAMETERS:    thisEnum (IN)              - index of audio device for which device handle is requested
//                hDeviceObject (OUT)        - pointer to NvAudioHandle
//
//  SUPPORTED OS: Windows XP and higher
// DESCRIPTION:   Enumerates Audio devices present in the system
//                
//
// RETURN STATUS: 
//                NVAPI_OK - completed request
//                NVAPI_ERROR - miscellaneous error occurred
//                NVAPI_INVALID_ARGUMENT - invalid input parameter
//                NVAPI_MATCHING_DEVICE_NOT_FOUND - No Nvidia HDA device installed
//                NVAPI_END_ENUMERATION - thisEnum is greater than the number of nvidia audio devices in system
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_Audio_EnumDeviceHandle(NvU32 thisEnum, NvAudioHandle* hDeviceObject);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Audio_GetDeviceParameters
//
// PARAMETERS:    NvAudioHandle (IN)............... - NvAudioHandle value
//                pNV_AUDIO_PARAMETERS (OUT)        - pointer to NV_AUDIO_PARAMETERS structure
//                                  
//  SUPPORTED OS: Windows XP and higher
// DESCRIPTION:   Provides various Audio Device Property values
//
// RETURN STATUS: 
//                NVAPI_OK - completed request
//                NVAPI_ERROR - miscellaneous error occurred
//                NVAPI_INVALID_ARGUMENT - invalid input parameter
//                NVAPI_INVALID_HANDLE - invalid handle to device
//                NVAPI_INCOMPATIBLE_STRUCT_VERSION - Incompatible struct version
//
///////////////////////////////////////////////////////////////////////////////

typedef enum _NV_AUDIO_CHANNEL
{
    NV_AUDIO_CHAN_0 =          (1 << 0),
    NV_AUDIO_CHAN_1 =          (1 << 1),
    NV_AUDIO_CHAN_2 =          (1 << 2),
    NV_AUDIO_CHAN_3 =          (1 << 3),
    NV_AUDIO_CHAN_4 =          (1 << 4),
    NV_AUDIO_CHAN_5 =          (1 << 5),
    NV_AUDIO_CHAN_6 =          (1 << 6),
    NV_AUDIO_CHAN_7 =          (1 << 7),
    NV_AUDIO_CHAN_8 =          (1 << 8),
    NV_AUDIO_CHAN_9 =          (1 << 9),
    NV_AUDIO_CHAN_10 =         (1 << 10)
}NV_AUDIO_CHANNEL;

typedef enum _NV_AUDIO_SIZE
{
    NV_AUDIO_SIZE_16BIT =      (1 << 0),
    NV_AUDIO_SIZE_20BIT =      (1 << 1),
    NV_AUDIO_SIZE_24BIT =      (1 << 2),
}NV_AUDIO_SIZE;

typedef enum _NV_AUDIO_RATE
{
    NV_AUDIO_RATE_32000 =      (1 << 8),
    NV_AUDIO_RATE_44100 =      (1 << 9),
    NV_AUDIO_RATE_48000 =      (1 << 10),
    NV_AUDIO_RATE_88200 =      (1 << 11),
    NV_AUDIO_RATE_96000 =      (1 << 12),
    NV_AUDIO_RATE_176400 =     (1 << 13),
    NV_AUDIO_RATE_192000 =     (1 << 14),
}NV_AUDIO_RATE;

typedef enum _NV_AUDIO_FORMAT
{
    NV_AUDIO_FORMAT_LPCM =     (1 << 1),  // Linear PCM (e.g., IEC 60958)
    NV_AUDIO_FORMAT_AC3 =      (1 << 2),  // AC-3
    NV_AUDIO_FORMAT_MPEG1 =    (1 << 3),  // MPEG1 (Layers 1 & 2)
    NV_AUDIO_FORMAT_MP3 =      (1 << 4),  // MP3 (MPEG1 Layer 3)
    NV_AUDIO_FORMAT_MPEG2 =    (1 << 5),  // MPEG2 (multichannel)
    NV_AUDIO_FORMAT_AAC =      (1 << 6),  // AAC
    NV_AUDIO_FORMAT_DTS =      (1 << 7),  // DTS
    NV_AUDIO_FORMAT_ATRAC =    (1 << 8),  // ATRAC
    NV_AUDIO_FORMAT_SACD =     (1 << 9),  // One Bit Audio
    NV_AUDIO_FORMAT_DDPLUS =   (1 << 10), // Dolby Digital +
    NV_AUDIO_FORMAT_DTSHD =    (1 << 11), // DTS-HD
    NV_AUDIO_FORMAT_MAT =      (1 << 12), // MAT (MLP)
    NV_AUDIO_FORMAT_DST =      (1 << 13), // DST
    NV_AUDIO_FORMAT_WMAPRO =   (1 << 14), // WMA Pro
    NV_AUDIO_FORMAT_RESERVED = (1 << 15), // Reserved for audio format 15
}NV_AUDIO_FORMAT;

typedef struct _NV_AUDIO_PARAMETERS
{
    NvU32 version;                // Strucure version
    
    NvU32 venID;                  // Vendor ID
    NvU32 devID;                  // Developer ID
    NvU32 revID;                  // Revision ID
    
    NvU32 paramVersion;           // Parameter versioning used inside audio Driver
    
    //Contents of audio HeadScratch registers
    NvU32 regH0S0;                // NV_PDISP_AUDIO_HEAD0_SCRATCH0
    NvU32 regH0S1;                // NV_PDISP_AUDIO_HEAD0_SCRATCH1
    NvU32 regH1S0;                // NV_PDISP_AUDIO_HEAD1_SCRATCH0
    NvU32 regH1S1;                // NV_PDISP_AUDIO_HEAD1_SCRATCH1
    NvU32 regLPCM;                // NV_PDISP_AUDIO_EXAUD_LPCM
    
    // Current audio stream properties
    NvU32 currentState:1;         // State of current audio stream
    NvU32 currentChan;            // Number of channels in current audio stream
    NvU32 currentRate;            // Bitrate of current audio stream
    NvU32 currentSampleSize;      // samplesize for current audio stream
    
    //Device maximum settings
    NvU32 maxState:1;             // State of Device maximum settings (Valid/Invalid)
    NvU32 maxRate;                // Bitrates allowed by NVHDA codec present
    NvU32 maxSampleSize;          // SampleSizes allowed by NVHDA codec present
    NvU32 maxFormats;             // SampleSIzes allowed by NVHDA codec present
    NvU32 maxChan;                // SampleSizes allowed by NVHDA codec present
    
    //Driver sink settings 
    NvU32 sinkState:1;            // State of Driver Sink settings (Valid/Invalid)
    NvU32 sinkRate;               // Bitrates allowed by NVHDA codec present
    NvU32 sinkSampleSize;         // SampleSizes allowed by sink device present
    NvU32 sinkFormats;            // SampleSIzes allowed by sink devicec present
    NvU32 sinkChan;               // SampleSizes allowed by sink device present
    
    //Driver override settings
    NvU32 overrideState:1;        // State of Driver Overrides (Valid/Invalid)
    NvU32 overrideRate;           // Bitrates overrided
    NvU32 overrideSampleSize;     // SampleSizes overrided
    NvU32 overrideFormats;        // SampleSIzes overrided
    NvU32 overrideChan;           // SampleSizes overrided

} NV_AUDIO_PARAMETERS;

#define NV_AUDIO_PARAMETERS_VER  MAKE_NVAPI_VERSION(NV_AUDIO_PARAMETERS,1)

NVAPI_INTERFACE NvAPI_Audio_GetDeviceParameters(NvAudioHandle NvAudioHandle, NV_AUDIO_PARAMETERS *pNV_AUDIO_PARAMETERS);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_SYS_SpbControl
//
// PARAMETERS:      command (IN)        - SPB control command to be executed
//                  locale (IN)         - locale ID
//                  param (IN, OUT)     - command specific paramater
//                                      -- power is specified in milliWatts
//                                      -- temperature is in milliCelsius
//
//  SUPPORTED OS: Windows Vista and higher
//
// DESCRIPTION:     This API call is used to control SPB functionality.
//                  It is used to get/set single SPB parameter as well as to
//                  control SPB execution mode.
//                  NVAPI_SPB_DATA_* commands require correct locale parameter.
//                  NVAPI_SPB_CMD_* and NVAPI_SPB_SYS_* commands require
//                  locale to be set to NVAPI_SPB_LOCALE_SYSTEM.
//                  NVAPI_SYS_CMD_* uses only enums defined
//                  in NVAPI_SPB_COMMAND_PARAM.
//                  Other commands that require additional parameter must
//                  respect required units as specified in parameter
//                  description.
//
//                  Do not use this call unles you work on SPB functionlaity.
//                  It is still under development and minor changes can occur.
//
// RETURN STATUS: 
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_INVALID_POINTER - NULL argument passed
//    NVAPI_INVALID_ARGUMENT - incorrect param value
//    NVAPI_NO_IMPLEMENTATION - command not implemented
//    NVAPI_NOT_SUPPORTED - call is not supported
//    NVAPI_API_NOT_INTIALIZED - NvAPI not initialized
//
///////////////////////////////////////////////////////////////////////////////
typedef enum _NV_SPB_COMMAND
{
    NVAPI_SPB_CMD_GET_INIT                      = 0x0000,
    NVAPI_SPB_CMD_SET_EXEC,
    NVAPI_SPB_CMD_GET_EXEC,
    NVAPI_SPB_CMD_SET_ACTIONS,
    NVAPI_SPB_CMD_GET_ACTIONS,
    NVAPI_SPB_CMD_SET_LOGIC,
    NVAPI_SPB_CMD_GET_LOGIC,
    NVAPI_SPB_CMD_SET_PREFERENCE,
    NVAPI_SPB_CMD_GET_PREFERENCE,
    NVAPI_SPB_CMD_SET_GPU2CPU_LIMIT,
    NVAPI_SPB_CMD_GET_GPU2CPU_LIMIT,

    NVAPI_SPB_SYS_SET_MAX_POWER                 = 0x0100,
    NVAPI_SPB_SYS_GET_MAX_POWER,
    NVAPI_SPB_SYS_SET_COOLING_BUDGET,
    NVAPI_SPB_SYS_GET_COOLING_BUDGET,
    NVAPI_SPB_SYS_SET_INTEGRAL_PERIOD,
    NVAPI_SPB_SYS_GET_INTEGRAL_PERIOD,
    NVAPI_SPB_SYS_SET_RULESET,
    NVAPI_SPB_SYS_GET_RULESET,
    NVAPI_SPB_SYS_GET_RULE_COUNT,
    NVAPI_SPB_SYS_SET_APP_BOOST,
    NVAPI_SPB_SYS_GET_APP_BOOST,
    NVAPI_SPB_SYS_SET_PWR_SUPPLY_MODE,
    NVAPI_SPB_SYS_GET_PWR_SUPPLY_MODE,

    NVAPI_SPB_DATA_GET_POWER                    = 0x0200,
    NVAPI_SPB_DATA_GET_POWER_DELTA,
    NVAPI_SPB_DATA_GET_POWER_FUTURE,
    NVAPI_SPB_DATA_GET_POWER_LTMAVG,
    NVAPI_SPB_DATA_GET_POWER_INTEGRAL,
    NVAPI_SPB_DATA_GET_POWER_BURDEN,

    NVAPI_SPB_DATA_GET_TEMP                     = 0x0220,
    NVAPI_SPB_DATA_GET_TEMP_DELTA,
    NVAPI_SPB_DATA_GET_TEMP_FUTURE,

    NVAPI_SPB_DATA_GET_PSTATE                   = 0x0240,
    NVAPI_SPB_DATA_GET_PSTATE_CAP,
    NVAPI_SPB_DATA_GET_PSTATE_MIN,
    NVAPI_SPB_DATA_GET_PSTATE_MAX,
    NVAPI_SPB_DATA_GET_PSTATE_ACTION,
    NVAPI_SPB_DATA_GET_PSTATE_SLFM_PRESENT

} NVAPI_SPB_COMMAND;

typedef enum _NV_SPB_LOCALE
{
    NVAPI_SPB_LOCALE_SYSTEM                     = 0x0000,
    NVAPI_SPB_LOCALE_CPU_0                      = 0x0100,
    NVAPI_SPB_LOCALE_CPU_1,
    NVAPI_SPB_LOCALE_GPU_0                      = 0x0200,
    NVAPI_SPB_LOCALE_GPU_1

} NVAPI_SPB_LOCALE;

typedef enum _NV_SPB_COMMAND_PARAM
{
    NVAPI_SPB_CMD_DEF_INVALID               = 0x80000000,
    NVAPI_SPB_CMD_DEF_INIT_NO                        = 0,
    NVAPI_SPB_CMD_DEF_INIT_YES,
    NVAPI_SPB_CMD_DEF_EXEC_STOP                      = 0,
    NVAPI_SPB_CMD_DEF_EXEC_START,
    NVAPI_SPB_CMD_DEF_ACTIONS_OFF                    = 0,
    NVAPI_SPB_CMD_DEF_ACTIONS_ON,
    NVAPI_SPB_CMD_DEF_LOGIC_OFF                      = 0,
    NVAPI_SPB_CMD_DEF_LOGIC_FUZZY,
    NVAPI_SPB_CMD_DEF_LOGIC_DETERMINISTIC,
    NVAPI_SPB_CMD_DEF_PREFERENCE_CPU                 = 0,
    NVAPI_SPB_CMD_DEF_PREFERENCE_GPU,
    NVAPI_SPB_CMD_DEF_PREFERENCE_BOTH,
    NVAPI_SPB_CMD_DEF_PWR_SUPPLY_REAL                = 0,
    NVAPI_SPB_CMD_DEF_PWR_SUPPLY_FAKE_AC,
    NVAPI_SPB_CMD_DEF_PWR_SUPPLY_FAKE_BATT,
    NVAPI_SPB_DATA_DEF_ACTION_DEC_TO_P0              = 0,
    NVAPI_SPB_DATA_DEF_ACTION_DEC_BY_1,
    NVAPI_SPB_DATA_DEF_ACTION_DO_NOTHING,
    NVAPI_SPB_DATA_DEF_ACTION_SET_CURRENT,
    NVAPI_SPB_DATA_DEF_ACTION_INC_BY_1,
    NVAPI_SPB_DATA_DEF_ACTION_INC_BY_2,
    NVAPI_SPB_DATA_DEF_ACTION_INC_TO_LFM,
    NVAPI_SPB_DATA_DEF_ACTION_INC_TO_SLFM,
    NVAPI_SPB_DATA_DEF_SLFM_PRESENT_NO               = 0,
    NVAPI_SPB_DATA_DEF_SLFM_PRESENT_YES

} NVAPI_SPB_COMMAND_PARAM;

NVAPI_INTERFACE NvAPI_SYS_SpbControl(NVAPI_SPB_COMMAND command, NVAPI_SPB_LOCALE locale, NvU32 *pParam);


#define NVAPI_SPB_BATCH_COMMANDS_MAX 16

typedef struct
{
    NvU32   version;            // [in] structure version
    NvU32   cmdCount;           // [in,out] number of commands to execute
    NvU32   succeeded;          // [out] number of succesfully executed commands

    struct
    {
        NVAPI_SPB_COMMAND   command;    // [in] SPB command
        NVAPI_SPB_LOCALE    locale;     // [in] SPB locale
        NvU32               param;      // [in/out] SPB param
    } commands[NVAPI_SPB_BATCH_COMMANDS_MAX];

} NV_SPB_BATCH_COMMAND_STRUCT;

#define NV_SPB_BATCH_COMMAND_STRUCT_VER  MAKE_NVAPI_VERSION(NV_SPB_BATCH_COMMAND_STRUCT,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_SYS_SpbBatchControl
//
// PARAMETERS:      pCmdStruct (IN, OUT) - Array of SPB commands to be executed
//
//  SUPPORTED OS: Windows Vista and higher
//
// DESCRIPTION:     This API call allows execution of multiple SpbControl
//                  commands. 
//                  On output each commands[i].param holds output value
//                  for appropriate command.  If command has failed
//                  param holds value NVAPI_SPB_CMD_DEF_INVALID.
//                  For more details on command/device/param refer to        
//                  NvAPI_SYS_SpbControl().
//
// RETURN STATUS: 
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_INVALID_POINTER - NULL argument passed
//    NVAPI_INVALID_ARGUMENT - incorrect cmdCount value
//    NVAPI_NO_IMPLEMENTATION - command not implemented
//    NVAPI_NOT_SUPPORTED - call is not supported
//    NVAPI_API_NOT_INTIALIZED - NvAPI not initialized
//    NVAPI_INVALID_CALL - invalid command/device/param & cmdCount holds # of failing entry
//    NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the INFO struct is not supported
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_SYS_SpbBatchControl(NV_SPB_BATCH_COMMAND_STRUCT *pCmdStruct);


typedef struct _NV_VIDEO_LOCATION_MAP
{
    NvU32 vidPnSrcId;
    NvU32 head;
    NvU32 displayId;
    NvU8  gdiDisplayName[32];
} NV_VIDEO_LOCATION_MAP;

typedef struct _NV_VIDEO_GET_VID_LOCATION_MAP
{
    NvU32   version;                        // (IN)version info
    NV_VIDEO_LOCATION_MAP vidLocMap;
} NV_VIDEO_GET_VID_LOCATION_MAP;

#define NV_VIDEO_GET_VID_LOCATION_MAP_VER  MAKE_NVAPI_VERSION(NV_VIDEO_GET_VID_LOCATION_MAP,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetVidLocMap
//
// PARAMETERS:    hNvDisplay(IN) - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//                pGetVidLocMap(OUT) - The VID_LOC_MAP associated with the selected display handle hNvDisplay.
//
//   DESCRIPTION: Returns the VideoLocationMap associated with a physical GPU handle.
//  SUPPORTED OS: Windows Vista and higher
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: nvGPUHandle is not valid; hNvDisp is NULL
//                NVAPI_OK: one handle was returned
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetVidLocMap(NvDisplayHandle hNvDisplay, NV_VIDEO_GET_VID_LOCATION_MAP *pGetVidLocMap);

#define NV_MAX_PROTECTED_VIDEO_SESSIONS 8

typedef enum _NV_PROTECTED_VIDEO_SESSION_TYPE
{
    NV_VIDEO_SESSION_COPP = 0,
    NV_VIDEO_SESSION_OPM  = 1
}NV_PROTECTED_VIDEO_SESSION_TYPE;

typedef struct _NVAPI_PROTECTED_VIDEO_SESSION_INFO
{
    NvU32                              version;                                       // (IN) version info
    NvU32                              dwNumProtSessions;                             // number of protected sessions
    NV_PROTECTED_VIDEO_SESSION_TYPE    sessionType[NV_MAX_PROTECTED_VIDEO_SESSIONS];  // SessionType COPP/OPM associated with each session
} NVAPI_PROTECTED_VIDEO_SESSION_INFO;

#define NVAPI_PROTECTED_VIDEO_SESSION_INFO_VER  MAKE_NVAPI_VERSION(NVAPI_PROTECTED_VIDEO_SESSION_INFO,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Video_GetProtectedVideoSessionInfo
//
// DESCRIPTION: Returns information on the number of protected Video sessions and their semantics COPP/OPM so far
//
//  SUPPORTED OS: Windows Vista and higher
//
// RETURN STATUS:
//                NVAPI_OK    - completed request
//                NVAPI_ERROR - miscellaneous error occurred
NVAPI_INTERFACE NvAPI_Video_GetProtectedVideoSessionInfo(NVAPI_PROTECTED_VIDEO_SESSION_INFO *pProtVideoSessionInfo); 


///////////////////////////////////////////////////////////////////////////////
//
// New view APIs 
//
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SYS_GetDisplayIdFromGpuAndOutputId
//
// DESCRIPTION:     Converts a Physical GPU handle and an output Id to a
//                  displayId
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:      hPhysicalGpu(IN)  - Handle to the physical GPU
//                  outputId(IN)      - Connected display output Id on the 
//                                      target GPU, must only have one bit 
//                                      set.
//                  displayId(OUT)    - Pointer to an NvU32 which will contain
//                                      the display ID
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_API_NOT_INTIALIZED - NVAPI not initialized
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_GetDisplayIdFromGpuAndOutputId(NvPhysicalGpuHandle hPhysicalGpu, NvU32 outputId, NvU32* displayId);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SYS_GetGpuAndOutputIdFromDisplayId
//
// DESCRIPTION:     Converts a Physical GPU handle and an output Id to a
//                  displayId
//
//  SUPPORTED OS: Windows XP and higher
//
// PARAMETERS:      displayId(IN)     - Display ID of display to retrieve 
//                                      GPU and outputId for
//                  hPhysicalGpu(OUT) - Handle to the physical GPU
//                  outputId(OUT)     - Connected display output Id on the 
//                                      target GPU, will only have one bit 
//                                      set.
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_API_NOT_INTIALIZED - NVAPI not initialized
//                  NVAPI_ID_OUT_OF_RANGE - The DisplayId corresponds to a 
//                                          display which is not within the
//                                          normal outputId range.
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_GetGpuAndOutputIdFromDisplayId(NvU32 displayId, NvPhysicalGpuHandle *hPhysicalGpu, NvU32 *outputId);

///////////////////////////////////////////////////////////////////////////////
// SetDisplayConfig/GetDisplayConfig
///////////////////////////////////////////////////////////////////////////////


typedef struct _NV_POSITION
{
    NvS32   x;
    NvS32   y;
} NV_POSITION;

typedef struct _NV_RESOLUTION
{
    NvU32   width;
    NvU32   height;
    NvU32   colorDepth;
} NV_RESOLUTION;

typedef struct _NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO
{
    NvU32                   version;

    // Rotation and Scaling
    NV_ROTATE               rotation;       // (IN) rotation setting.
    NV_SCALING              scaling;        // (IN) scaling setting.

    // Refresh Rate
    NvU32                   refreshRate1K;  // (IN) Non-interlaced Refresh Rate of the mode, multiplied by 1000, 0 = ignored

    // Flags
    NvU32                   interlaced:1;   // (IN) Interlaced mode flag, ignored if refreshRate == 0
    NvU32                   primary:1;      // (IN) Declares primary display in clone configuration. This is *NOT* GDI Primary.
                                            // Only one target can be primary per source. If no primary is specified, the first 
                                            // target will automatically be primary.
    NvU32                   reserved:30;    // (IN) Reserved, must be 0

    // TV format information
    NV_GPU_CONNECTOR_TYPE   connector;      // Specify connector type. For TV only, ignored if tvFormat == NV_DISPLAY_TV_FORMAT_NONE
    NV_DISPLAY_TV_FORMAT    tvFormat;       // (IN) to choose the last TV format set this value to NV_DISPLAY_TV_FORMAT_NONE

    // Backend (raster) timing standard
    NV_TIMING_OVERRIDE      timingOverride;     // Ignored if timingOverride == NV_TIMING_OVERRIDE_CURRENT
    NV_TIMING               timing;             // Scan out timing, valid only if timingOverride == NV_TIMING_OVERRIDE_CUST
} NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO;

typedef struct _NV_DISPLAYCONFIG_PATH_TARGET_INFO
{
    NvU32                                           displayId;  // Display ID
    NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO*     details;    // May be NULL if no advanced settings are required
} NV_DISPLAYCONFIG_PATH_TARGET_INFO;

typedef enum _NV_DISPLAYCONFIG_SPANNING_ORIENTATION
{
    NV_DISPLAYCONFIG_SPAN_NONE          = 0,
    NV_DISPLAYCONFIG_SPAN_HORIZONTAL    = 1,
    NV_DISPLAYCONFIG_SPAN_VERTICAL      = 2,
} NV_DISPLAYCONFIG_SPANNING_ORIENTATION;

typedef struct _NV_DISPLAYCONFIG_SOURCE_MODE_INFO
{
    NV_RESOLUTION                           resolution;
    NV_FORMAT                               colorFormat;                // Ignored at present, must be NV_FORMAT_UNKNOWN (0)
    NV_POSITION                             position;                   // Is all positions are 0 or invalid, displays will be automatically positioned from left to right with GDI Primary at 0,0, and all other displays in the order of the path array.
    NV_DISPLAYCONFIG_SPANNING_ORIENTATION   spanningOrientation;        // Spanning is only supported on XP
    NvU32                                   bGDIPrimary : 1;
    NvU32                                   bSLIFocus : 1;
    NvU32                                   reserved : 30;              // Must be 0
} NV_DISPLAYCONFIG_SOURCE_MODE_INFO;

typedef struct _NV_DISPLAYCONFIG_PATH_INFO
{
    NvU32                                   version;
    NvU32                                   reserved_sourceId;          // This field is reserved. There is ongoing debate if we need this field.
                                                                        // Identifies sourceIds used by Windows. If all sourceIds are 0, these will be computed automatically.

    NvU32                                   targetInfoCount;            // Number of elements in targetInfo array
    NV_DISPLAYCONFIG_PATH_TARGET_INFO*      targetInfo;
    NV_DISPLAYCONFIG_SOURCE_MODE_INFO*      sourceModeInfo;             // May be NULL if mode info is not important
} NV_DISPLAYCONFIG_PATH_INFO;

typedef enum _NV_DISPLAYCONFIG_FLAGS
{
    NV_DISPLAYCONFIG_VALIDATE_ONLY          = 0x00000001,
    NV_DISPLAYCONFIG_SAVE_TO_PERSISTENCE    = 0x00000002, 
    NV_DISPLAYCONFIG_DRIVER_RELOAD_ALLOWED  = 0x00000004,               // Driver reload is permitted if neccessary
} NV_DISPLAYCONFIG_FLAGS;

#define NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_VER  MAKE_NVAPI_VERSION(NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO,1)
#define NV_DISPLAYCONFIG_PATH_INFO_VER                  MAKE_NVAPI_VERSION(NV_DISPLAYCONFIG_PATH_INFO,1)

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_GetDisplayConfig
//
// DESCRIPTION:     This API lets caller retrieve the current global display
//                  config.
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      pathInfoCount(IN/OUT) - Number of elements in pathInfo array, returns number of valid topologies
//                  pathInfo(IN/OUT) - Array of path information
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_API_NOT_INTIALIZED - NVAPI not initialized
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_GetDisplayConfig(NvU32* pathInfoCount, NV_DISPLAYCONFIG_PATH_INFO* pathInfo);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_SetDisplayConfig
//
// DESCRIPTION:     This API lets caller apply a global display configuration
//                  across multiple GPUs.
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      pathInfoCount(IN) - Number of supplied elements in pathInfo
//                  pathInfo(IN) - Array of path information
//                  flags(IN) - Flags for applying settings
// 
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_API_NOT_INTIALIZED - NVAPI not initialized
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_SetDisplayConfig(NvU32 pathInfoCount, NV_DISPLAYCONFIG_PATH_INFO* pathInfo, NvU32 flags);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Hybrid_SetHybridModeAndDisplayConfig
//
// DESCRIPTION:     This request will set the hybrid mode, and attempt to 
//                  apply the display settings after the transition. If the 
//                  requested settings cannot be applied, a default path will 
//                  be applied, and status will return NVAPI_PATH_IGNORED.
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      mode(IN)     - hybrid mode
//                  pathInfoCount(IN) - Number of supplied elements in pathInfo
//                  pathInfo(IN) - Array of path information
//                  flags(IN) - Flags for applying settings
//
// RETURN STATUS:
//                  NVAPI_OK - completed request
//                  NVAPI_API_NOT_INTIALIZED - NVAPI not initialized
//                  NVAPI_ERROR - miscellaneous error occurred
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter.
//                  NVAPI_PATH_IGNORED - The transition was successful, but
//                                           the requested path could not
//                                           be applied.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Hybrid_SetHybridModeAndDisplayConfig(NV_HYBRID_MODE mode, NvU32 pathInfoCount, NV_DISPLAYCONFIG_PATH_INFO* pathInfo, NvU32 flags);



typedef struct _NV_TV_CLASSIFICATION_TYPE
{
    NvU32 isPC      : 1;    // supports at least one PC timing, as defined by the VESA specification
    NvU32 isSDTV    : 1;    // supports at least one SDTV timing (720x480i or 720x576i)   
    NvU32 isEDTV    : 1;    // supports at least one EDTV timing (720x480p or 720x576p)
    NvU32 isHDTV    : 1;    // supports at least one HDTV timing (1920x1080i or 1280x720p or above)
    NvU32 reserved  : 28;
} NV_TV_CLASSIFICATION_TYPE;

typedef struct _NV_TV_CLASSIFICATION
{
    NvU32 version;
    // the TV classification based on the combination of the display's EDID (if it 
    // has a valid one)connector, and bandwidth of the display link as determined 
    // by the display driver
    NV_TV_CLASSIFICATION_TYPE identifiedAs;       
    
    // the TV classification based on the modes supported by the entire hardware &
    // software stack, including modes added by an operating system or end user 
    // which are not present in the EDID
    NV_TV_CLASSIFICATION_TYPE treatedAs;    
} NV_TV_CLASSIFICATION;

#define NV_TV_CLASSIFICATION_VER  MAKE_NVAPI_VERSION(NV_TV_CLASSIFICATION,1)

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_GetTvClassification
//
// DESCRIPTION:     Given a display Id, this API returns the monitor's TV 
//                  classifications based on the monitor's EDID or connector 
//                  type and customer's usage.
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      displayId(IN) - NVIDIA Display ID. It is the value 
//                                  returned from 
//                                  NvAPI_SYS_GetDisplayIdFromGpuAndOutputId()
//                  pTvClass(OUT) - Pointer to struct NV_TV_CLASSIFICATION. 
//                                  Returns various TV Classification for a 
//                                  given displayId.
//
// RETURN STATUS:
//                  NVAPI_OK - *pTvClass has a NV_TV_CLASSIFICATION value
//                  NVAPI_API_NOT_INTIALIZED - NVAPI not initialized
//                  NVAPI_INVALID_ARGUMENT - Invalid input parameter.
//                  NVAPI_INCOMPATIBLE_STRUCT_VERSION - Incompatible structure version
//                  NVAPI_NVIDIA_DEVICE_NOT_FOUND - The display specified by displayId is not connected
//                  NVAPI_ID_OUT_OF_RANGE - The DisplayId corresponds to a 
//                                          display which is not within the
//                                          normal outputId range.
//                  NVAPI_ERROR - miscellaneous error occurred
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_GetTvClassification(NvU32 displayId, NV_TV_CLASSIFICATION *pTvClass);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_IDM_ConfigureDisplayForIDM
//
// DESCRIPTION:     Given a display which is already configured to support 
//                  IDM, this API will force-attach the VGA source to prepare
//                  the display for IDM access. This API uses a named 
//                  semaphore to track usage, so the display won't be released
//                  if another application is also accessing IDM-mode on the
//                  specified display.
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      displayName(IN) - GDI name of the display which is 
//                                    already prepared for IDM mode.
//                  pIDMHandle(OUT) - Pointer to an IDM handle used to release
//                                    this display in a later call to
//                                    NvAPI_IDM_ReleaseDisplayFromIDM
//
// RETURN STATUS:
//                  NVAPI_OK - Display is now ready for IDM access
//                  NVAPI_API_NOT_INTIALIZED - NVAPI not initialized
//                  NVAPI_INVALID_ARGUMENT - displayName is not a valid GDI
//                                           display name
//                  NVAPI_EXPECTED_ANALOG_DISPLAY - displayName must point to
//                                                  an analog display
//                  NVAPI_NOT_SUPPORTED - Call only supported on Win7 and above
//                  NVAPI_INVALID_COMBINATION - displayName is not configured
//                                              for IDM support
//                  NVAPI_ERROR - miscellaneous error occurred
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_IDM_ConfigureDisplayForIDM(NvAPI_ShortString displayName, NvIDMHandle* pIDMHandle); 

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_IDM_ReleaseDisplayFromIDM
//
// DESCRIPTION:     Given a display which is already force-attached for IDM, 
//                  this API will detach the VGA source if there are no more
//                  IDM clients accessing the display. 
//
//  SUPPORTED OS: Windows Vista and higher
//
// PARAMETERS:      idmHandle(IN) - Handle acquired from 
//                                  NvAPI_IDM_ConfigureDisplayForIDM
//
// RETURN STATUS:
//                  NVAPI_OK - Display is now ready for IDM access
//                  NVAPI_API_NOT_INTIALIZED - NVAPI not initialized
//                  NVAPI_INVALID_ARGUMENT - idmHandle is not a valid IDM 
//                                           handle
//                  NVAPI_NOT_SUPPORTED - Call only supported on Win7 and above
//                  NVAPI_ERROR - miscellaneous error occurred
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_IDM_ReleaseDisplayFromIDM(NvIDMHandle idmHandle); 



#define MAX_PCLK_RANGES 10

typedef struct
{
    NvU32           uMaxPixClk;                         // Maximum Upper Frequency
    NvU32           uMinPixClk;                         // Minimum Upper Frequency
} NV_PCLK_RANGE;

typedef struct
{
    NvU32           uOrgPixelClock;                     // Original Frequency in Hz
    NvU32           uCurrPixelClock;                    // Frequency in Hz
    NvU32           uCurrSpreadSpectrum;                // Spread Spectrum Range in Hz
    NV_PCLK_RANGE   uFineAdjustBounds;                  // Optional: Upper/Lower bounds
                                                        // If not present then only 
                                                        // course adjustment is supported 
    NV_PCLK_RANGE   uCourseAdjustBounds;                // Timing Shift Upper/Lower
} NV_GET_PCLK;

typedef struct
{
    NV_PCLK_RANGE   uAllowedRanges[MAX_PCLK_RANGES];    // Allowed List
    NV_PCLK_RANGE   uDisallowedRanges[MAX_PCLK_RANGES]; // Disallowed List
} NV_SET_PCLK;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetPixelClockRange
//
// PARAMETERS:    hPhysicalGpu (IN)  - GPU selection
//                outputId     (IN)  - Display output id
//                pTimings     (OUT) - current pixel clock settings
//
//                  NOTE: use hPhysicalGpu=NULL and outputId=0 to specify the
//                        first internal panel
//
//  SUPPORTED OS: Windows Vista and higher
// DESCRIPTION:   Retrieve the current pixel clock settings from the driver.
//
// RETURN STATUS: 
//                NVAPI_OK                  - completed request
//                NVAPI_API_NOT_INITIALIZED - nvapi not initialized
//                NVAPI_ERROR               - miscellaneous error occurred
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPixelClockRange(NvPhysicalGpuHandle hPhysicalGpu, NvU32 outputId, NV_GET_PCLK *pTimings);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_SetPixelClockRange
//
// PARAMETERS:    hPhysicalGpu (IN)  - GPU selection
//                outputId     (IN)  - Display output id
//                pTimings     (IN)  - allowed and disallowed pixel clock ranges
//
//                  NOTE: use hPhysicalGpu=NULL and outputId=0 to specify the
//                        first internal panel
//
//  SUPPORTED OS: Windows Vista and higher
// DESCRIPTION:   Pass allowed and disallowed pixel clock values to the 
//                driver.  If a possible timing found, the driver
//                performs modeset to this timing.
//
// RETURN STATUS: 
//                NVAPI_OK                  - completed request
//                NVAPI_API_NOT_INITIALIZED - nvapi not initialized
//                NVAPI_ERROR               - miscellaneous error occurred
//                NVAPI_INVALID_ARGUMENT    - no suitable pixel clock was found
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetPixelClockRange(NvPhysicalGpuHandle hPhysicalGpu, NvU32 outputId, NV_SET_PCLK *pTimings);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetECCStatusInfo
//
// PARAMETERS:      hPhysicalGpu (IN) - A handle identifying the physical GPU for
//                                      which ECC status information is to be
//                                      retrieved.
//                  pECCStatusInfo (OUT) - A pointer to an ECC status structure.
//
//  SUPPORTED OS: Windows XP and higher
//
// DESCRIPTION:     This function returns ECC memory status information.
//
// RETURN STATUS: 
//    NVAPI_OK - The request was completed successfully.
//    NVAPI_ERROR - An unknown error occurred.
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - The provided GPU handle is not a physical GPU handle.
//    NVAPI_INVALID_HANDLE - The provided GPU handle is invalid.
//    NVAPI_HANDLE_INVALIDATED - The provided GPU handle is no longer valid.
//    NVAPI_INVALID_POINTER - An invalid argument pointer was provided.
//    NVAPI_NOT_SUPPORTED - The request is not supported.
//    NVAPI_API_NOT_INTIALIZED - NvAPI was not yet initialized.
//
///////////////////////////////////////////////////////////////////////////////

typedef enum _NV_ECC_CONFIGURATION
{
    NV_ECC_CONFIGURATION_NOT_SUPPORTED = 0,
    NV_ECC_CONFIGURATION_DEFERRED,           // Changes require a POST to take effect
    NV_ECC_CONFIGURATION_IMMEDIATE,          // Changes can optionally be made to take effect immediately
} NV_ECC_CONFIGURATION;

typedef struct
{
    NvU32                 version;               // Structure version
    NvU32                 isSupported : 1;       // ECC memory feature support
    NV_ECC_CONFIGURATION  configurationOptions;  // Supported ECC memory feature configuration options
    NvU32                 isEnabled : 1;         // Active ECC memory setting
} NV_GPU_ECC_STATUS_INFO;

#define NV_GPU_ECC_STATUS_INFO_VER MAKE_NVAPI_VERSION(NV_GPU_ECC_STATUS_INFO,1)

NVAPI_INTERFACE NvAPI_GPU_GetECCStatusInfo(NvPhysicalGpuHandle hPhysicalGpu, 
                                           NV_GPU_ECC_STATUS_INFO *pECCStatusInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetECCErrorInfo
//
// PARAMETERS:      hPhysicalGpu (IN) - A handle identifying the physical GPU for
//                                      which ECC error information is to be
//                                      retrieved.
//                  pECCErrorInfo (OUT) - A pointer to an ECC error structure.
//
//  SUPPORTED OS: Windows XP and higher
//
// DESCRIPTION:     This function returns ECC memory error information.
//
// RETURN STATUS: 
//    NVAPI_OK - The request was completed successfully.
//    NVAPI_ERROR - An unknown error occurred.
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - The provided GPU handle is not a physical GPU handle.
//    NVAPI_INVALID_POINTER - An invalid argument pointer was provided.
//    NVAPI_INVALID_HANDLE - The provided GPU handle is invalid.
//    NVAPI_HANDLE_INVALIDATED - The provided GPU handle is no longer valid.
//    NVAPI_NOT_SUPPORTED - The request is not supported.
//    NVAPI_API_NOT_INTIALIZED - NvAPI was not yet initialized.
//
///////////////////////////////////////////////////////////////////////////////

typedef struct
{
    NvU32   version;             // Structure version
    struct {
        NvU64  singleBitErrors;  // Number of single-bit ECC errors detected since last boot
        NvU64  doubleBitErrors;  // Number of double-bit ECC errors detected since last boot
    } current;
    struct {
        NvU64  singleBitErrors;  // Number of single-bit ECC errors detected since last counter reset
        NvU64  doubleBitErrors;  // Number of double-bit ECC errors detected since last counter reset
    } aggregate;
} NV_GPU_ECC_ERROR_INFO;

#define NV_GPU_ECC_ERROR_INFO_VER MAKE_NVAPI_VERSION(NV_GPU_ECC_ERROR_INFO,1)

NVAPI_INTERFACE NvAPI_GPU_GetECCErrorInfo(NvPhysicalGpuHandle hPhysicalGpu, 
                                          NV_GPU_ECC_ERROR_INFO *pECCErrorInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_ResetECCErrorInfo
//
// PARAMETERS:      hPhysicalGpu (IN) - A handle identifying the physical GPU for
//                                      which ECC error information is to be
//                                      cleared.
//                  bResetCurrent (IN) - Reset the current ECC error counters.
//                  bResetAggregate (IN) - Reset the aggregate ECC error counters.
//
//  SUPPORTED OS: Windows XP and higher
//
// DESCRIPTION:     This function resets ECC memory error counters.
//
// RETURN STATUS: 
//    NVAPI_OK - The request was completed successfully.
//    NVAPI_ERROR - An unknown error occurred.
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - The provided GPU handle is not a physical GPU handle.
//    NVAPI_INVALID_HANDLE - The provided GPU handle is invalid.
//    NVAPI_HANDLE_INVALIDATED - The provided GPU handle is no longer valid.
//    NVAPI_NOT_SUPPORTED - The request is not supported.
//    NVAPI_API_NOT_INTIALIZED - NvAPI was not yet initialized.
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_GPU_ResetECCErrorInfo(NvPhysicalGpuHandle hPhysicalGpu, NvU8 bResetCurrent,
                                            NvU8 bResetAggregate);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetECCConfigurationInfo
//
// PARAMETERS:      hPhysicalGpu (IN) - A handle identifying the physical GPU for
//                                      which ECC configuration information
//                                      is to be retrieved.
//                  pECCConfigurationInfo (OUT) - A pointer to an ECC
//                                                configuration structure.
//
//  SUPPORTED OS: Windows XP and higher
//
// DESCRIPTION:     This function returns ECC memory configuration information.
//
// RETURN STATUS: 
//    NVAPI_OK - The request was completed successfully.
//    NVAPI_ERROR - An unknown error occurred.
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - The provided GPU handle is not a physical GPU handle.
//    NVAPI_INVALID_HANDLE - The provided GPU handle is invalid.
//    NVAPI_HANDLE_INVALIDATED - The provided GPU handle is no longer valid.
//    NVAPI_INVALID_POINTER - An invalid argument pointer was provided.
//    NVAPI_NOT_SUPPORTED - The request is not supported.
//    NVAPI_API_NOT_INTIALIZED - NvAPI was not yet initialized.
//
///////////////////////////////////////////////////////////////////////////////

typedef struct
{
    NvU32  version;                 // Structure version
    NvU32  isEnabled : 1;           // Current ECC configuration stored in non-volatile memory
    NvU32  isEnabledByDefault : 1;  // Factory default ECC configuration (static)
} NV_GPU_ECC_CONFIGURATION_INFO;

#define NV_GPU_ECC_CONFIGURATION_INFO_VER MAKE_NVAPI_VERSION(NV_GPU_ECC_CONFIGURATION_INFO,1)

NVAPI_INTERFACE NvAPI_GPU_GetECCConfigurationInfo(NvPhysicalGpuHandle hPhysicalGpu, 
                                                  NV_GPU_ECC_CONFIGURATION_INFO *pECCConfigurationInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_SetECCConfiguration
//
// PARAMETERS:      hPhysicalGpu (IN) - A handle identifying the physical GPU for
//                                      which to update the ECC configuration
//                                      setting.
//                  bEnable (IN) - The new ECC configuration setting.
//                  bEnableImmediately (IN) - Request that the new setting take effect immediately.
//
//  SUPPORTED OS: Windows XP and higher
//
// DESCRIPTION:     This function updates the ECC memory configuration setting.
//
// RETURN STATUS: 
//    NVAPI_OK - The request was completed successfully.
//    NVAPI_ERROR - An unknown error occurred.
//    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - The provided GPU handle is not a physical GPU handle.
//    NVAPI_INVALID_HANDLE - The provided GPU handle is invalid.
//    NVAPI_HANDLE_INVALIDATED - The provided GPU handle is no longer valid.
//    NVAPI_NOT_SUPPORTED - The request is not supported.
//    NVAPI_API_NOT_INTIALIZED - NvAPI was not yet initialized.
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_GPU_SetECCConfiguration(NvPhysicalGpuHandle hPhysicalGpu, NvU8 bEnable,
                                              NvU8 bEnableImmediately);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_SYS_VenturaGetState
//
// PARAMETERS:      state (OUT)         - current Ventura state
//
//  SUPPORTED OS: Windows Vista and higher
//
// DESCRIPTION:     This API call is used to query current Ventura state.
//                  If call succeeds, variable state hold one of the following
//                  values:
//                  - NVAPI_VENTURA_STATE_UNSUPPORTED - when executed on
//                  Ventura non-capable system
//                  - NVAPI_VENTURA_STATE_DISABLED - Ventura control is not
//                  active (but system is Ventura capable)
//                  - NVAPI_VENTURA_STATE_ENABLED - Ventura is actively
//                  managing power consumption to stay within defined budget
//
// RETURN STATUS: 
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_INVALID_POINTER - NULL argument passed
//    NVAPI_INVALID_ARGUMENT - incorrect param value
//    NVAPI_NOT_SUPPORTED - call is not supported
//    NVAPI_API_NOT_INTIALIZED - NvAPI not initialized
//
///////////////////////////////////////////////////////////////////////////////
typedef enum _NVAPI_VENTURA_STATE
{
    NVAPI_VENTURA_STATE_UNSUPPORTED,
    NVAPI_VENTURA_STATE_DISABLED,
    NVAPI_VENTURA_STATE_ENABLED

} NVAPI_VENTURA_STATE;

NVAPI_INTERFACE NvAPI_SYS_VenturaGetState(NVAPI_VENTURA_STATE *state);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_SYS_VenturaSetState
//
// PARAMETERS:      state (IN)          - new Ventura state
//
//  SUPPORTED OS: Windows Vista and higher
//
// DESCRIPTION:     This API call is used to control Ventura state.
//                  Valid values for state are:
//                  - NVAPI_VENTURA_STATE_DISABLED - deactivate Ventura
//                  - NVAPI_VENTURA_STATE_ENABLED - activate Ventura
//
// RETURN STATUS: 
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_INVALID_ARGUMENT - incorrect param value
//    NVAPI_NOT_SUPPORTED - call is not supported
//    NVAPI_API_NOT_INTIALIZED - NvAPI not initialized
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_VenturaSetState(NVAPI_VENTURA_STATE state);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_SYS_VenturaGetCoolingBudget
//
// PARAMETERS:      budget (OUT)        - current cooling budget [mW]
//
//  SUPPORTED OS: Windows Vista and higher
//
// DESCRIPTION:     This API call is used to retrieve cooling budget that is
//                  currently being used by Ventura.
//
// RETURN STATUS: 
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_INVALID_POINTER - NULL argument passed
//    NVAPI_INVALID_ARGUMENT - incorrect param value
//    NVAPI_NOT_SUPPORTED - call is not supported
//    NVAPI_API_NOT_INTIALIZED - NvAPI not initialized
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_VenturaGetCoolingBudget(NvU32 *budget);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_SYS_VenturaSetCoolingBudget
//
// PARAMETERS:      budget (IN)         - new cooling budget [mW]
//
//  SUPPORTED OS: Windows Vista and higher
//
// DESCRIPTION:     This API call is used to set new cooling budget
//                  that will be used by Ventura.
//
// RETURN STATUS: 
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_INVALID_ARGUMENT - incorrect param value
//    NVAPI_NOT_SUPPORTED - call is not supported
//    NVAPI_API_NOT_INTIALIZED - NvAPI not initialized
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_VenturaSetCoolingBudget(NvU32 budget);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_SYS_VenturaGetPowerReading
//
// PARAMETERS:      device (IN)         - targeted device
// PARAMETERS:      power (OUT)         - latest power reading [mW]
//
//  SUPPORTED OS: Windows Vista and higher
//
// DESCRIPTION:     This API call is used to query for latest power reading.
//                  'Device' describes desired target device .
//                  If call succeeds, variable 'power' holds device's latest
//                  power reading in [mW] (1/1000 of Watt).
//
//                  Power measurement for device 'system' can be greater than
//                  sum of power measurements for devices 'cpu_0' and 'gpu_0'
//                  since additional devices can be introduced in the future.
//
// RETURN STATUS:
//    NVAPI_OK - completed request
//    NVAPI_ERROR - miscellaneous error occurred
//    NVAPI_INVALID_POINTER - NULL argument passed
//    NVAPI_INVALID_ARGUMENT - incorrect param value
//    NVAPI_NOT_SUPPORTED - call is not supported
//    NVAPI_API_NOT_INTIALIZED - NvAPI not initialized
//
///////////////////////////////////////////////////////////////////////////////
typedef enum _NVAPI_VENTURA_DEVICE
{
    NVAPI_VENTURA_DEVICE_SYSTEM,
    NVAPI_VENTURA_DEVICE_CPU_0,
    NVAPI_VENTURA_DEVICE_GPU_0

} NVAPI_VENTURA_DEVICE;

NVAPI_INTERFACE NvAPI_SYS_VenturaGetPowerReading(NVAPI_VENTURA_DEVICE device, NvU32 *power);

#ifdef __cplusplus
}; //extern "C" {

#endif

#pragma pack(pop)

#endif // _NVAPI_H

